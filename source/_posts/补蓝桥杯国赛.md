---
title: 补蓝桥杯国赛
date: 2018-09-03 08:00:57
tags:
    - 经历
    - C/C++题目
categories: C/C++
description: 第九届蓝桥杯复赛。
---

时间:2018年5月
地点：首都经济贸易大学
事件：第九届蓝桥杯国赛

# 换零钞
x星球的钞票的面额只有：100元，5元，2元，1元，共4种。
小明去x星旅游，他手里只有2张100元的x星币，太不方便，恰好路过x星银行就去换零钱。
小明有点强迫症，他坚持要求200元换出的零钞中2元的张数刚好是1元的张数的10倍，
剩下的当然都是5元面额的。
银行的工作人员有点为难，你能帮助算出：在满足小明要求的前提下，最少要换给他多少张钞票吗？
（5元，2元，1元面额的必须都有，不能是0）

## 分析
这个题目手算都可以算出来，编程的话  也行， 像我懒得算直接写个循环给他跑一下就行了。

## 题解

```C++

# include <bits/stdc++.h>
using namespace std;
int main(){
    int $1 , $2 , $5;
    for ($1 = 5; $1 < 200; $1 = $1 + 5){
        $2 = 10 * $1;
        if((200 - $1 - $2 * 2) % 5 == 0){
            $5 = (200 - $1 - $2 * 2) / 5;
            break;
        }
    }
    cout << $1 + $2 + $5 << endl;
    return 0;
}

```

答案 ：　74


# 激光样式
x星球的盛大节日为增加气氛，用30台机光器一字排开，向太空中打出光柱。
安装调试的时候才发现，不知什么原因，相邻的两台激光器不能同时打开！
国王很想知道，在目前这种bug存在的情况下，一共能打出多少种激光效果？
显然，如果只有3台机器，一共可以成5种样式，即：
全都关上（sorry, 此时无声胜有声，这也算一种）
开一台，共3种
开两台，只1种
30台就不好算了，国王只好请你帮忙了。
要求提交一个整数，表示30台激光器能形成的样式种数。

## 分析
这道题一开始拿上手，好的写个dfs
完了，怎么写来着　
写了两次，　不熟啊，　bfs比较熟，但怎么写。。。
卡了好久，　要不先写后面的吧
瞅了眼格雷码　。。　题目难度是有个梯度的吧　　
哇，我不会卡在这么简单的第二题吧
然后就开始列出数据找规律了(我也不知道我怎么就觉得会有规律)
估计也是到了绝境

好的，出来了　激动的一匹！
｀｀｀
台数　　　开的样式
 1　　　　　2
 2　　　　　3
 3　　　　　5
 4　　　　　8
 5　　　　　13

｀｀｀
这是个什么？　　看着它总觉得特别亲切！　哈哈哈

对的　就是个斐波那契数列。

那就是求fib的第　(30 + 2) 项的值就行了 （因为一台是从第三项开始）

## 题解

```C++
# include <bits/stdc++.h>
using namespace std;
int main(){
    int a = 1, b = 1;
    for (int i= 0; i < 30 ; i ++)
        swap(a , b) , a = a + b;
    cout << a << endl;
    return 0;
}
```

答案 ：2178309

当然  dfs 也是可以的:
```C++
#include <iostream>
using namespace std;
int cnt = 0;
void dfs(int t,bool status){
    if( t == 30){
        cnt++;
        return;
    }
    if(status==0){
        dfs( t + 1 , 1);
        dfs( t + 1 , 0);
    }
    else dfs( t + 1 , 0);
}
int main(){
    dfs(0 , 0);
    cout << cnt;
    return 0;
}

```

# 格雷码

格雷码是以n位的二进制来表示数。
与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。
首尾两个数字也要求只有1位之差。
有很多算法来生成格雷码。以下是较常见的一种：
从编码全0开始生成。
当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0）
当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。
用这个规则产生的4位格雷码序列如下：
0000
0001
0011
0010
0110
0111
0101
0100
1100
1101
1111
1110
1010
1011
1001
1000
以下是实现代码，仔细分析其中逻辑，并填写划线部分缺少的代码。

```C++
#include <stdio.h>  
void show(int a,int n)  
{  
    int i;  
    int msk = 1;  
    for(i=0; i<n-1; i++) msk = msk << 1;  
    for(i=0; i<n; i++){  
        printf((a & msk)? "1" : "0");  
        msk = msk >> 1;  
    }  
    printf("\n");  
}   

void f(int n)  
{  
    int i;  
    int num = 1;  
    for(i=0; i<n; i++) num = num<<1;  

    int a = 0;  
    for(i=0; i<num; i++){  
        show(a,n);  

        if(i%2==0){  
            a = a ^ 1;  
        }  
        else{  
            a = _________________________ ; //填空  
        }  
    }  
}  

int main()  
{  
    f(4);  
    return 0;  
}  
```

## 分析
分析不来啊， 没见过 ， 直接上  ，  一个空 ， 我感觉得几行啊
想想几行应该怎么合成一行呢 ， 三目运算！
可是一个也不够用啊 ，  那就用几个呗
23333  丧心病狂的我  就这样交了上去（还以为是对的，就是想让我们用三目运算符）
见识短浅啊  后来问郭佬才知道是 lowbit（树状数组）的解法去解
具体lowbit 是什么 ， 详见百度吧
https://zh.wikipedia.org/wiki/树状数组
```C++
int lowbit(int x)
{
    return x&(-x);
}
```

答案：a^((a&(-a))<<1)
