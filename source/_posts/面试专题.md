---
title: 面试专题
author: edxuanlen
top: true
cover: false
toc: true
mathjax: false
date: 2020-03-13 14:46:51
img:
coverImg:
password: 
summary: 
tags:
    - Interview
    - Java
categories:
    - Java
description: Java面试常见问题
---

[String相关](/2020/08/07/String相关)
[编码相关问题](/2020/08/07/编码相关问题)
[阻塞队列的使用和区别](/2020/08/04/LinkedBlockingQueue-和-ArrayBlockingQueue的区别)
[Java-IO(Linux-IO)](/2020/08/07/JAVA-IO流)
[Java引用类型](/2020/08/13/Reference和ReferenceQueue)
[ThreadLocal](/2020/08/13/ThreadLocal)
[SpringMVC相关问题(拦截器，过滤器)](/2020/07/18/Spring-MVC)

[并发相关面试题](/2020/04/04/面试题-并发)
[并发](/2020/04/01/并发)

[reids相关](/2020/06/13/redis)
[操作系统相关](/2020/08/10/操作系统相关)
[计算机网络相关](/2020/08/10/计算机网络相关)
[数据库相关](/2020/08/10/数据库相关)
[JVM相关](/2020/03/12/JVM)
[Spring相关](/2020/08/10/Spring)


## Java集合框架

### 数据结构

// TODO

- 数组和链表的区别
- 链表的操作，如反转，链表环路检测，双向链表，循环链表相关操作
- 队列，栈的应用
- 二叉树的遍历方式及其递归和非递归的实现
- 红黑树的旋转


#### Collection

![2020-08-10-12-33-53](http://image.edxuanlen.cn/2020-08-10-12-33-53.png)

#### HashMap

HashMap(java8之前): 数组+链表  关于1.7前的头插法问题在扩容的时候一起看一下
HashMap(java8之后): 数组+链表+红黑树

##### 扩容

代码来看，hashmap有几个构造方法，主要参数涉及到

```JAVA
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

一个是initial_capacity，定义容量大小，默认值16
一个是load_factor 负载因子，会有默认值0.75

```JAVA
if (++size > threshold)  // map.put的源码中有这么一个判断
    resize();
```

threshold 注解是The next size value at which to resize (capacity * load factor).

意思是如果达到capacity*load factor这个值的时候，map就会resize

JDK1.7中，resize的过程大概是引入到transfer中。

```JAVA
 void transfer(Entry[] newTable, boolean rehash) {  
    int newCapacity = newTable.length;  
    for (Entry<K,V> e : table) {  

        while(null != e) {  
            Entry<K,V> next = e.next;
            if (rehash) {  
                e.hash = null == e.key ? 0 : hash(e.key);  
            }  
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i];  
            newTable[i] = e;  
            e = next;  
        } // while
    }
 }
```

假设有T1，T2两个线程同时对一个HashMap进行put操作，刚好，HashMap达到了扩容的条件，两个线程同时对HashMap进行扩容操作。
在扩容的过程中就会引起死循环。类似A.next=B,B.next=A
头插法在rehash的时候，会像栈一样的那种操作，先读取的先hash，也就是比如说这个时候数据是 e -> a -> b; 那么我们塞入到同一个index中的顺序应该是 e -> b -> a;  而这个时候如果T1执行第一个rehash，改变了e -> a，而T2也准备获取 a -> next (就是b), 但是这个时候，

尾插法，直接在末尾插入对应元素，不会变化原Node的next关系,所以不会出现死循环。


- 多线程环境下，调整大小存在条件竞争，容易造成死锁
- rehashing 是一个耗时的过程

#### HashTable

synchronized 锁住整个table

#### ConcurrentHashMap

早期通过分段锁Segment

现在采用了CAS + sync，数组链表红黑树

### 算法

- 内部排序: 如递归排序，交换排序(冒泡排序、快排)、选择排序、插入排序
- 外部排序: 应掌握如何利用有限的内存配合海量的外部存储来处理超大的数据集，写不出来也要有相关的思路

哪些不稳定(堆，快)，稳定意味着什么
不同数据集，各种排序最好或最差的情况
如何优化算法

