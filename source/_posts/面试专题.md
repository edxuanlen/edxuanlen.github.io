---
title: 面试专题
author: edxuanlen
top: true
cover: false
toc: true
mathjax: false
date: 2020-03-13 14:46:51
img:
coverImg:
password: 
summary: 
tags:
    - Interview
    - Java
categories:
    - Java
description: Java面试常见问题
---

## 网络

### OSI七层协议

OSI 并不是一个标准，只是一个概念型框架

![七层](七层.jpg)

- 物理层  
    + 传输比特流  
    + 定义了物理设备的标准(网线类型，光纤接口等)
    + 单位比特
    + 网卡也在这一层工作

- 数据链路层
    + 定义了如何格式化数据进行传输，控制物理介质的访问
    + 错误检测，纠正
    + 将比特数据组成帧，交换机在这层，对帧解码并发送到正确的接收方

- 网络层
    + 把网络地址翻译为物理地址
    + 决定数据如何从发送方路由到接收方
    + 路由器属于网络层
    + 数据包
    + 协议: **IP**

- 传输层
    + 解决主机间的数据传输
    + OSI中最主要的一层
    + 传输协议同时进行流量控制
    + 将数据包强行分割(分割成数据片并给予序列号)
    + TCP协议和UDP协议

- 会话层
    + 自动收发，自动寻址
    + 建立和管理应用程序之间的通信
    + 解决不同系统之间的通信语法的问题

- 表示层
    +  网络协议，需要固定长度，组成的消息头
    + 更方便接收方了解接收的包

- 应用层
    + 更方便的应用接收到的数据
    + HTTP协议

先自上(应用层)而下添加数据头，后自下而上处理数据头部


### OSI的标准:TCP/IP

![TCP/IP](TCP_IP.png)  

先自上(应用层)而下添加数据头，后自下而上处理数据头部

![TCP/IP](TCP_IP1.png)  


### TCP三次握手

基于字节流，将应用层的数据流分割成报文段并发送给目标节点的TCP层  
数据包都有序号，对方收到则发送确认ACK确认，未收到则重传。  
使用校验和来校验的数据在传输过程中是否有误。  

![TCP报文](面试专题/TCP报文.png)

TCP Flags:

+ URG: 紧急指针标志 urgent
+ ACK: 确认序号标志 acknowledgment
+ PSH: push 标志
+ RST: 重置连接标志 Reset
+ SYN: 同步序号，用于建立连接过程
+ FIN: finish标志，释放连接

SYN = 1， ACK = 0 请求链接

#### A => B 通信过程

A 打开 发送SYN = 1, seq = x,进入SYN_SEND状态，等待服务器确认

B 被动打开 发送 SYN = 1, ACK = 1, seq = y, ack = x + 1，此时服务器进入SYN_RECV状态

A 接收后发送 ACK = 1, seq = x + 1, ack = y + 1 ，双方进入ESTABLISHED状态

![三次握手](三次握手.png)

#### 为什么需要三次握手

为了初始化Sequence Number 的初始值

起因:
> Server接收到Client的SYN，回复SYN-ACK的时候未收到ACK
> Server不断充实直至超时，Linux默认等待63秒才断开连接

针对SYN Flood的防护措施

### TCP的四次挥手

#### A => B 四次挥手

A: FIN = 1, seq = u, FIN_WAIT_1
B: ACK = 1, seq = v, ack = u + 1  ,进入CLOSE_WAIT状态(半关闭状态)， 客户端进入 FIN_WAIT_2  
B: FIN = 1, ACK = 1, seq = w, ack = u + 1, LAST_ACK  
A: ACK = 1, seq = u + 1m, ack = w + 1, TIMEWAIT (2 * MSL)

![四次挥手](四次挥手.png)

#### 为什么又TIME_WAIT状态

原因:

+ 确保有足够的时间让对方收到ACK包  
+ 避免新旧连接混淆

#### 为什么需要四次握手才能断开连接

因为全双工，发送方和接收方都需要FIN报文和ACK报文

#### 服务器出现大量CLOSE_WAIT状态的原因

对方关闭socket连接，我方忙于读写，没有及时关闭连接

+ 检查代码，特别是释放资源的代码
+ 检查配置，特别是处理请求的线程配置  

### UDP

#### UDP 特点

+ 面向非连接
+ 不维护连接状态。支持同时向多个客户端传输相同的消息
+ 数据包报头只有8字节，额外开销小
+ 吞吐量只受限于数据生成速率、传输速率以及机器性能
+ 尽量交付，不需要维护复杂的状态表

#### TCP 和 UDP 的区别

+ 面向链接 vs 无连接
+ 可靠 vs 不可靠
+ 有序性 vs 无序性
+ 速度慢 vs 速度快
+ 重量级(20) vs 轻量级(8)

#### TCP 滑动窗口

+ RTT: 发送数据包到收到对应ACK
+ RTO: 重传时间间隔

RTO 由 RTT 计算

滑动窗口: 流量控制和乱序重排

### HTTP

超文本传输协议

- 支持客户/服务器模式 (Client - Server)
- 简单快速 (get/post)
- 灵活

HTTP 请求步骤

- 客户端连接到web服务器
- 发送HTTP请求
- 服务器接受并返回HTTP响应
- 释放连接TCP连接
- 客户端浏览器解析HTML内容

##### 在浏览器地址栏键入一个URL，按下回车之后经历的流程

- 逐层DNS解析
- TCP连接(3次)
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染
- 连接结束(4次挥手)

#### HTTP 状态码

五种可能的取值

- 1XX: 指示信息--表示请求已经接收，继续处理
- 2xx: 成功-- 表示请求已被成功接收、理解、接受
- 3xx: 重定向--要完成请求必须进行进一步操作
- 4xx: 客户端错误--请求有语法错误或请求无法实现
- 5xx: 服务器端错误--服务器未能实现合法的请求

常见状态码

- 200 OK: 正常返回
- 400 Bad Request:客户端请求有语法错误，无法被服务器理解
- 401 Unauthorized: 请求未经授权，这个状态代码必须和WWW-Authenticate 报头域一起使用
- 403 Forbidden: 服务器收到请求，但是拒绝提供服务
- 404 Not Found: 请求资源不存在 (例如输入了错误的URL)
- 500 Internal Server Error: 服务器发生了不可预期的错误
- 503 Server Unavailable: 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。  

#### GET 和 POST 请求的区别

从三个层面来解答

- HTTP报文层面，GET将请求信息放在URL，POST放在报文体中
- 数据库层次: GET符合幂等性和安全性，POST不符合
- 其他层面: GET可以被缓存、被存储，而POST不行

#### Cookie 和 Session的区别

##### Cookie

- 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端
- 客户端再次请求的时候，会把Cookie回发 
- 服务器接收到后，会解析Cookie生成与客户端相对应的内容

发送过程

- Client => HTTP req Server
- Client <= HTTP resp + set-Cookie Server
- Client => HTTP req + Cookie Server
- Client <= HTTP resp Server

##### Session

- 服务器端的机制，在服务器上保存的信息
- 解析客户端请求并操作session id ，按需保存状态信息

实现方式

1. Cookie 来实现
2. URL来回写实现(如果Cookie被禁用)

- Client => req Server
- Client <= resp + set-Cookie:JSESSIONID=xxx Server
- Client => req + Cookie:JSESSIONID=xxx Server
- Client <= resp server

##### 区别

1. Cookie 数据存放在客户的浏览器，Session数据存放在服务器上
2. Session相对于Cookie 更安全
3. 若考虑减轻服务器负担，应当使用Cookie

### HTTP 和 HTTPS


HTTP TCP IP
HTTPS SSL/TLS TCP IP

保护交换数据隐私，安全版的HTTP

#### SSL

(security sockets layer, 安全套接层)

- 为网络通信提供安全及数据完整性的一种安全协议
- 是操作系统对外的API，SSL3.0后更名为TLS
- 采用身份验证和数据加密保证网络通信的安全和数据的完整性

HTTPS 数据传输流程

- 浏览器将支持的加密算法信息发送给服务器
- 服务器选择一套浏览器支持的加密算法，以证书的形式发回给浏览器(CA机构，有效期，公钥，所有者)
- 浏览器验证证书的合法性，并结合证书公钥加密信息发送给服务器
- 服务器使用私钥解密信息，验证哈希，加密相应信息回发浏览器
- 浏览器解密响应消息，并对消息进行验证，之后进行加密交互数据

#### HTTP和HTTPS的区别

- HTTPS需要到CA申请证书，HTTP不需要
- HTTPS密文传输，HTTP明文传输
- 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口
- HTTPS= HTTP+加密+认证+完整新保护，比HTTP更安全

HTTP => HTTPS 301跳转也可能被劫持，因此要用HSTS优化

### Socket

Socket是对TOC/IP的抽象，是操作系统对外开放的接口

#### Socket通信流程

![Socket](socket.jpg)

编写一个网络应用程序,有客户端与服务器端,客户端向服务器发送一个字符串,服务器收到该字符串后将其打印到命令行上,
然后向客户端返回该字符串的长度,最后,客户端输出服务器端返回的该字符串的长度,分别用TCP和UDP两种方式去实现  

## 数据库

### 如何设计一个关系型数据库(RDBMS)

1. 程序实例  
    - 存储管理
    - 缓存机制
    - SQL 解析
    - 日志管理
    - 权限划分
    - 容灾机制
    - 索引管理
    - 锁管理

2. 存储(文件系统)

### 索引模块

#### 为什么要使用索引

快速查询数据

#### 什么信息能成为索引

主键，唯一键以及普通键

#### 索引的数据结构

生成索引，建立二叉查找树进行二分查找
生成索引，建立B-Tree 结构进行查找
生成索引，建立B+Tree 结构进行查找
生成索引，建立Hash结构进行查找

![二叉树](二叉树.png)

#### B Tree

定义

- 根节点至少包括两个孩子
- 书中每个节点最多含有m铬孩子( m>= 2)
- 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子
- 所有叶子节点都位于同一层
- 假设每个非终端节点中包含有n个关键字信息，其中：
    1. Ki(i=1...n)为关键字，且关键字按顺序升序排序K(i-1) < Ki
    2. 关键是个数满足: [ceil(m / 2) - 1] <= n <= m - 1
    3. 非叶子节点的指针:P[1],P[2],... P[M], P[1]指向的关键字小于K[1]的子树，
        P[M]指向关键字大于P[M -1] 的子树，其他P[i]指向关键字属于(K[i-1], K[i])的子树

#### B+ Tree

B+ 树是B树的变体，其定义基本与B树相同，除了：
    - 非叶子节点的子树指针与关键字个数相同
    - 非叶子节点的子树指针P[i],指向关键字值([K[i],K[i+1])
    - 非叶子节点仅用来索引，数据都保存在叶子节点中
    - 所有叶子节点均有一个链指针指向下一个叶子节点

#### 结论

B+ Tree更适合用来做存储索引
    - B+ Tree 的磁盘读写代价更低
    - B+ Tree 的查询效率更加稳定
    - B+ Tree 更加有利于对数据库的扫描

#### Hash索引

优点 查询速度O(1)
缺点:

- 仅仅能够满足'=','IN', 不能使用范围查询
- 无法被用来避免数据的排序操作
- 不能利用部分索引键查询
- 不能避免表扫描
- 遇到大量Hash值相等的情况后性能并不一定会比B Tree索引高

#### 密集索引和稀疏索引的区别

- 密集索引文件中的每个搜索码值都对应一个索引值
- 稀疏索引只为某些值建立索引项

##### InnoDB

- 若一个主键被定义，该主键则作为密集索引
- 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引
- 若不满足以上条件，innodb内部会生成一个隐藏主键(密集索引)
- 非主键索引存储相关键位和其对于的主键值，包含两次查找

myISAM索引和DB是分开的，InnoDB索引和DB是存放在一起的

### 索引问答

Q: 为什么要用索引  
A: 避免全表扫描数据，提升检索效率

Q: 什么样的信息能成为索引  
A: 主键、唯一键等有区分性的数据

Q: 索引的数据结构
A: 主流是B+ Tree，以及hash结构 ， bitMap 等，mysql不支持bitmap，基于innoDB以及myISAM的mysql不显示支持hash


Q: 密集索引和稀疏索引的区别
A: 密集索引文件中的每个搜索码值都对应一个索引值，稀疏索引只为某些值建立索引项

#### mysql

##### 如何定位并优化慢查询sql

- 根据慢日志定位慢查询sql

- 使用explain等工具分析Sql
    - type
        - 表示: 找到数据行的方式
        - index 索引查询 / ALL 证明是全局查找(需要优化)
    - extra
        - 出现以下两项意味着MYSQL根本不能使用索引，效率会受到重大影响，应尽可能对此进行优化
        - Using filesort —— 无法利用索引排序
        - Using temporary  —— 使用了临时表，order by 或者分组查询 group by

- 修改sql 或者让sql尽量走索引  
    - 使用有索引的字段代替
    - 添加索引 alter table tb_name add index idx_name(name);


##### 联合索引的最左匹配原则 


#### 索引是建的越来越多好吗

- 数据量小的表不需要建立索引，建立会增加额外的索引开销
- 数据变更需要维护索引，因此更多的索引意味着更大的维护成本
- 更多的索引意味着需要更多的空间

#### 锁模块

##### MyISAM与InnoDB关于锁方面的区别是什么

- MyISAM 默认使用的是表级锁，不支持行级锁
- InnoDB 默认用的是行级锁，也支持表级锁

共享锁和排斥锁的兼容性

<!-- Share && exclude

|   | X    | S    |
|---|------|------|
| X | 冲突 | 冲突 |
| S | 冲突 | 兼容 | -->

行级锁不一定比表级锁好，锁的粒度越细，带价越高，需要扫描表到对应的对其上锁，代价是比较大的。  

InnoDB 相比 MyISAM 带来了更大的开销。

##### MyISAM适合的场景

- 频繁执行全表count 语句
- 对数据进行增删改的频率不高，查询非常频繁
- 没有事务

##### InnoDB适合的场景

- 数据增删改查都相当频繁
- 可靠性要求比较高，要求支持事务

##### 数据库锁的分类

- 按锁的粒度划分可以分为：表级锁，行级锁，页级锁
- 按锁级别划分，可分为共享锁和排他锁
- 按加锁方式划分，可分为自动锁，显示锁
- 按操作划分可分为DML锁，DDL锁
- 按使用方式划分，可分为乐观锁、悲观锁

### 数据库事务的四大特性

> * A:原子性,Atomicity
> * C:一致性,Consistency
> * I:隔离性,Isolation
> * D:持久性,Durability

### 事务鼓励级别以及各级别下的并发访问问题

并发访问引起的问题和如何避免

- 更新丢失-- mysql 所有事务隔离级别在数据库层面上均可避免
- 脏读-- READ-COMMITTED事务隔离级别以上可避免
- 不可重复读-- REPEATABLE-READ 事务隔离级别以上可避免
- 幻读-- SERIABLIZABLE事务隔离级别可避免

#### 脏读、不可重复读、幻象读概念说明

1. 脏读：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。  
2. 不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。
3. 幻象读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）  

#### 如何避免

| 事务隔离级别 | 更新丢失 | 脏读 | 不可重复读 | 幻读 |
|--------------|----------|------|------------|------|
| 未提交读     | 避免     | 发生 | 发生       | 发生 |
| 已提交读     | 避免     | 避免 | 发生       | 发生 |
| 可重复读     | 避免     | 避免 | 避免       | 发生 |
| 串行化       | 避免     | 避免 | 避免       | 避免 |

在mysql中的innodb引擎,原子性,一致性,隔离性通过redo和undo实现,redo 就是ib_logfile物理文件,而undo默认在共享表空间ibdata里面,通过设置参数可以独立出来.

#### 数据库操作事务隔离

##### 读取未提交的事务里面的数据(脏读)

设置隔离级别方法

```sql
set session transaction isolation level read uncommitted;
```

开始事务

<!-- show variables like '%tx_isolation%'; -->

```sql
set session transaction isolation level read uncommitted;

begain
update propagation set count = count + 1 where id = 1

rollback (回滚操作)
```

另外开一个session 进行查询，可看到并不还没有更改数据。

```sql
set session transaction isolation level read uncommitted;

select * from propagation

```

begain中执行的操作  被第二个进程读到了，导致脏读，一但事务回滚，第二个进程保存的是之前的结果。

#### InnoDB可重复读隔离级别下如何避免幻读

- 表象: 快照读(非阻塞读) -- 伪
    - 当前读是上了锁的增删改查， update,delete,insert
    - 快照读: 不加锁的非阻塞读,select 

### 语法

关键语法

- Group By
- Having
- Count, Sum, Max, Min, Avg

#### Group By

- 满足 "select 自居的列名必须为分组列或列函数
- 列函数对于 group by 子句定义的每个组各返回一个结果

```SQL
# 查询所有同学学号、姓名、选课数、总成绩
SELECT
	s.student_id,
	stu.name,
	COUNT( course_id ),
	SUM( score ) 
FROM
	score s,
	student stu
WHERE
	s.student_id = stu.student_id
GROUP BY
	student_id
```

#### Having

- 通常与Group By 子句一起使用
- WHERE 过滤行，Having过滤组
- 出现在同一sql的顺序: WHERE > GROUP BY > HAVING

## Redis

### 缓存知识考点

#### 缓存中间件-Memcache 和 Redis 的区别

|                    | Memcache | Redis |
|:------------------:|:--------:|:-----:|
|      数据类型      | 类似Hash |  丰富 |
| 数据磁盘持久化存储 |  不支持  |  支持 |
|        主从        |  不支持  |  支持 |
|        分片        |  不支持  |  支持 |

简单key-value可以选择Memcache  

### 为什么Redis能这么快

10w+ QPS(query per second)

- 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高
- 数据结构简单，对数据操作也简单
- 采用单线程，单线程也能处理高并发请求，想多核也可以多实例
- 多路I/O复用模型，非阻塞IO

#### 多路I/O复用

##### I/O复用模型

Redis 采用的I/O多路复用函数: epoll/kqueue/evport/select

- 因地制宜
- 优先选择时间复杂度为O(1)的多路服用函数作为底层实现
- 以时间复杂度为O(n)的select作为保底
- 基于react设计模式监听I/O事件

#### Redis 数据类型

供用户使用的数据类型

- String : 最基本的数据类型，二进制安全(可以存JPG图片)
    - get (key)
    - set (key) (value)
- Hash: String元素组成的字典，适合用于存储对象
    - hget (struct) (key)
    - hmset (struct) (key1) (value1) (key2) (value2) ... 
- List: 列表，按照String元素插入顺序排序(有点像栈)
    - lrange (list) (min) (max)
    - lpush (list) (key)
- Set: Sting 元素组成的无序集合，通过哈希表实现，不允许重复
    - smembers (set)
    - sadd (set) (key)
- Sorted Set: 通过分数来为集合中的成员进行从小到大的排序
    - zrangebyscore (set) (min) (max)
    - zadd (set) (score) (key)
- HyperLogLog 用于计数
- Geo 存储地理位置

##### 底层数据类型基础

- 简单动态字符串
- 链表
- 字典
- 跳跃表
- 整数集合
- 压缩列表
- 对象

### 从海量key里查询出某一固定前缀的key


- KEYS pattern: 查找所有符合给定模式pattern的key
    - KEYS指令一次性返回所有匹配的KEY
    - 键的数量过大会使服务卡顿

- SCAN cursor [MATCH pattern] [COUNT count]
    - 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
    - 以0作为游标开始一次新的迭代，知道命令返回游标0完成一次便利
    - 并不保证每次执行都返回某个给定数量的元素，支持模糊查询
    - 一次返回的数量不可控，只能是大概率符合count参数

### Redis实现分布式锁

分布式锁需要解决的问题

- 互斥性
- 安全性
- 死锁
- 容错

#### SET

SET key value [EX seconds] [PX milliseconds] [NX|XX]

- EX second: 设置键的过期时间为 second 秒
- PX millisecond: 设置键的过期时间为millisecond 毫秒
- NX: 只在键不存在时，才对键进行设置
- XX: 只在键已经存在时，才对键进行设置操作
- SET操作成功完成时，返回OK，否则返回nil

#### 大量的key同时过期的注意事项

集中过期，由于清除大量的key很耗时，会出现断站的卡顿现象
    - 解决方案: 在设置key 的过期时间时，给每个key加上随机值

### 使用Redis做异步队列

使用List作为队列，RPush生产消息，LPOP消费消息

```redis
rpush list aaa
rpush list bbb
rpush list ccc
lpop list // aaa
lpop list // bbb
lpop list // ccc

```

- 缺点： 没有等待，队列里有值就直接消费
- 弥补： 可以通过在应用层引入Sleep机制去调用LPOP重试

如果不想用sleep 可以用BLPOP




#### BLPOP

blpop key [key ...] timeout: 阻塞直到队列有消息或者超时

```redis
session 1:
    blpop list 30  // 为空进入等待30s

session 2:
    rpush list a

session 1:
    1) "a"

```

缺点是只能共给一个消费者使用

#### pub/sub

主题订阅者模式

- 发送者(pub)发送消息，订阅者(sub)接收消息
- 订阅者可以订阅任意数量的频道

```redis
subscribe (channel) 接收广播
publish (channel) (content) 发送广播
```

缺点： 消息的发布是无状态的，无法保证可达

kafka 和 MQ

### 持久化方法之 RDB

RDB(快照)持久化：保存某个时间点的全量数据快照

手动：

- SAVE: 阻塞Redis的服务器进程，直到RDB文件创建完毕
- BGSAVE: Fork出一个子进程来创建RDB文件，不阻塞服务器进程

自动：

- 根据redis.conf配置里面的SAVE m n定时触发(用的是BGSAVE)
- 主从复制时，主节点自动触发
- 执行Debug Reload
- 执行Shutdown且没有开启AOF持久化
 
缺点：

- 内存数据的全量同步，数据量大会由于I/O而严重影响性能
- 可能会因为Redis 挂掉而丢失从当前至最后一次快照期间的数据

### 持久化之 AOF

AOF (Append-Only-File) 持久化：保存写状态

- 记录下除了查询以外的所有变更数据库状态的指令
- 以append的形式追加保存到AOF文件中

日志重写解决AOF文件大小不断增大的问题，原理如下

    - 调用fork(), 创建一个子进程
    - 子进程把新的AOF写道临时文件，不依赖原来的AOF文件
    - 主进程持续把新的变动同时写到内存和原来的AOF里
    - 主进程获取子进程重写AOF的完成信号，往新的AOF同步增量变动
    - 使用新的AOF文件替换掉旧的AOF文件

手动重写指令: BGREWRITEAOF

### RDB和AOF

#### RDB和AOF共存时的恢复流程 

![RDB&AOF](RDB&AOF.png)

#### RDB和AOF的优缺点

|      |               RDB              |                    AOF                   |
|:----:|:------------------------------:|:----------------------------------------:|
| 优点 |  全量数据快照，文件小，恢复快  | 可读性高，适合保存增量数据，数据不易丢失 |
| 缺点 | 无法保存最近一次快照之后的数据 |          文件体积大，恢复时间大          |

### RDB-AOF混合持久化方式

default RDB-AOF

- BGSAVE做镜像全量持久化，AOF做增量持久化

### pipeline 的好处

- pipeline 跟linux 的管道类似
- Redis基于请求/响应模型，单个请求处理需要一一对应
- pipeline批量执行指令，节省多次IO往返的时间
- 有顺序依赖的指令建议分批发送

### redis的同步机制

主从同步原理

#### 全同步过程

- Salve 发送sync 命令到Master
- Master启动一个后台进程，将Redis中的数据快照保存到文件中(BGSAVE)
- Master将保存数据快照期间接收到的写命令缓存起来
- Master完成写文件操作后，将该文件发送给Salve
- 使用新的AOF文件替换掉旧的AOF文件
- Master将这期间收集的增量写命令发送给Salve端

#### 增量同步过程

- Master接收到用户的操作指令，判断是否需要传播到Slave
- 将操作记录追加到AOF文件
- 将操作传播到其他Slave:
    1. 对齐主从库
    2. 往响应缓存写入指令
- 将缓存中的数据发给Slave


### Redis Sentinel 

解决主从同步Master宕机后的主从切换问题：

- 监控： 检查主从服务器是否运行正常
- 提醒： 通过API向管理员或者其他应用程序发送故障通知
- 自动故障迁移：主从切换

#### 流言协议Gossip

在杂乱无章中寻求一致

- 每个节点都随机的与对方通信，最终所有节点达成一致的状态
- 种子节点定期随机向其他节点发送节点列表以及需要传播的信息
- 不保证信息一定会传递给所有节点，但是最终会趋于一致

### Redis 的集群原理

如何从海量数据里快速找到所需？

- 分片：按照某种规则去划分数据，分散存储在多个节点上
- 常规的按照哈希划分无法实现节点的动态增减

一致性哈希算法： 对2^32取模，将哈希值空间组织成虚拟的圆环
将数据key使用相同的函数hash计算出哈希值
 

数据存储节点如下，若Node C宕机，则会存储到D节点上
![Node_C宕机](redis_node_c.png)
 
新增Node X服务器，则在B到X之间的数据(object c)更改存储位置到X的位置上

![Node_X](Node_X.png)

#### Hash环数据倾斜问题

引入虚拟节点解决数据倾斜问题

![vitual_node](vitual_node.png)

## JAVA 

### 类加载机制和双亲委派模型

类的生命周期  
![类的生命周期](类的声明周期.png)

类加载包括 加载 验证 准备 解析 初始化五个阶段  

- 加载: 类加载器(可自己设置)，热部署，加密解密
- 验证: 字节流包含的信息符不符合虚拟机要求，会不会危害虚拟机  
- 准备: 为类变量分配内存，设置初始值。  
- 解析: 将常量池的一些引用替换为实际值。
- 初始化: 赋值
- 使用: 构造过程，构造方法

|类加载器名称|加载范围|
|:-------:|:-------:|
|启动类加载器 Bootstrap ClassLoader | 存放在<JAVA_HOME>\lib 目录中的，并且是虚拟机识别的类库加载到虚拟机内存中的|
|扩展类加载器 Extension ClassLoader| 存放在<JAVA_HOME>\lib\ext 目录中的所有类库，开发者可以直接使用|
|应用程序加载器 Application ClassLoader | 加载用户类路径上指定的类库，开发者可以直接使用，一般情况下这个就是程序中默认的类加载器 |

如何组织类加载器？

虚拟器引入了双亲委派模型  
当一个加载器进行类加载的时候，先委派给双亲加载器加载。双亲无法加载的时候再返回自己加载。
好处: 保证类有合适的优先级的层次关系，保证程序稳定运行。  


### 七个事务传播属性  

什么是事务传播属性  
传播两个方法: 两个方法都带事务，但是事务设置不同。

为什么要事务？
事务是为解决数据安全操作提出的，事务控制实际上就是控制数据的安全访问。

|传播行为|含义|
|:---:|:---:|
|propagation_required（xml文件中为required)|表示当前方法必须在一个具有事务的上下文中运行，如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。（如果被调用端发生异常，那么调用端和被调用端事务都将回滚）|
|propagation_supports(xml文件中为supports)|表示当前方法不必需要具有一个事务上下文，但是如果有一个事务的话，它也可以在这个事务中运行|
|propagation_mandatory(xml文件中为mandatory)|表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常|
|propagation_nested(xml文件中为nested)|表示如果当前方法正有一个事务在运行中，则该方法应该运行在一个嵌套事务中，被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在，并且外层事务抛出异常回滚，那么内层事务必须回滚，反之，内层事务并不影响外层事务。如果封装事务不存在，则同propagation_required的一样|
|propagation_never（xml文件中为never)|表示当方法务不应该在一个事务中运行，如果存在一个事务，则抛出异常|
|propagation_requires_new(xml文件中为requires_new)|表示当前方法必须运行在它自己的事务中。一个新的事务将启动，而且如果有一个现有的事务在运行的话，则这个方法将在运行期被挂起，直到新的事务提交或者回滚才恢复执行。|
|propagation_not_supported（xml文件中为not_supported)|表示该方法不应该在一个事务中运行。如果有一个事务正在运行，他将在运行期被挂起，直到这个事务提交或者回滚才恢复执行|

### Spring中的事务隔离级别

|隔离级别|含义|
|:----:|:----:|
|isolation_default|使用数据库默认的事务隔离级别|
|isolation_read_uncommitted|允许读取尚未提交的修改，可能导致脏读、幻读和不可重复读|
|isolation_read_committed | 允许从已经提交的事务读取，可防止脏读、但幻读，不可重复读仍然有可能发生|
|isolation_repeatable_read|对相同字段的多次读取的结果是一致的，除非数据被当前事务自生修改。可防止脏读和不可重复读，但幻读仍有可能发生|
|isolation_serializable |完全服从acid隔离原则，确保不发生脏读、不可重复读、和幻读，但执行效率最低。|

除了default另外四个与JDBC的隔离级别相对应。




### 高并发如何修改同一行数据

#### jvm解决

1. jvm 下用synchronized锁。


2. lock 锁

try lock finally unlock

JVM 解决不了分布式环境多任务对共享资源竞争的协同操作问题

#### 分布式解决

分布式锁 三种实现方式

- 数据库 (性能差)
- redis (死锁)
- zookeeper

    - 基于异常 (临时节点)
    - 基于相互监听 (性能比较高，占用资源，临时有序节点)

##### Zookeerper 数据结构

- Zookeeper 数据结构类似Linux  
- 每一个节点都有值  


