---
title: 蓝桥杯试题集_基础练习
date: 2019-02-20 16:22:50
tags: 蓝桥杯
categories: C/C++
description: 基础。
---

[蓝桥杯基础练习](http://lx.lanqiao.cn/problemset.page?code=BASIC-)

## BASIC 1 [闰年判断 ](http://lx.lanqiao.cn/problem.page?gpid=T5)

**问题描述**
```
给定一个年份，判断这一年是不是闰年。
当以下情况之一满足时，这一年是闰年：
1. 年份是4的倍数而不是100的倍数；
2. 年份是400的倍数。
其他的年份都不是闰年。
```
**输入格式**
```
输入包含一个整数y，表示当前的年份。
```
**输出格式**
```
输出一行，如果给定的年份是闰年，则输出yes，否则输出no。
说明：当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。
```
**样例输入**
```
2013
```
**样例输出**
```
no
```
**样例输入**
```
2016
```
**样例输出**
```
yes
```
**数据规模与约定**
```
1990 <= y <= 2050
```

**问题分析**
略

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int main(){
	int y;
	cin >> y;
	if( y % 4 == 0 && ( y % 400 == 0 || y % 100 != 0) )
		puts("yes");
	else puts("no");
	return 0;
}
```

## BASIC 2 [01字串](http://lx.lanqiao.cn/problem.page?gpid=T6)

**问题描述**
```
对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是：
00000
00001
00010
00011
00100
请按从小到大的顺序输出这32种01串。
```

**输入格式**
```
本试题没有输入。
```
**输出格式**
```
输出32行，按从小到大的顺序每行一个长度为5的01串。
```
**样例输出**
```markdown
00000
00001
00010
00011
<以下部分省略>
```

**问题分析**
1. 可以循环嵌套实现
2. 可以模拟二进制直接从低位到高位逢2进位
3. 也可以直接使用STL的容器bitset

### AC代码
```C++
// 循环嵌套
# include <bits/stdc++.h>
using namespace std;
int main(){
	for(int i1 = 0; i1 < 2; i1 ++)
		for(int i2 = 0; i2 < 2; i2 ++)
			for(int i3 = 0; i3 < 2; i3 ++)
				for(int i4 = 0; i4 < 2; i4 ++)
					for(int i5 = 0; i5 < 2; i5 ++)
						cout << i1<< i2 << i3 << i4 << i5 << endl;
	return 0;
}
```

```C++
// 模拟二进制
# include <bits/stdc++.h>
using namespace std;
int main(){
	string a = "00000";
	for(int i = 0; i < 32 ; i ++){
		cout << a << endl;
		a[4] += 1;
		for(int j = 4 ; j >= 0 ; j --)
			if(a[j] == '2'){
				a[j - 1] += 1;
				a[j] = '0';
			}
	}
	return 0;
}
```

```C++
# include <bits/stdc++.h>
using namespace std;

int main(){
	for (int i = 0; i < 32; i ++){
		bitset<5> b(i);   // 头文件 <bitset>
		cout << b << endl;
	} 
	return 0;
}

// bitset 容器每个位置存储值只能为0和1
// 用在这里正好合适
```
[bitset文档](http://www.cplusplus.com/reference/bitset/bitset/)


## BASIC 3 [字母图形](http://lx.lanqiao.cn/problem.page?gpid=T7)

**问题描述**
```
利用字母可以组成一些美丽的图形，下面给出了一个例子：
ABCDEFG
BABCDEF
CBABCDE
DCBABCD
EDCBABC
这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。
```
**输入格式**
```
输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。
```
**输出格式**
```
输出n行，每个m个字符，为你的图形。
```
**样例输入**
```
5 7
```
**样例输出**
```markdown
ABCDEFG
BABCDEF
CBABCDE
DCBABCD
EDCBABC
```
**数据规模与约定**
```
1 <= n, m <= 26
```

**问题分析**
可以直接两层循环直接输出ASCII码

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int main(){
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n; i ++){
		for (int j = 0; j < m; j ++)
			putchar( abs(j - i) + 65 );  
		puts("");
	}
	return 0;
}
```

## BASIC 4 [数列特征](http://lx.lanqiao.cn/problem.page?gpid=T8)

**问题描述**
```
给出n个数，找出这n个数的最大值，最小值，和。
```
**输入格式**
```
第一行为整数n，表示数的个数
第二行有n个数，为给定的n个数，每个数的绝对值都小于10000。
```
**输出格式**
```
输出三行，每行一个整数。第一行表示这些数中的最大值，第二行表示这些数中的最小值，第三行表示这些数的和。
```
**样例输入**
```
5
1  3  -2  4  5
```
**样例输出**
```markdown
5
-2
11
```
**数据规模与约定**
```
1 <= n <= 10000
```

**问题分析**
在读入的过程中判断是否是最小和最大值，并加进总和中

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int main(){
	int n, x, Min = 10000, Max = -10000, sum = 0;
	scanf("%d", &n);
	for (int i = 0; i < n; i ++){
		scanf("%d", &x);
		Min = min(Min, x);
		Max = max(Max, x);
		sum += x;
	}
	printf("%d\n%d\n%d\n", Max, Min, sum);
	return 0;
}
```

## BASIC 5 [查找整数](http://lx.lanqiao.cn/problem.page?gpid=T9)

**问题描述**
```markdown
给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。
```
**输入格式**
```markdown
第一行包含一个整数n。
第二行包含n个非负整数，为给定的数列，数列中的每个数都不大于10000。
第三行包含一个整数a，为待查找的数。
```
**输出格式**
```markdown
如果a在数列中出现了，输出它第一次出现的位置(位置从1开始编号)，否则输出-1。
```
**样例输入**
```markdown
6
1 9 4 8 3 9
9
```
**样例输出**
```markdown
2
```
**数据规模与约定**
```markdown
1 <= n <= 1000
```

**问题分析**
读取数组, 然后使用find函数	
### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int main(){
	int n, x;
	int a[1001];
	scanf ("%d", &n);
	for (int i = 0; i < n; i ++)
		scanf("%d", a + i);
	scanf ("%d", &x);
	int ans = find(a, a + n, x) - a;
	if( ans != n ) cout << ans + 1;
	else puts("-1");
	return 0;
}
```
　　
给出n，输出它的前n行。

## BASIC 6 [杨辉三角形](http://lx.lanqiao.cn/problem.page?gpid=T10)

**问题描述**
```markdown
杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。
它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。
下面给出了杨辉三角形的前4行：　
   1
  1 1
 1 2 1　　
1 3 3 1
```
**输入格式**
```markdown
输入包含一个数n。
```
**输出格式**
```markdown
输出杨辉三角形的前n行。每一行从这一行的第一个数开始依次输出，中间使用一个空格分隔。请不要在前面输出多余的空格。
```
**样例输入**
```markdown
4
```
**样例输出**
```markdown
1
1 1
1 2 1
1 3 3 1
```
**数据规模与约定**
```markdown
1 <= n <= 34
```

**问题分析**
略

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int main(){
	int n;
	cin >> n;
	int a[35];
	memset(a, 0, sizeof(a));
	a[0] = 1;
	for (int i = 1; i <= n; i ++){
		for (int j = 0; j < i; j ++)
			printf ("%d ", a[j]);
		int temp = 1;
		for (int j = 1; j <= i + 1; j ++){
			temp = a[j] + temp;
			swap(temp, a[j]);
		}
		puts("");
	}
	return 0;
}
```


## BASIC 7 [特殊的数字](http://lx.lanqiao.cn/problem.page?gpid=T46)
**问题描述**
```markdown
153是一个非常特殊的数，它等于它的每位数字的立方和，即153=1*1*1+5*5*5+3*3*3。编程求所有满足这种条件的三位十进制数。
```
**输出格式**
```markdown
按从小到大的顺序输出满足条件的三位十进制数，每个数占一行。
```
**问题分析**
循环跑一遍，公式都给了，范围是三位数

### AC代码

```C++
# include <bits/stdc++.h> 
using namespace std;

int main(){
	int i,a,b,c; 
	for(i = 100; i < 1000; i ++){
		a = i  /100;	// 百位	
		b = ( i % 100 ) / 10;	// 十位 
		c = i % 10;		// 个位 
		if(i == a * a * a + b * b * b + c * c * c)
			cout << i << endl; 
	} 
	return 0;
}
```
## BASIC 8 [回文数](http://lx.lanqiao.cn/problem.page?gpid=T47)
**问题描述**
```markdown
1221是一个非常特殊的数，它从左边读和从右边读是一样的，编程求所有这样的四位十进制数。
```
**输出格式**
```markdown
按从小到大的顺序输出满足条件的四位十进制数。
```
**问题分析**
直接循环找到千位和个位相等，百位和十位相等。

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int main(){
	for (int i = 1001; i < 10000; i ++){
		if( i % 10 == i / 1000 && i % 100 / 10 == i / 100 % 10)
			cout << i << endl;
	}	
	return 0;
}
```

## BASIC 9 [特殊回文数](http://lx.lanqiao.cn/problem.page?gpid=T48)
**问题描述**
```markdown
123321是一个非常特殊的数，它从左边读和从右边读是一样的。
输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。
```
**输入格式**
```markdown
输入一行，包含一个正整数n。
```
**输出格式**
```markdown
按从小到大的顺序输出满足条件的整数，每个整数占一行。
```
**样例输入**
```markdown
52
```
**样例输出**
```markdown
899998
989989
998899
```
**数据规模与约定**
```markdown
1 <= n <= 54
```
**问题分析**
六位数是回文数，且六个数总和是n。
取高三位，总和为n / 2。因此如果为奇数则一定没有解。

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int main(){
	int n;
	cin >> n;
	if( n % 2 != 0 )
		for (int i = 1; i < 10; i ++)
			for (int j = 0; j < 10; j ++)
				for (int k = 0; k < 10; k ++)
					if( i + j + k == n / 2)
						cout << i << j << k << k << j << i << endl;
	return 0;
}
```

## BASIC 10 [十进制转十六进制](http://lx.lanqiao.cn/problem.page?gpid=T49)
**问题描述**
```markdown
十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F共16个符号，分别表示十进制数的0至15。
十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的30在十六进制中是1E。
给出一个非负整数，将它表示成十六进制的形式。
```
**输入格式**
```markdown
输入包含一个非负整数a，表示要转换的数。0<=a<=2147483647
```
**输出格式**
```markdown
输出这个整数的16进制表示
```
**样例输入**
```markdown
30
```
**样例输出**
```markdown
1E
```
**问题分析**
这类问题模仿十进制转二进制的过程即可，使用了STL的string

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

string Turn(int n, int d){
	string ans;
	if( !n ) puts("0");
	while ( n ){
		int x = n % d;
		if( x < 10 ) ans += x + 48;
		else ans += 55 + x;
		n /= d;
	}
	reverse(ans.begin(), ans.end());
	return ans;
}

int main(){
	int n;
	cin >> n;
	cout << Turn(n, 16);
	return 0;
}
```

## BASIC 11 [十六进制转十进制](http://lx.lanqiao.cn/problem.page?gpid=T50)
**问题描述**
```markdown
从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。
注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。
```
**样例输入**
```markdown
FFFF
```
**样例输出**
```markdown
65535
```
**问题分析**
(FFFF)<sub>H</sub> => (65535)<sub>D</sub>
也就是 F * 16 <sup>0</sup> + F * 16 <sup>1</sup> + F * 16 <sup>2</sup> + F * 16 <sup>3</sup> = 65535.
这里F代表的是数字15
需要注意的是不能用int，FFFFFFFF会爆int。
### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

typedef long long ll;
unsigned int Pow(int d, int p){
	unsigned int mul = 1;
	while ( -- p ) mul *= d;
	return mul;
}

unsigned int Turn(string str, int d){
	unsigned int sum = 0;
	for (int i = str.size() - 1; i >= 0; i --)
		if( str[i] < 57 )
			sum += (str[i] - 48) * Pow(d, str.size() - i);
		else
			sum += (str[i] - 55) * Pow(d, str.size() - i);
	return sum;
}

int main(){
	string str;
	cin >> str;
	cout << Turn(str, 16);
	return 0;
}
```


## BASIC 12 [十六进制转八进制](http://lx.lanqiao.cn/problem.page?gpid=T51)
**问题描述**
```markdown
给定n个十六进制正整数，输出它们对应的八进制数。
```
**输入格式**
```
输入的第一行为一个正整数n （1<=n<=10）。
接下来n行，每行一个由0~9、大写字母A~F组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。
```
**输出格式**
```
输出n行，每行为输入对应的八进制正整数。
【注意】
输入的十六进制数不会有前导0，比如012A。
输出的八进制数也不能有前导0。
```
**样例输入**
```markdown
2
39
123ABC
```
**样例输出**
```markdown
71
4435274
```
**提示**
先将十六进制数转换成某进制数，再由某进制数转换成八进制。

**问题分析**
很多人第一眼看到这题，十六进制转十进制再转八进制即可，思路同上两题。但这题要注意到的是数据范围，每个十六进制数长度不超过100000。
我的做法是转成二进制，而不是十进制。
这个对上题的代码需要进行改动。
但to_string函数编译不通过手写一个To_string。
### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

string hexTurnbin(string str){
	string bin;
	for (int i = 0; i < str.size(); i ++){
		int hex = str[i] < 65 ? str[i] - 48 : str[i] - 55;
		string t;
		while( hex ){
			t += hex % 2 + 48;
			hex /= 2;
		}
		reverse(t.begin(), t.end());
		for (int i = t.size(); i < 4; i ++) bin += '0';  // 二进制补前置0
		bin += t;
	}
	return bin;
}

string To_string(int n){
	string str;
	if( n )
		while( n ){
			str += (n % 10 + 48);
			n /= 10;
		}
	else str = "0";
	reverse(str.begin(), str.end());
	return str;
}

string binTurnoct(string str){
	string oct;
	int M = 1, mul = 0;
	for (int i = str.size() - 1; i >= 0; i --){
		mul += M * (str[i] - 48);
		M *= 2;
		if( M == 8 ){
			M = 1;
			oct += To_string(mul);  // to_string 用于int 转成 string
			mul = 0;
		}
	}
	if( mul ) oct += To_string(mul);
	reverse(oct.begin(), oct.end());
	return oct;
}

int main(){
	int n;
	cin >> n;
	while ( n -- ){
		string str;
		cin >> str;
		str = hexTurnbin(str);
		str = binTurnoct(str);
		int i = 0;
		for (; i < str.size(); i ++) if( str[i] != 48 ) break;
		for (; i < str.size(); i ++) putchar(str[i]);
		putchar('\n');
	}
	return 0;
}
```

## BASIC 13 [数列排序](http://lx.lanqiao.cn/problem.page?gpid=T52)
**问题描述**
```markdown
给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1<=n<=200
```
**输入格式**
```markdown
第一行为一个整数n。
第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。
```
**输出格式**
```markdown
输出一行，按从小到大的顺序输出排序后的数列。
```
**样例输入**
```markdown
5
8 3 6 4 9
```
**样例输出**
```markdown
3 4 6 8 9
```
**问题分析**
直接使用algorithm里面的sort函数即可(有兴趣可以自己了解sort实现的方法)

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int a[201];
int main(){
	int n;
	cin >> n;
	for(int i = 0; i < n; i ++)
		scanf("%d", &a[i]);
	sort(a, a + n);
	for(int i = 0; i < n; i ++)
		printf("%d ", a[i]);
	return 0;
}
```


## BASIC 14 [时间转换](http://lx.lanqiao.cn/problem.page?gpid=T54)
**问题描述**
```markdown
给定一个以秒为单位的时间t，要求用“<H>:<M>:<S>”的格式来表示这个时间。<H>表示时间，<M>表示分钟，而<S>表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。
```
**输入格式**
```markdown
输入只有一行，是一个整数t（0<=t<=86399）。
```
**输出格式**
```markdown
输出只有一行，是以“<H>:<M>:<S>”的格式所表示的时间，不包括引号。
```
**样例输入**
```markdown
0
```
**样例输出**
```markdown
0:0:0
```
**样例输入**
```markdown
5436
```
**样例输出**
```markdown
1:30:36
```
**问题分析**
略

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int main(){
	int t;
	cin >> t;
	printf("%d:%d:%d", t / 3600 , (t / 60 % 60), t % 60);
	return 0;
}
```

## BASIC 15 [字符串对比](http://lx.lanqiao.cn/problem.page?gpid=T56)
**问题描述**
```markdown
　　给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一：
　　1：两个字符串长度不等。比如 Beijing 和 Hebei
　　2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing
　　3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和 BEIjing
　　4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing
　　编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。
```
**输入格式**
```markdown
包括两行，每行都是一个字符串
```
**输出格式**
```markdown
仅有一个数字，表明这两个字符串的关系编号
```
**样例输入**
```markdown
BEIjing
beiJing 
```
**样例输出**
```markdown
3
```
**问题分析**
使用transform 函数使string 整个转大写或小写。

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int main(){
	string str1, str2;
	cin >> str1 >> str2;
	if ( str1.size() != str2.size() ) cout << "1";
	else if ( str1 == str2 ) cout << "2";
	else{
		transform(str1.begin(), str1.end(), str1.begin(), ::toupper);
		transform(str2.begin(), str2.end(), str2.begin(), ::toupper);
		if( str1 == str2 ) cout << "3";
		else cout << "4";
	}
	return 0;
}
```

## BASIC 16 [分解质因数 ](http://lx.lanqiao.cn/problem.page?gpid=T57)
**问题描述**
```markdown
求出区间[a,b]中所有整数的质因数分解。
```
**输入格式**
```markdown
输入两个整数a，b。
```
**输出格式**
```markdown
每行输出一个数的分解，形如k=a1*a2*a3...(a1<=a2<=a3...，k也是从小到大的)(具体可看样例)
```
**样例输入**
```markdown
3 10
```
**样例输出**
```markdown
3=3
4=2*2
5=5
6=2*3
7=7
8=2*2*2
9=3*3
10=2*5
```
**提示**
先筛出所有素数，然后再分解。

**数据规模与约定**
```markdown
1 <= n <= 1,000,000
```
**问题分析**
打出素数表，然后按素数表顺序用 2 3 5 7 9，依次选择。
若可以整除，则除以这个素数。

例如 18 = 2， 3， 3。

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int a, b, k = 0;
int p[10001];
int P[5000];
void init(){
	memset(p, 0, sizeof(p));
	p[0] = p[1] = 1;
	for (int i = 2; i <= b; i ++)
		if( !p[i] ){
			P[k ++] = i;
			for (int j = 2; i * j <= b; j ++)
				p[i * j] = 1;
		}	
}

int main(){
	cin >> a >> b;
	init();
	for(int i = a; i <= b; i ++){
		int j = i, h = 0;
		printf("%d=", i);
		if( !p[i] )	{
			printf("%d\n", i);
			continue;
		}
		while ( j > 1 ){
			while ( j % P[h] == 0 ){
				if( j == P[h] )
					cout << P[h];
				else
					cout << P[h] << "*";
				j /= P[h];
			}
			h ++;
		}
		putchar('\n');
	}
	return 0;
}
```
## BEGIN 17:
[矩阵乘法](http://lx.lanqiao.cn/problem.page?58)
### 问题描述
```
给定一个N阶矩阵A，输出A的M次幂（M是非负整数）
例如：
　　A =
　　1 2
　　3 4
　　A的2次幂
　　7 10
　　15 22
```
**输入格式**
```
第一行是一个正整数N、M（1<=N<=30, 0<=M<=5），表示矩阵A的阶数和要求的幂数
接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值
```
**输出格式**
```
输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开
```
**样例输入**
```
2 2
1 2
3 4
```
**样例输出**
```
7 10
15 22
```

**问题分析**
直接对矩阵进行乘法运算，但要注意一点的是，数组开int类型会爆。
也可以学习矩阵快速幂。

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

typedef long long ll;
int n;
typedef struct matnode{
	ll a[31][31];
	void reset (){
		for (int i = 0; i < n; i ++)
			a[i][i] = 1;
	}
	void print(){
		for (int i = 0; i < n; i ++){
			for (int j = 0; j < n; j ++)
				printf("%lld ", a[i][j]);
			putchar('\n');
		}
	}
}mat;

mat operator * ( mat a, mat b ){  // 重载乘法
	mat ans;
	for (int i = 0; i < n; i ++)
		for (int j = 0; j < n; j ++){
			ans.a[i][j] = 0;
			for (int k = 0; k < n; k ++)
				ans.a[i][j] += a.a[i][k] * b.a[k][j];
	}
	return ans;
}

mat qpow( mat a, int m ){   //快速幂
	mat ans;
	ans.reset();
	while ( m ){
		if( m & 1 )
			ans = ans * a;
		a = a * a;
		m /= 2;
	}
	return ans;
}

int main(){
	int  m;
	cin >> n >> m;
	mat a;
	for (int i = 0; i < n; i ++)
		for (int j = 0; j < n; j ++)
			scanf ("%lld", &a.a[i][j]);
	a = qpow( a, m );
	a.print();
	
	return 0;
}

```




