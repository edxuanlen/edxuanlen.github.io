---
title: 计算机网络相关
author: edxuanlen
top: false
cover: false
toc: true
mathjax: false
date: 2020-08-10 10:47:33
img:
coverImg:
password:
summary:
tags:
    - 计网
    - Interview
categories:
    - Interview
description: 计算机网络相关问题
---


## 网络

### OSI七层协议

OSI 并不是一个标准，只是一个概念型框架

![七层](http://image.edxuanlen.cn/2020-08-10-10-51-20.png)


- 物理层  
    + 传输比特流  
    + 定义了物理设备的标准(网线类型，光纤接口等)
    + 单位比特
    + 网卡也在这一层工作

- 数据链路层
    + 定义了如何格式化数据进行传输，控制物理介质的访问
    + 错误检测，纠正
    + 将比特数据组成帧，交换机在这层，对帧解码并发送到正确的接收方

- 网络层
    + 把网络地址翻译为物理地址
    + 决定数据如何从发送方路由到接收方
    + 路由器属于网络层
    + 数据包
    + 协议: **IP**

- 传输层
    + 解决主机间的数据传输
    + OSI中最主要的一层
    + 传输协议同时进行流量控制
    + 将数据包强行分割(分割成数据片并给予序列号)
    + TCP协议和UDP协议

- 会话层
    + 自动收发，自动寻址
    + 建立和管理应用程序之间的通信
    + 解决不同系统之间的通信语法的问题

- 表示层
    +  网络协议，需要固定长度，组成的消息头
    + 更方便接收方了解接收的包

- 应用层
    + 更方便的应用接收到的数据
    + HTTP协议

先自上(应用层)而下添加数据头，后自下而上处理数据头部

![2020-08-10-11-11-16](http://image.edxuanlen.cn/2020-08-10-11-11-16.png)

### TCP/IP

![2020-08-10-10-54-30](http://image.edxuanlen.cn/2020-08-10-10-54-30.png)

### TCP三次握手

基于字节流，将应用层的数据流分割成报文段并发送给目标节点的TCP层  
数据包都有序号，对方收到则发送确认ACK确认，未收到则重传。  
使用校验和来校验的数据在传输过程中是否有误。  

![2020-08-10-11-10-55](http://image.edxuanlen.cn/2020-08-10-11-10-55.png)

标志位中的 TCP Flags:

+ URG: 紧急指针标志 urgent
+ ACK: 确认序号标志 acknowledgment
+ PSH: push 标志
+ RST: 重置连接标志 Reset
+ SYN: 同步序号，用于建立连接过程
+ FIN: finish标志，释放连接

SYN = 1， ACK = 0 请求链接

#### A => B 通信过程

A 打开 发送SYN = 1, seq = x,进入SYN_SEND状态，等待服务器确认

B 被动打开 发送 SYN = 1, ACK = 1, seq = y, ack = x + 1，此时服务器进入SYN_RECV状态

A 接收后发送 ACK = 1, seq = x + 1, ack = y + 1 ，双方进入ESTABLISHED状态

![2020-08-10-11-12-14](http://image.edxuanlen.cn/2020-08-10-11-12-14.png)

#### 为什么需要三次握手

为了初始化Sequence Number 的初始值

起因:
> Server接收到Client的SYN，回复SYN-ACK的时候未收到ACK
> Server不断重试直至超时，Linux默认等待63秒才断开连接

针对SYN Flood的防护措施

#### 为什么不是两次或四次

TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！

若是两次握手：A与B的初始序列号达成了一致。但是B无法明确知道A是否已经收到了自己的同步信号，如果这个信号丢失，双发序列号将无法达成一致。所以需要第三次握手，回应一个ACK

### TCP的四次挥手

#### A => B 四次挥手

A: FIN = 1, seq = u, FIN_WAIT_1
B: ACK = 1, seq = v, ack = u + 1  ,进入CLOSE_WAIT状态(半关闭状态)， 客户端进入 FIN_WAIT_2  
B: FIN = 1, ACK = 1, seq = w, ack = u + 1, LAST_ACK  
A: ACK = 1, seq = u + 1m, ack = w + 1, TIMEWAIT (2 * MSL)

#### 为什么TIME_WAIT状态

(2MSL) 两倍最大报文段传输时间

原因:

+ 确保有足够的时间让对方收到ACK包  
+ 避免新旧连接混淆

#### 为什么需要四次握手才能断开连接

因为全双工，发送方和接收方都需要FIN报文和ACK报文

#### 服务器出现大量CLOSE_WAIT状态的原因

对方关闭socket连接，我方忙于读写，没有及时关闭连接

+ 检查代码，特别是释放资源的代码
+ 检查配置，特别是处理请求的线程配置  

### UDP

#### UDP 特点

+ 面向非连接
+ 不维护连接状态。支持同时向多个客户端传输相同的消息
+ 数据包报头只有8字节，额外开销小
+ 吞吐量只受限于数据生成速率、传输速率以及机器性能
+ 尽量交付，不需要维护复杂的状态表

#### TCP 和 UDP 的区别

+ 面向链接 vs 无连接
+ 可靠 vs 不可靠
+ 有序性 vs 无序性
+ 速度慢 vs 速度快
+ 重量级(20) vs 轻量级(8)

#### TCP 滑动窗口

+ RTT: 发送数据包到收到对应ACK
+ RTO: 重传时间间隔

RTO 由 RTT 计算

滑动窗口: 流量控制和乱序重排

### HTTP

超文本传输协议

- 支持客户/服务器模式 (Client - Server)
- 简单快速 (get/post)
- 灵活

HTTP 请求步骤

- 客户端连接到web服务器
- 发送HTTP请求
- 服务器接受并返回HTTP响应
- 释放连接TCP连接
- 客户端浏览器解析HTML内容

##### 在浏览器地址栏键入一个URL，按下回车之后经历的流程

- 逐层DNS解析
- TCP连接(3次)
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染
- 连接结束(4次挥手)

#### HTTP 状态码

五种可能的取值

- 1XX: 指示信息--表示请求已经接收，继续处理
- 2xx: 成功-- 表示请求已被成功接收、理解、接受
- 3xx: 重定向--要完成请求必须进行进一步操作
- 4xx: 客户端错误--请求有语法错误或请求无法实现
- 5xx: 服务器端错误--服务器未能实现合法的请求

常见状态码

- 200 OK: 正常返回
- 400 Bad Request:客户端请求有语法错误，无法被服务器理解
- 401 Unauthorized: 请求未经授权，这个状态代码必须和WWW-Authenticate 报头域一起使用
- 403 Forbidden: 服务器收到请求，但是拒绝提供服务
- 404 Not Found: 请求资源不存在 (例如输入了错误的URL)
- 500 Internal Server Error: 服务器发生了不可预期的错误
- 503 Server Unavailable: 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。  

#### GET 和 POST 请求的区别

从三个层面来解答

- HTTP报文层面，GET将请求信息放在URL，POST放在报文体中
- 数据库层次: GET符合幂等性和安全性，POST不符合
- 其他层面: GET可以被缓存、被存储，而POST不行

#### Cookie 和 Session的区别

##### Cookie

- 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端
- 客户端再次请求的时候，会把Cookie回发 
- 服务器接收到后，会解析Cookie生成与客户端相对应的内容

发送过程

- Client => HTTP req Server
- Client <= HTTP resp + set-Cookie Server
- Client => HTTP req + Cookie Server
- Client <= HTTP resp Server

##### Session

- 服务器端的机制，在服务器上保存的信息
- 解析客户端请求并操作session id ，按需保存状态信息

实现方式

1. Cookie 来实现
2. URL来回写实现(如果Cookie被禁用)

- Client => req Server
- Client <= resp + set-Cookie:JSESSIONID=xxx Server
- Client => req + Cookie:JSESSIONID=xxx Server
- Client <= resp server

##### 区别

1. Cookie 数据存放在客户的浏览器，Session数据存放在服务器上
2. Session相对于Cookie 更安全
3. 若考虑减轻服务器负担，应当使用Cookie

### HTTP 和 HTTPS


HTTP TCP IP
HTTPS SSL/TLS TCP IP

保护交换数据隐私，安全版的HTTP

#### SSL

(security sockets layer, 安全套接层)

- 为网络通信提供安全及数据完整性的一种安全协议
- 是操作系统对外的API，SSL3.0后更名为TLS
- 采用身份验证和数据加密保证网络通信的安全和数据的完整性

HTTPS 数据传输流程

- 浏览器将支持的加密算法信息发送给服务器
- 服务器选择一套浏览器支持的加密算法，以证书的形式发回给浏览器(CA机构，有效期，公钥，所有者)
- 浏览器验证证书的合法性，并结合证书公钥加密信息发送给服务器
- 服务器使用私钥解密信息，验证哈希，加密相应信息回发浏览器
- 浏览器解密响应消息，并对消息进行验证，之后进行加密交互数据

#### HTTP和HTTPS的区别

- HTTPS需要到CA申请证书，HTTP不需要
- HTTPS密文传输，HTTP明文传输
- 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口
- HTTPS= HTTP+加密+认证+完整新保护，比HTTP更安全

HTTP => HTTPS 301跳转也可能被劫持，因此要用HSTS优化

### Socket

Socket是对TOC/IP的抽象，是操作系统对外开放的接口

#### Socket通信流程

![2020-08-10-11-24-44](http://image.edxuanlen.cn/2020-08-10-11-24-44.png)

编写一个网络应用程序,有客户端与服务器端,客户端向服务器发送一个字符串,服务器收到该字符串后将其打印到命令行上,
然后向客户端返回该字符串的长度,最后,客户端输出服务器端返回的该字符串的长度,分别用TCP和UDP两种方式去实现  
