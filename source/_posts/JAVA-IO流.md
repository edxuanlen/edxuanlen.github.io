---
title: JAVA IO流
author: edxuanlen
top: false
cover: false
toc: true
mathjax: false
date: 2020-08-07 10:29:42
img:
coverImg:
password:
summary:
tags: 
    - JAVA
    - 操作系统
categories:
description:
---

## 分类方法

### 流向

输入流 输出流

### 操作单元

字节流和字符流

#### 字节流

数据单元是8位字节

主要使用InputStream OutputStream作为基类

#### 字符流

数据单元为16位字节

主要使用Reader,Writer作为基类

### 角色划分

节点流和处理流

## 字节流和字符流

### 怎么选择

1. 大多数情况下使用字节流会更好，因为大多数时候 IO 操作都是直接操作磁盘文件，所以这些流在传输时都是以字节的方式进行的（图片等都是按字节存储的）  
2. 如果对于操作需要通过 IO 在内存中频繁处理字符串的情况使用字符流会好些，因为字符流具备缓冲区，提高了性能。

### 缓冲区的作用

1. 缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性能。  
2. 对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 **flush** 方法操作。  

### 字符流和字节流的区别

1. 字符流和字节流的使用非常相似，但是实际上字节流的操作不会经过缓冲区（内存）而是直接操作文本本身的，而字符流的操作会先经过**缓冲区**（内存）然后通过缓冲区再操作文件。  

### 序列化和流的关系

1. 序列化就是一种用来处理对象流的机制，将对象的内容进行流化。可以对流化后的对象进行读写操作，可以将流化后的对象传输于网络之间。序列化是为了解决在对象流读写操作时所引发的问题。  
2. 序列化的实现：将需要被序列化的类实现Serialize接口，没有需要实现的方法，此接口只是为了标注对象可被序列化的，然后使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputStream(对象流)对象，再使用ObjectOutputStream对象的write(Object obj)方法就可以将参数obj的对象写出。

### PrintStream、BufferedWriter、PrintWriter的比较

1. PrintStream类的输出功能非常强大，通常如果需要输出文本内容，都应该将输出流包装成PrintStream后进行输出。它还提供其他两项功能。与其他输出流不同，PrintStream 永远不会抛出 IOException；而是，异常情况仅设置可通过 checkError 方法测试的内部标志。另外，为了自动刷新，可以创建一个 PrintStream  
2. BufferedWriter:将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过write()方法可以将获取到的字符输出，然后通过newLine()进行换行操作。BufferedWriter中的字符流必须通过调用flush方法才能将其刷出去。并且BufferedWriter只能对字符流进行操作。如果要对字节流操作，则使用BufferedInputStream
3. PrintWriter的println方法自动添加换行，不会抛异常，若关心异常，需要调用checkError方法看是否有异常发生，PrintWriter构造方法可指定参数，实现自动刷新缓存（autoflush）  

## 节点流和处理流

### BufferedReader属于哪种流,它主要是用来做什么的,它里面有那些经典的方法

属于处理流中的缓冲流，可以将读取的内容存在内存里面，有readLine()方法，它，用来读取一行

### 什么是节点流,什么是处理流,它们各有什么用处,处理流的创建有什么特征

1. 节点流 直接与数据源相连，用于输入或者输出
2. 处理流：在节点流的基础上对之进行加工，进行一些功能的扩展
3. 处理流的构造器必须要 传入节点流的子类


## 其他面试题 

### 流一般需要不需要关闭,如果关闭的话在用什么方法,一般要在那个代码块里面关闭比较好，处理流是怎么关闭的，如果有多个流互相调用传入是怎么关闭的

1. 流一旦打开就必须关闭，使用close方法
2. 放入finally语句块中（finally 语句一定会执行）
3. 调用的处理流就关闭处理流
4. 多个流互相调用只关闭最外层的流

### InputStream里的read()返回的是什么,read(byte[] data)是什么意思,返回的是什么值

1. 返回的是所读取的字节的int型（范围0-255）
2. read（byte [ ] data）将读取的字节储存在这个数组。返回的就是传入数组参数个数  

### OutputStream里面的write()是什么意思,write(byte b[], int off, int len)这个方法里面的三个参数分别是什么意思


1. write将指定字节传入数据源
2. Byte b[ ]是byte数组
3. b[off]是传入的第一个字符、b[off+len-1]是传入的最后的一个字符 、len是实际长度


## IO和NIO

[参考 zengxiantao博客](https://blog.csdn.net/zengxiantao1994/article/details/88094910?utm_medium=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-4.opensearch_close_1&depth_1-utm_source=distribute.pc_relevant_right.none-task-blog-BlogCommendFromMachineLearnPai2-4.opensearch_close_1)

### 区别

Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。  

1. Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write() 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。
2. Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。

此外NIO具有选择器，**能管理多个通道**

### 使用场景

NIO也会有缺点，每次都要判断缓存区数据是否完整或者已经读取完毕，每次处理之前都要检测缓存区数据。  

1. 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候用NIO处理数据可能是个很好的选择。
2. 而如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更合适。使用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作比较来权衡选择。

## NIO

### 核心组件

Java NIO的三个核心基础组件，Channels、Buffers、Selectors。

#### Channel

所有的IO操作在NIO中都是以Channel开始的。一个Channel就像一个流，NIO Channel和流很近似但是也有一些不同。

1. 你既可以读取也可以写入到Channel，流只能读取或者写入，inputStream和outputStream。
2. Channel可以异步地读和写。
3. channel永远都是从一个buffer中读或者写入到一个buffer中去。

基本的Channel实现有以下这些：

1. FileChannel：向文件当中读写数据；
2. DatagramChannel：通过UDP协议向网络读写数据；
3. SocketChannel：通过TCP协议向网络读写数据；
4. ServerSocketChannel：以一个web服务器的形式，监听到来的TCP连接，对每个连接建立一个SocketChannel。

#### Buffer

1. 容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。容量在缓冲区创建时被设定，并且永远不能被改变。
2. 上界（Limit）：写模式中等价于buffer的大小，即capacity；读模式中为当前缓冲区中一共有多少数据，即可读的最大位置。这意味着当调用filp()方法切换成读模式时，limit的值变成position的值，而position重新指向0。
3. 位置（Position）：下一个要被读或写的元素的位置。初始化为0，buffer满时，position最大值为capacity-1。切换成读模式的时候，position指向0。Position会自动由相应的 get( )和 put( )函数更新。
 
position和limit的值在读/写模式中是不一样的。capacity的值永远表示buffer的大小。
  下图解释了在读/写模式中Capacity，Position和Limit的意思。

![2020-08-07-15-15-09](http://image.edxuanlen.cn/2020-08-07-15-15-09.png)

#### Selector

Selector允许一个线程来监视多个Channel，这在当你的应用建立了多个连接，但是每个连接吞吐量都较小的时候是可行的。例如：一个聊天服务器。图为一个线程使用Selector处理三个Channel。
![2020-08-07-15-19-42](http://image.edxuanlen.cn/2020-08-07-15-19-42.png)

## BIO 

### 传统 BIO

通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在 while(true) 循环中服务端会调用 accept() 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作。

### 伪异步 IO

为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。

## AIO (Asynchronous I/O)

AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。

## 操作系统中的IO

在Linux(UNIX)操作系统中，共有五种IO模型，分别是：阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动IO模型以及异步IO模型。  

### 阻塞IO

阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。条件满足，则进行下一步操作。

应用进程通过系统调用 recvfrom 接收数据，但由于内核还未准备好数据报，应用进程就会阻塞住，直到内核准备好数据报，recvfrom 完成数据报复制工作，应用进程才能结束阻塞状态。

![2020-08-07-16-33-49](http://image.edxuanlen.cn/2020-08-07-16-33-49.png)

### 非阻塞IO

应用进程与内核交互，目的未达到之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据准备有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中。

应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回error，应用进程在得到error后，过一段时间再发送recvfrom请求。在两次发送请求的时间段，进程可以先做别的事情。  

![2020-08-07-16-34-08](http://image.edxuanlen.cn/2020-08-07-16-34-08.png)

### 信号驱动型IO

应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。

应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。

![2020-08-07-16-34-21](http://image.edxuanlen.cn/2020-08-07-16-34-21.png)

### IO复用类型

多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。

IO多路转接是多了一个select函数，多个进程的IO可以注册到同一个select上，当用户进程调用该select，select会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，select调用进程会阻塞。当任意一个IO所需的数据准备好之后，select调用就会返回，然后进程在通过recvfrom来进行数据拷贝。

这里的IO复用模型，并没有向内核注册信号处理函数，所以，他并不是非阻塞的。进程在发出select后，要等到select监听的所有IO操作中至少有一个需要的数据准备好，才会有返回，并且也需要再次发送请求去进行文件的拷贝。

### 异步IO

应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。
用户进程发起aio_read操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后再通知进程本次IO已经完成。

![2020-08-07-16-55-16](http://image.edxuanlen.cn/2020-08-07-16-55-16.png)

### 对比IO

![2020-08-07-16-56-27](http://image.edxuanlen.cn/2020-08-07-16-56-27.png)

