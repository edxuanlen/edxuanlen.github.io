---
title: 蓝桥杯试题集_入门训练
date: 2019-02-20 02:02:11
tags: 蓝桥杯
categories: C/C++
description: 入门。
---


[蓝桥杯入门训练](http://lx.lanqiao.cn/problemsets.page)

## BEGIN 1:
[A+B问题](http://lx.lanqiao.cn/problem.page?gpid=T1)
### 问题描述
```
输入A、B，输出A+B。
说明：在“问题描述”这部分，会给出试题的意思，以及所要求的目标。
```
**输入格式**
```
输入的第一行包括两个整数，由空格分隔，分别表示A、B。
说明：“输入格式”是描述在测试你的程序时，所给的输入一定满足的格式。

做题时你应该假设所给的输入是一定满足输入格式的要求的，所以你不需要对输入的格式进行检查。
多余的格式检查可能会适得其反，使用你的程序错误。

在测试的时候，系统会自动将输入数据输入到你的程序中，你不能给任何提示。比如，你在输入的时候提示“请输入A、B”之类的话是不需要的，这些多余的输出会使得你的程序被判定为错误。
```
**输出格式**
```
输出一行，包括一个整数，表示A+B的值。
说明：“输出格式”是要求你的程序在输出结果的时候必须满足的格式。

在输出时，你的程序必须满足这个格式的要求，不能少任何内容，也不能多任何内容。如果你的内容和输出格式要求的不一样，你的程序会被判断为错误，包括你输出了提示信息、中间调试信息、计时或者统计的信息等。
```
**样例输入**
```
12 45
说明：“样例输入”给出了一组满足“输入格式”要求的输入的例子。

这里给出的输入只是可能用来测试你的程序的一个输入，在测试的时候，还会有更多的输入用来测试你的程序。
```
**样例输出**
```
 57
说明：“样例输出”给出了一组满足“输出格式”要求的输出的例子。

样例输出中的结果是和样例输入中的是对应的，因此，你可以使用样例的输入输出简单的检查你的程序。

要特别指出的是，能够通过样例输入输出的程序并不一定是正确的程序，在测试的时候，会用很多组数据进行测试，而不局限于样例数据。有可能一个程序通过了样例数据，但测试的时候仍只能得0分，可能因为这个程序只在一些类似样例的特例中正确，而不具有通用性，再测试更多数据时会出现错误。

比如，对于本题，如果你写一个程序不管输入是什么都输入57，则样例数据是对的，但是测试其他数据，哪怕输入是1和2，这个程序也输出57，则对于其他数据这个程序都不正确。

数据规模与约定
-10000 <= A, B <= 10000。
说明：“数据规模与约定”中给出了试题中主要参数的范围。

这个范围对于解题非常重要，不同的数据范围会导致试题需要使用不同的解法来解决。比如本题中给的A、B范围不大，可以使用整型(int)来保存，如果范围更大，超过int的范围，则要考虑其他方法来保存大数。

有一些范围在方便的时候是在“问题描述”中直接给的，所以在做题时不仅要看这个范围，还要注意问题描述。
```
### 问题分析
略

### AC代码
**本题的C++源代码如下：**

```C++
#include <iostream>
 
using namespace std;
 
int main()
{
    int a, b;
    cin >> a >> b;
    cout << a + b;
    return 0;
}
```

**本题的C源代码如下：**

```C
#include <stdio.h>
 
int main()
{
    int a, b;
    scanf("%d%d", &a, &b);
    printf("%d", a+b);
    return 0;
}
```

**本题的Java源代码如下：**

```JAVA
import java.util.*;
 
public class Main
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        Integer a = sc.nextInt();
        Integer b = sc.nextInt();
        System.out.println(a + b);
    }
}
```

## BEGIN 2:
[ 序列求和](http://lx.lanqiao.cn/problem.page?gpid=T2)
### 问题描述
```
求1+2+3+...+n的值。
输入包括一个整数n。

```
```
样例输入

```
```
样例输出

```
### 问题分析
略

### AC代码

```C++
#include <iostream>
 
using namespace std;
 
int main()
{
    int a, b;
    cin >> a >> b;
    cout << a + b;
    return 0;
}
```


## BEGIN 2:
[序列求和](http://lx.lanqiao.cn/problem.page?gpid=T2)
### 问题描述
```
求1+2+3+...+n的值。
```
**输入格式**
```
输入包括一个整数n。
```
**输出格式**
```
输出一行，包括一个整数，表示1+2+3+...+n的值。
```
**样例输入**
```
4
```
**样例输出**
```
10
```
**样例输入**
```
100
```
**样例输出**
```
5050
```
**数据规模与约定**
```
1 <= n <= 1,000,000,000
```
### 问题分析
数据范围比较大如果累加会超时如下代码:

```C++
while (n) ans += n --;
```
所以应该使用求和公式


### AC代码
```C++
# include <stdio.h>
type long long ll;
int main() {
	ll n;
	scanf("%d", &n);
 	printf("%I64d", (1 + n) * n / 2);
 	return 0;
}
```

## BEGIN 3:
[圆的面积](http://lx.lanqiao.cn/problem.page?gpid=T3)
### 问题描述
```
给定圆的半径r，求圆的面积。
```
**输入格式**
```
输入包含一个整数r，表示圆的半径。
```
**输出格式**

```
输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。

说明：在本题中，输入是一个整数，但是输出是一个实数。
对于实数输出的问题，请一定看清楚实数输出的要求，比如本题中要求保留小数点后7位，则你的程序必须严格的输出7位小数，输出过多或者过少的小数位数都是不行的，都会被认为错误。
实数输出的问题如果没有特别说明，舍入都是按四舍五入进行。
```
**样例输入**
```
4
```
**样例输出**
```
50.2654825
```
**数据规模与约定**
```
1 <= r <= 100000
本题对精度要求较高，请注意π的值应该取较精确的值。你可以使用常量来表示π，比如PI=3.14159265358979323，也可以使用数学公式来求π，比如PI=atan(1.0)*4。
```
### 问题分析
使用浮点数计算

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

double PI=3.14159265358979323;
int main(){
	int r;
	scanf ("%d", &r);
	printf ("%.7lf", PI * r * r);
	return 0;
}
```

## BEGIN 4:
[Fibonacci数列](http://lx.lanqiao.cn/problem.page?gpid=T4)
### 问题描述
```
Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。
当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。
```
**输入格式**
```
输入包含一个整数n。
```
**输出格式**
```
输出一行，包含一个整数，表示Fn除以10007的余数。
说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。
```
**样例输入**
```
10
```
**样例输出**
```
55
```
**样例输入**
```
22
```
**样例输出**
```
7704
```
**数据规模与约定**
```
1 <= n <= 1,000,000
```
### 问题分析
略

### AC代码

```C++
# include <bits/stdc++.h>
using namespace std;

int MOD = 10007;
int main(){
	int n;
	while (cin >> n){
		int a = 1, b = 1;
		if (n <= 2){  				// n <= 2时都是1
			cout << "1" << endl;
			continue;
		}
		while (-- n){
			swap(a, b);
			b = (a + b) % MOD;
		}
		cout << a << endl;
	}
	return 0;
}
```

