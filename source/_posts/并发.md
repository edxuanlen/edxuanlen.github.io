---
title: 并发
author: edxuanlen
top: false
cover: false
toc: true
mathjax: false
date: 2020-04-01 23:29:55
img:
coverImg:
password:
summary:
tags:
    - Interview
    - Java
categories:
    - Java
description: 线程进程、锁、线程池、JMM
---

## 线程和进程

### 进程和线程的区别

#### 进程和线程的由来

- 串行: 串行执行任务，需要长时间等待用户输入
- 预处理:预先将用户指令集中成清单，批量串行处理用户指令，任无法并发执行
- 进程: 进程独占内存空间。保存各自运行状态，相互不干扰且可切换，为并发处理任务提供了可能性
- 线程: 共享进程的内存资源，相互切换更快速，支持更细粒度的任务控制，使进程内的子任务得以并发执行

#### 区别

进程是资源分配的最小单位，线程是CPU调度的最小单位

- 所有与进程相关的资源都被记录在PCB中(进程控制块)
- 进程是抢占处理机的调度单位，线程属于某个进程，共享其资源
- 线程只由堆栈寄存器、程序计数器和TCB组成(线程控制块)

- 线程不是独立应用。而进程可以看做独立应用
- 进程又独立的空间，相互不影响，县城只是进程不同的执行路径
- 线程没有独立的地址空间，多进程的程序比多线程程序健壮
- 进程的切换比线程的切换开销大

### 进程和线程的关系

- Java堆操作系统提供的功能进行封装，包括进程和线程
- 运行一个程序会产生一个进程，进程包含至少一个线程
- 每个进程对应一个JVM实例，多个线程共享JVM里的堆
- Java采用单线程编程模型，程序会自动创建主线程
- 主线程可以创建子线程，原则上要晚于子线程结束

### Thread有几种新启线程的方法

类Thread和接口Runnable

### Thread和Runnable是什么关系

Thread是类，Runnable是接口
Thread是Java对线程的抽象
Runnable是对任务，对事务逻辑的抽象

- Thread是实现了Runnable接口的类，使得run支持多线程
- 因类的单一继承原则，推荐多使用Runnable接口

### 如何让线程安全的停止工作

stop interrupt isInterupted static方法interupted

死锁状态不理会中断

### Thread中的start和run方法的区别

Thread#start() => JVM_StartThread => thread_entry => Thread#run()

- 调用start()方法会创建一个新的子线程并启动
- run() 方法只是Thread的一个普通方法的调用，线程是原来的线程

### 如何给run()方法传参

- 构造函数传参
- 成员变量传参
- 回调函数传参

### 如何实现线程的返回值

- 主线程等待
- Thread类的join方法
- Callable接口实现: 通过FutureTask or 线程池获取

### 线程的状态

![线程状态间转换](http://www.edxuanlen.cn/2020-04-02-13-26-30.png)

六个状态

- 新建(New): 创建后尚未启动的线程的状态
- 运行(Runnable):包含Running和Ready
- 无限期等待(Waiting): 不会被分配CPU执行时间，需要显性被唤醒
- 限期等待(Timed Waiting): 在一定时间后会由系统自动唤醒
- 阻塞(Blocked): 等待获取排他锁
- 结束(terminated): 已终止线程的状态，线程已经结束运行

### 如何让两个线程顺序执行--join 方法

使线程变成了串行执行

### 线程优先级

```java
thread.setPriority(1) // 1~10 default 5
```

不一定时间片就会长，取决于处理器

### 守护线程

- 用户线程new Thread创建的线程都是非守护线程  
- thread.sleep  thread.interrupt 都是守护线程

主线程结束，守护线程也结束

### sychronized

对象锁 //  
类锁 // 本质是class 对象锁

// TODO

### volatile

JVM提供的轻量级同步机制

- 保证被volatile修饰的共享变量对所有线程总是可见的
- 禁止指令重排序优化

可见，但不保证原子性  
适用场景一写多读

#### volatile 的可见性

如何实现?

- 当写一个 volatile变量时,JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中
- 当读取个 volatile变量时,JM会把该线程对应的工作内存置为无效

### ThreadLocal

为每一个线程提供变量的副本
实现了线程隔离

Spring 实现事务的时候使用了ThreadLocal

#### ThreadLocal内存泄漏

每个Thread 维护一个 ThreadLocalMap，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object，也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。仔细观察ThreadLocalMap，这个map是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。

![引用链](http://www.edxuanlen.cn/2020-04-03-22-49-10.png)

虚线表示的是弱引用

#### 错误使用ThreadLocal导致线程不安全

错误的使用了同一个对象(static方法)

### 线程间的协作

#### 等待/通知机制

##### sleep和wait

- sleep是Thread类的方法，wait是Object类中定义的方法
- Sleep()方法可以在任何地方使用
- wait()只能在synchronized方法或synchronized块中使用

本质区别

- Thread.sleep只会让出CPU，不会导致锁行为改变
- Object.wait不仅让出CPU，还会释放已经占有的同步资源锁

##### notify和notifyall 的区别

两个概念

- EntryList 锁池
- WaitSet 等待池

- notifyAll会让所有处于等待池的线程进入锁池中去竞争获取锁的机会
- notify 只会随机选取一个处于等待池中的线程进入锁池去竞争

### yield

Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示

## 线程的并发工具类

### Fork-Join

分治思想， 拆分成若干小任务，最后将小任务运算的结果进行join汇总

#### 工作密取

即当前线程的Task已经全被执行完毕，则自动取到其他线程的Task池中取出Task继续执行。
ForkJoinPool中维护着多个线程（一般为CPU核数）在不断地执行Task，每个线程除了执行自己职务内的Task之外，还会根据自己工作线程的闲置情况去获取其他繁忙的工作线程的Task，如此一来就能能够减少线程阻塞或是闲置的时间，提高CPU利用率。

#### Fork/Join使用的标准范式

我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork和join的操作机制，通常我们不直接继承ForkjoinTask类，只需要直接继承其子类。

1. RecursiveAction，用于没有返回结果的任务
2. RecursiveTask，用于有返回值的任务

task要通过ForkJoinPool来执行，使用submit 或 invoke 提交，两者的区别是：invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码；submit是异步执行。
join()和get方法当任务完成的时候返回计算结果。

![compute](http://www.edxuanlen.cn/%E5%B9%B6%E5%8F%91-1)

在我们自己实现的compute方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用invokeAll方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。

### CountDownLatch 和 Cyclic Barrier

CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以反复使用。  
CountDownLatch.await一般阻塞工作线程，所有的进行预备工作的线程执行countDown，而CyclicBarrier通过工作线程调用await从而自行阻塞，直到所有工作线程达到指定屏障，再大家一起往下走。
在控制多个线程同时运行上，CountDownLatch可以不限线程数量，而CyclicBarrier是固定线程数。
同时，CyclicBarrier还可以提供一个barrierAction，合并多线程计算结果。

### semaphore

semaphore 限流，实现数据库连接池

``` java
public class DBPoolSemaphore {

    private final static int POOL_SIZE = 10;
//    private Semaphore semaphore;

    private final Semaphore useful, useless;
    private static LinkedList<Connection> pool = new LinkedList<>();

    static {
        for (int i = 0; i < POOL_SIZE; i ++){
            pool.addLast(SqlConnectImpl.fetchConnection());
        }
    }

    public DBPoolSemaphore() {
        this.useful = new Semaphore(POOL_SIZE);
        this.useless = new Semaphore(0);
    }

    public Connection fetchConnect() throws InterruptedException {
        useful.acquire();
        Connection connection;
        synchronized (pool){
            connection = pool.removeFirst();
        }
        useless.release();
        return connection;
    }

    public void releaseConnect(Connection connection) throws InterruptedException {
        if (connection != null){
            System.out.println("当前有" + useful.getQueueLength() + "个线程等待数据库连接"
                + "\n 可用连接数为: " + useful.availablePermits());
            useless.acquire();
            synchronized (pool){
                pool.addLast(connection);
            }
            useful.release();
        }
    }
}
```

### Exchange

两个线程之间的交互，数据交换

### Future, FutureTask, Callable

Runnable是一个接口，在它里面只声明了一个run()方法，由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。  
Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。  
Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。  

```java
UseCallable useCallable = new UseCallable();
FutureTask<Integer> futureTask = new FutureTask<>(useCallable);

new Thread(futureTask).start();

Random r = new Random();

Thread.sleep(10);
if (r.nextInt(100) > 50){
    System.out.println("Get UseCallable result = " + futureTask.get());
} else {
    System.out.println("cancel....");
    futureTask.cancel(true);
}
```

## 原子操作 CAS

### 什么是原子操作

假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。

### 如何实现原子操作

- 实现原子操作可以使用锁，锁机制。  

但是如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况。  

- 实现原子操作还可以使用当前的处理器基本都支持CAS()的指令，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。
    循环CAS就是在一个循环里不断的做cas操作，直到成功为止。
    语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。

![CAS自旋](http://www.edxuanlen.cn/2020-04-20-01-07-58.png)

### CAS 实现原子操作的三大问题

#### ABA问题

因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。  

解决： 追加版本号

#### 循环时间长开销大

自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销

#### 只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。  
从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。

### jdk中相关原子操作类

#### AtomicInteger

- int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。
- boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。
- int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。
- int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。

#### AtomicIntegerArray

主要是提供原子的方式更新数组里的整型，其常用方法如下。

- int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。  
- boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。

### 更新引用类型

原子更新基本类型的AtomicInteger只能更新一个变量，更新多个则需要使用原子更新引用类型提供的类。

#### AtomicReference

原子更新引用类型。

#### AtomicStampedReference

利用版本戳的形式记录了每次改变以后的版本号，这样的话就不会存在ABA问题了。

#### AtomicMarkableReference

原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。

## 显示锁和AQS

AbstractQueuedSynchronizer

### 显式锁

有了内置锁 synchronized 为什么还要Lock?
Java程序是靠synchronized 关键字实现锁功能的，使用synchronized 关键字将会隐式地获取锁，但是它将锁的获取和释放固定化了，也就是先获取再释放。

### Lock的标准用法

```Java
lock.lock();
try{
    count ++;
} finally{
    lock.unlock();
}
```

在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。  
不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。

### Lock常用API

![2020-05-20-16-14-35](http://www.edxuanlen.cn/2020-05-20-16-14-35.png)

### ReentrantLock

#### 锁的可重入

简单地讲就是：“同一个线程对于已经获得到的锁，可以多次继续申请到该锁的使用权”。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁。ReentrantLock在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。

#### 公平和非公平锁

如果在时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。事实上，公平的锁机制往往没有非公平的效率高。  
在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。

#### 读写锁ReentrantReadWriteLock

锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。

一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量  
ReentrantReadWriteLock其实实现的是ReadWriteLock接口

### Condition 接口

实现一组类似监视器的方法，与Lock配合可以实现等待/通知模式。

### LockSupport

LockSupport 定义了一组公共静态方法，这些方法提供了最基本的线程阻塞喝唤醒功能，而LockSupport也成为构建同步组件的基础工具。  
LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。

### CLH队列锁

CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。  

CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。CLH队列锁常用在SMP体系结构下。  

### AQS 中的数据结构-节点和同步队列

AQS是CLH队列锁的一种变体实现，节点数据结构应该考虑哪些信息？  

1、线程信息，肯定要知道我是哪个线程  
2、队列中线程状态  
3、前驱和后继线程



### 学习AQS的必要性

队列同步器AbstractQueuedSynchronizer（以下简称同步器或AQS），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。

### AQS 使用方式和设计模式

AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在AQS里由一个int型的state来代表这个状态，在抽象方法的实现过程中免不了要对同步状态进行 更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。

## 并发容器




<!--
### ReentrantLock

- synchronized 是mark word ,lock调用unsafe的park方法

### Lock 和 synchronized

Lock以及它的一个实现类ReentrantLock是jdk5新增加的， Lock也可以用于实现多线程的同步

区别
synchronized既可以加在方法上，也可以加载特定代码块上，而lock需要显示地指定起始位置和终止位置；
synchronized是托管给JVM执行(底层使用mutex lock实现)，lock的锁定是通过代码实现的，它有比synchronized更精确的线程语义；
synchronized获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁。而Lock则需要开发人员手动释放，并且必须在finally中释放，否则会引起死锁；
性能上的区别：在Java1.5中，synchronize是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java1.6上synchronize的性能并不比Lock差



### JMM (Java Memory Model) -- Java内存模式

#### JMM 主内存

- 存储Java实例对象
- 包括有成员变量、类信息、常量、静态变量等
- 属于数据共享的区域，多线程并发操作时会引发线程安全问题

#### JMM的工作内存

- 存储当前方法的所有本地变量信息，本地变量对其他线程不可见
- 字节码行号指示器、Native方法信息
- 属于线程私有的数据区域，不存在线程安全问题

#### JMM与Java内存区域划分是不同的概念层次

- JMM描述的是一组规则，围绕原子性，有序性，可见性展开
- 相似点: 存在共享区和私有区域

#### 主内存与工作内存的数据存储类型以及操作方式归纳

- 方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中
- 引用类型的本地变量: 引用存储在工作内存中，实例存储在主内存中
- 成员变量、static变量、类信息均存储在主内存中
- 主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新主内存

#### JMM怎么实现可见性

##### 指令重排序需要满足条件

- 单线程环境下不能改变程序运行的结果
- 存在数据以来关系的不允许重排序

无法通过happens-before原则推导出来的，才能进行指令的重排序
A操作的结果需要对B操作可见，则A与B存在happens-before关系

##### happens-before八大原则

1. 程序次序规则:一个线程内,按照代码顺序,书写在前面的操作先行发生于肀写在后面的操作;
2. 锁定规则:一个 unlock操作先行发生于后面对同一个锁的lock操作;
3. volatile变量规则:对一个变量的写操作先行发生于后面对这个变量的读操作 
4. 传递规则:如果操作A先行发生于操作B,而操作B又先行发生于操作C,则可以得出操作A先行发生于操作C;
5. 线程启动规则: Thread对象的 start(方法先行发生于此线程的每一个动作;
6. 线程中断规则:对线程 Interrupt0方法的调用先行发生于被中断线程的代码检测到中断事件的发生;
7. 线程终结规则:线程中所有的操作都先行发生于线程的终止检测,我们可以过 Thread join(方法结束、 Thread isalive0的返回值手段检测到线程已经终止执行;
8. 对象终结规则:一个对象的初始化完成先行发生于他的 Finalize0方法的开始



###### 如何禁止重排优化

内存屏障(memory barrier)

1. 保证特定操作的执行顺序
2. 保证某些变量的内存可见性

通过内存屏障指令禁止在内存屏障前后的指令执行重新排序优化  
强制刷出各种CPU的缓存数据,因此任何CPU上的线程都能读取到这些数据的最新版本

### CAS

sync是悲观锁，假定会并发冲突
乐观锁假定并发不冲突 CAS

- 支持原子更新操作，适用于计算器，序列发生器等场景
- 属于乐观锁机制，号称lock-free
- CAS操作失败时由开发者决定是继续尝试，还是执行别的操作

#### CAS思想

- 包含三个操作数-- 内存位置(V)、预期原值(A)和新值(B)

### 线程池

1. newFixedThreadPool -->

