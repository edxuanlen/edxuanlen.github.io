---
title: JVM
author: edxuanlen
top: false
cover: false
toc: true
mathjax: false
date: 2020-03-12 14:52:47
img:
coverImg:
password:
summary:
tags:
    - Interview
    - Java
categories:
    - Java
description: JVM要点
---


## JVM

### 谈谈你对Java的理解

- 平台无关性
- GC
- 语言特性(泛型、反射)
- 面向对象
- 库类
- 异常处理

#### Compile Once, Run Anywhere如何实现

- 编译时
- 运行时

javac编译，生成字节码

![ 跨平台](JAVA跨平台.png)

Java源码首先被编译为字节码，再由不同平台的JVM进行解析，Java语言在不同平台上运行时不需要进行重新编译，Java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令。

#### 为什么JVM不直接将源码解析成机器码去执行

为什么要先编译成字节码再解析成机器码

- 准备工作: 每次执行都需要各种检查
- 兼容性: 也可以将别的语言解析成字节码

#### JVM如何加载.class文件

![JVM](JVM.png)

- Class Loader: 依据特定格式，加载class文件到内存 (本地接口)
- Execution Engine: 对命令进行解析 (解释器)
- Native Interface: 融合不同开发语言的原生库为Java所用
- Runtime Data Area: JVM内存空间结构模型

#### 谈谈反射

##### 列举反射的例子

// TODO 添加代码

#### ClassLoader

类从编译到执行的过程

- 将源文件编译为字节码文件
- ClassLoader将字节码转换为JVM中的Class< xx >对象
- JVM利用Class< xx > 对象实例化为 xx 对象

Classloader在Java中有着非常重要的作用,它主要工作在 Class 装载的加载阶段,其主要作用是从系统外部获得 ** Class二进制数据流 **。它是Java的核心组件所有的 Class都是由 Classloader进行加载的Classloader负责通过将 Class文件里的二进制数据流装载进系统,然后交给Java虚拟机进行连接、初始化等操作。

##### ClassLoader种类

- BootStrapClassLoader: C++编写，加载核心库java.*
- ExtClassLoader: java编写，加载扩展库 javax.*
- AppClassLoader: java编写，加载程序所在目录
- 自定义ClasLoader: java编写，自定义加载
    - findClass
    - defineClass
    // TODO 代码

|类加载器名称|加载范围|
|:-------:|:-------:|
|启动类加载器 Bootstrap ClassLoader | 存放在<JAVA_HOME>\lib 目录中的，并且是虚拟机识别的类库加载到虚拟机内存中的|
|扩展类加载器 Extension ClassLoader| 存放在<JAVA_HOME>\lib\ext 目录中的所有类库，开发者可以直接使用|
|应用程序加载器 Application ClassLoader | 加载用户类路径上指定的类库，开发者可以直接使用，一般情况下这个就是程序中默认的类加载器 |
|自定义加载器 Custom ClassLoader | 加载自定义的类 |

##### 如何组织类加载器

虚拟器引入了双亲委派模型  
当一个加载器进行类加载的时候，先委派给双亲加载器加载。双亲无法加载的时候再返回自己加载。
好处: 保证类有合适的优先级的层次关系，保证程序稳定运行。  

![双亲委派](双亲委派.png)

// TODO ClassLoader 源码

[openjdk](http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file)

##### 为什么使用双亲委派机制去加载类

- 避免多份同样字节码的加载

##### 类的加载方式

- 隐式加载: new
- 显示加载: loadClass, forName等(不支持反射，需要newInstance()获取实例)

###### 类的生命周期

![类的生命周期](类的声明周期.png)

类加载包括 加载 验证 准备 解析 初始化五个阶段  

- 加载: 类加载器(可自己设置)，热部署，加密解密
- 验证: 字节流包含的信息符不符合虚拟机要求，会不会危害虚拟机  
- 准备: 为类变量分配内存，设置初始值 。  
- 解析: 将常量池的一些引用替换为实际值。
- 初始化: 赋值
- 使用: 构造过程，构造方法

![类加载](类加载.png)

###### loadClass 和 forNmae 的区别

- Class.forName 得到的class 是已经初始化完成的
- Classloader.loadClass得到的class是还没有链接的

例如forName用于加载MySQL jdbc Driver，loadclass 不可以

loadclass 一般用于spring ioc，因为 lazy loading 即懒加载的特性，加快加载速度，等要用到的时候再去初始化

#### Java的内存模型

- 地址空间划分
    - 内核空间  (主要的系统操纵程序和C运行的空间，逻辑和基于C的进程)
    - 用户空间  (Java实际运行时使用的内存空间)

JVM内存模型--JDK8

![JVM内存模型](JVM内存模型.png)

##### 程序计数器(Program Counter Register)

- 当前线程执行的字节码行号指示器(逻辑计数器)
- 改变计数器的值来选取下一条需要执行的字节码指令
- 和线程时一对一的关系即"线程私有"
- 对Java方法计数，如果时Native方法，计数器值为Undefined
- 不会发生内存泄漏

##### Java虚拟机栈(Stack)

- Java方法执行的内存模型
- 包含多个栈帧

// TODO javap -verbose 

![stack](Stack.png)

###### 递归为什么会引发java.lang.StackOVerflowError异常

- 递归过深，栈帧数超出虚拟栈深度
- 虚拟机栈过多会引发java.lang.OutOfMemoryError

##### 本地方法栈(Native Stack)

- 与虚拟机栈相似，主要作用于标注了native的方法

##### 元空间(MetaSpace)

元空间(MetaSpace)与永久代(PermGen)的区别

- 元空间使用本地内存，而永久代使用的是jvm的内存

MetaSpace 相比 PermGen的优势

- 字符串常量池存在永久代中，容易出现性能问题和内存溢出
- 类和方法的信息大小难以确定，给永久代的大小指定带来了困呐
- 永久代会为GC带来不必要的复杂性
- 方便HotSpot与其他JVM如Jrockit的继承

##### Java堆(Heap)

- 对象实例的分配区域
- GC管理的主要区域
    - 分代清除算法(新生代，老生代)

##### 常考问题

###### JVM 三大性能调优参数-Xms -Xmx -Xss的含义

- -Xss: 规定了每个线程虚拟机栈(堆栈)的大小
- -Xms: 堆的初始值
- -Xmx: 堆能达到的最大值

###### Java的内存模型(堆和栈)

Java内存模型中堆和栈的区别-- 内存分配策略

- 静态存储：编译时确定每个数据目标在运行时的存储空间需求
- 栈式存储：数据区需求在编译时未知，运行时模块入口前确定
- 堆式存储：编译时或运行时模块入口都无法确定，动态分配

Java内存中堆和栈的区别

- 联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址
- 管理方式: 栈自动释放，堆需要GC
- 空间大小：栈比堆小
- 碎片相关：栈产生的碎片远小于堆
- 分配方式: 站支持静态和动态分配，而堆仅支持动态分配
- 效率： 栈的效率比堆高

元空间、堆、线程独占部分间的联系-内存角度

- 元空间：方法
- 堆： 对象
- 栈： 执行过程

不同JDK版本置键的intern()方法的区别-JDK6 VS JDK+

```java
String s = new String ("a");
s.intern();
```

JDK6:当调用 intern方法时,如果字符串常量池先前已创建出该字符串对象,则返回池中的该字符串的引用。  
否则,将此字符串对象添加到字符串常量池中,并且返回该字符串对象的引用。

JDK6+:当调用 intern方法时,如果字符串常量池先前已创建出该字符串对象,则返回池中的该字符串的引用。  
否则,如果该字符串对象已经存在于Java堆中,则将堆中对此对象的引用添加到字符串常量池中,并且返回该引用;  
如果堆中不存在,则在池中创建该字符串并返回其引用。


### JVM的内存布局

![2020-08-10-12-00-27](http://image.edxuanlen.cn/2020-08-10-12-00-27.png)

程序计数器: 记录程序的下一跳，像代码行号的指示器

JAVA虚拟机栈: 每个方法在被调用的时候就会创建一个栈帧，每个方法从调用到执行的过程，就对应着一个栈帧入栈到出栈的过程。

JAVA虚拟机堆: 是Java虚拟机所管理的内存中最大的一块。被所有线程共享的内存区域，对象实例在这里分配内存。是垃圾收集器(GC)管理的主要区域。

方法区: 存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，运行时常量池(RunTime Constant Pool)是方法区的一部分。

直接内存: 直接内存(Direct Memory) 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。

![2020-08-10-12-01-34](http://image.edxuanlen.cn/2020-08-10-12-01-34.png)

<span style="color:red;">1.6 运行时常量池在方法区，1.7后在堆中，1.8移除了方法区，多了元空间 </span>

### 垃圾回收机制

#### 标记-清楚算法

(Mark-Sweep)  
内存碎片，内存不规整

#### 复制算法

空间浪费，总有一半以上的空间没被使用

#### 标记-整理算法

(Mark-Compact)  
内存区域块的移动，性能有所影响

#### 把算法都用上

分代收集，分新生代、年老代  
并行式垃圾回收  

传统的GC收集器将连续的内存空间划分为新生代，老年代和永久代（JDK 8移除了永久代，约会了元空间Metaspace），这种划分的特点是各代的存储地址（逻辑地址，下同）是连续的。如下图所示：传统GC内存布局

![2020-08-10-12-28-51](http://image.edxuanlen.cn/2020-08-10-12-28-51.png)

而G1的各代存储地址是不连续的，每一代都使用了n个不连续的大小相同的区域，每个区域占有一块连续的虚拟内存地址。如下图所示：

![2020-08-10-12-29-44](http://image.edxuanlen.cn/2020-08-10-12-29-44.png)

新生代 复制算法， 老年代 用了标记清除算法
**G1** 不再是划分为两大块，划分得更加详细，提出了很多性能上的提升。

参考文章: [美团技术团队](https://tech.meituan.com/2016/09/23/g1.html)

#### G1 GC模式

G1提供了两种GC模式，Young GC和混合GC，两个都是完全停止世界的。* Young GC：允许所有年轻代里的区域。通过控制年轻代的区域个数，即年轻代内存*混合GC：将所有年轻代里的区域，外加根据全局并发标记统计转换收集收益高的多个老年代区域。在用户指定的目标范围内进行调整选择收益高的老年代地区。

由上面的描述可知，混合GC不是完整GC，它只能回收部分老年代的区域，如果混合GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行混合GC，就会使用串行所以我们可以知道，G1是不提供完整GC的。

上文中，多次提到了全局并发标记，它的执行过程类似CMS，但是不同的是，在G1 GC中，它主要是为混合GC提供标记服务的，而不是一次GC过程的一个必须重叠。 *并发标记（Concurrent Marking）。这个阶段从GC Root开始对堆。*并发标记（Concurrent Marking）。这个阶段从GC Root开始对堆。 *最终标记（Remark，STW）。标记那些在并发标记阶段发生变化的对象，将被回收。*清除垃圾（Cleanup）。清除空区域（没有存活对象的），加入免费列表。

第一阶段初始标记是共享了Young GC的暂停，这是因为他们可以替换root scan操作，所以可以说global并发标记是伴随Young GC而发生的。第四阶段清理只是回收了没有存活对象的Region ，所以它并不需要STW。

*是G1HeapWastePercent：在全局并发标记结束之后，，实际上是由一些参数控制着的，另外也控制着其中老年代Region会被选入CSet。 * G1MixedGCLiveThresholdPercent，我们可以知道旧时代地区中有多少空间要被回收，在每次YGC之后和再次发生混合GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生混合GC。 ：旧世代区域中的存活对象的占比，只有在此后的参数之下，才会被选入CSet。* G1MixedGCCountTarget：一次全局并发标记之后，最大执行混合GC的次数。* G1OldCSetRegionThresholdPercent：一次混合GC中能被选入CSet的最多的上一代地区数量。

除了以上的参数，G1 GC相关的其他主要的参数有：

|参数|意味着|
|:----:|:----:|:----:|
|-XX：G1HeapRegionSize = n | 设置Region大小，并非最终值|
|-XX：MaxGCPauseMillis| 	设置G1收集过程目标时间，设置值200ms，不是硬性条件|
|-XX：G1NewSizePercent|新生代系数，预设值5％|
|-XX：G1MaxNewSizePercent|新生代变量，预设值60％|
|-XX：ParallelGCThreads|STW期间，并行GC线程数|
|-XX：ConcGCThreads = n|	并发标记阶段，并行执行的线程数|
|-XX：正在启动堆占用率|	设置触发标记周期的Java堆占用率阈值。默认值是45％。这里的java堆占比指的是non_young_capacity_bytes，包括old + humongous|

### 杂

多线程下 i-- 不是一个原子性操作

CPU 线程 1:1 关系，时间片轮转机制

AtomicInteger 底层原理  CAS (compare and swap)

ABA 问题

Sync 解决  synchronized(非公平), Lock （ReentrantLock 可重入锁）

### 引用

#### 强引用

- 最普通的引用: Object obj = new Object()
- 抛出OutOfMemoryError 终止程序也不会回收具有强引用的对象
- 通过将对象设置为null来弱化引用，使其被回收

#### 软引用

- 对象处在有用但非必须的状态
- 只有当内存空间不足时，GC会回收该引用的对象的内存
- 可以用来实现高速缓存

#### 弱引用

- 非必须的对象，比软引用更弱
- GC时会被回收
- 被回收的概率不大，因为GC线程优先级比较低
- 适用于引用偶尔被使用且不影响垃圾收集的对象

#### 虚引用

- 不会决定对象的生命周期
- 任何时候都可能被垃圾收集器回收
- 跟踪对象被垃圾收集器回收的活动，起哨兵作用
- 必须和引用队列ReferenceQueue联合使用

#### 区别

| 引用类型 | 被垃圾回收时间 |      用途      |      生存时间     |
|:--------:|:--------------:|:--------------:|:-----------------:|
|  被强用  |    从来不会    | 对象的一般状态 | JVM停止运行时终止 |
|  被软用  |  在内存不足时  |    对象缓存    |   内存不足时终止  |
|  弱引用  |  在垃圾回收时  |    对象缓存    |    gc运行后终止   |
|  虚引用  |     Unknown    |   标记、哨兵   |      Unknown      |



## GC

### Java垃圾回收机制

###### 对象被判定为垃圾的标准

- 没有被其他对象引用

#### 判断对象是否为垃圾的算法

##### 引用计数算法

做法

- 通过判断对象的引用数量来决定对象是否可以被回收
- 每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1
- 任何引用计数为0 的对象实例可以被当作垃圾收集

- 优点：执行效率高，程序执行受影响较小
- 缺点: 无法检测出循环引用的情况，导致内存泄露

##### 可达性分析算法

由离散数学的图论引入的  

通过判断对象的引用链是否可达来决定对象是否可以被回收  
选择一个GC Root对象

- 虚拟机栈中引用的对象(栈帧中的本地变量表)
- 方法区中的常量引用对象
- 方法区中的类静态属性引用的对象
- 本地方法栈中JNI(Native方法)的引用对象
- 活跃线程的引用对象

#### 垃圾回收算法

##### 标记-清楚算法(Mark and Sweep)

- 标记: 从根集合进行扫描，对存活的对象进行标记
- 清楚: 对堆内存从头到尾进行线性遍历，回收不可达对象内存

缺点  
造成碎片化问题

##### 复制算法(Copying)

- 分为对象面和空闲面
- 对象在对象面上创建
- 存货的对象被从对象面复制到空闲区
- 将对象面所有对象内存清楚

优点  

- 解决碎片化问题
- 顺序分配内存，简单高效
- 适用于对象存活率低的场景

适用于分代的年轻代

##### 标记-整理算法(Compacting)

使用了标记清除算法的方式，加上了整理步骤

- 避免内存的不连续行
- 不用设置两块内存互换
- 适用于存活率高的场景

##### 分代收集算法(Generational Collector)

组合拳  

- jdk6, jdk7 分为年轻代，老年代，永久代
- jdk8 以后永久代消失

年轻代存活率低，使用复制算法，老年代存活率高，使用标记清除/整理算法  

##### GC 分类

- Minor GC (年轻代)
- Full GC (老年代)

###### 年轻代(1/3)

- Eden区(伊甸) (大)
- 两个Survivor区 (from/to) (小)

如何判断进入老年代  

- 经历一定Minor次数依然存活的对象
- Survivor区中存放不下的对象
- 新生成的大对象

常用调优参数

- -XX:SurvivorRatio: Eden 和 Survivor的比值，默认8:1
- -XX:NewRatio: 老年代和年轻代内存大小的比例
- -XX:MaxTenurinThreshold: 对象从年轻代晋升到老年代经过GC次数的最大阈值

###### 老年代(2/3)

- 标记-清理算法
- 标记-整理算法

老年代的GC会涉及新生代，Full GC就是全GC

- Full GC 和 Major GC
- Full GC 比Minor GC 慢(10倍左右)，但执行频率低

触发Full GC的条件

- 老年代空间不足
- 永久代空间不足 (jdk6, 7)
- CMS GC时出现promotion failed, concurrent mode failure
- Minor GC晋级到老年代的平均大小大于老年代的剩余空间
- 调用System.gc()
- 使用RMI来进行RPC管理的JDK应用，每效时执行一次Full GC

###### Stop-the-World

- JVM 由于要执行GC而停止了应用程序的执行
- 任何一种GC算法中都会发生
- 多数GC优化通过减少Stop-the-world发生的时间来提高程序性能(实现高吞吐)

###### Safepoint

- 分析过程中对象引用关系不会发生变化的点
- 产生安全点的地方: 方法调用，循环跳转，异常跳转等
- 安全点数量适中

#### 垃圾收集器

JVM的运行模式

- Server
- Client

##### 年轻代常见的垃圾收集器

###### Serial收集器(-XX: +UseSerialGC, 复制算法)

- 单线程收集，进行垃圾收集时，必须暂停所有工作线程
- 简单高效，Client模式下默认的年轻代收集器

###### ParNew收集器(-XX: +UseParNewGC, 复制算法)

- 多线程收集，其他行为同Serial
- 单核执行效率不如Serial，多核下有优势

###### Parallel Scavenge收集器(-XX: +UseParallelGC，复制算法)

- 吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)
- 比起关注用户线程停顿时间，更关注系统的吞吐量
- 在多核下执行才有优势，Server模式下默认的年轻代收集器

##### 老年代垃圾收集器

###### Serial Old收集器(-XX: +UseSerialOldGC, 标记-整理算法)

其他特点同年轻代

###### Paraller Old收集器(-XX: +UseParallelOldGC，标记-清理算法)

- 多线程，吞吐量优先

###### CMS收集器(-XX: +UseConcMarkSweepGC， 标记-清理算法)

- 初始标记: stop-the-world
- 并发标记: 并发追溯标记，程序不会停顿
- 并发预清理: 查找执行并发标记阶段从年轻代晋升到老年代的对象
- 重新标记: 暂停虚拟机，扫面CMS堆中的剩余对象
- 并发清理: 清理垃圾对象，程序不会停顿
- 并发重置: 重置CMS收集器的数据结构

##### G1收集器(-XX: +UseG1GC，复制+标记-整理算法)

Garbage First收集器优点

- 并发和并行
- 分代收集
- 空间整合
- 可预测的停顿

G1

- Java堆内存划分为多个大小相等的Region
- 年轻代和老年代不再物理隔离

#### GC 的面试题

##### Object的finalize()方法的作用是否与C++的析构函数作用相同

- 与C++的析构函数不同，析构函数调用确定，而它是不确定的
- 将未被引用的对象放置在F-Queue队列
- 方法执行随时可能会被终止
- 给予对象最后一次重生的机会

##### G1, ZGC


###### 引用队列(reference queue)

- 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达
- 存储关联的且被GC的软引用，弱引用以及虚引用
