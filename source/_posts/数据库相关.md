---
title: 数据库相关
author: edxuanlen
top: false
cover: false
toc: true
mathjax: false
date: 2020-08-10 11:25:28
img:
coverImg:
password:
summary:
tags:
    - Interview
    - 数据库
    - MySQL
categories:
    - Interview
    - 数据库
description:
---


## 数据库

### 如何设计一个关系型数据库(RDBMS)

1. 程序实例  
    - 存储管理
    - 缓存机制
    - SQL 解析
    - 日志管理
    - 权限划分
    - 容灾机制
    - 索引管理
    - 锁管理

2. 存储(文件系统)

### 索引模块

#### 为什么要使用索引

快速查询数据

#### 什么信息能成为索引

主键，唯一键以及普通键

#### 索引的数据结构

生成索引，建立二叉查找树进行二分查找
生成索引，建立B-Tree 结构进行查找
生成索引，建立B+Tree 结构进行查找
生成索引，建立Hash结构进行查找

![2020-08-10-11-26-37](http://image.edxuanlen.cn/2020-08-10-11-26-37.png)

#### B Tree

定义

- 根节点至少包括两个孩子
- 书中每个节点最多含有m铬孩子( m>= 2)
- 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子
- 所有叶子节点都位于同一层
- 假设每个非终端节点中包含有n个关键字信息，其中：
    1. Ki(i=1...n)为关键字，且关键字按顺序升序排序K(i-1) < Ki
    2. 关键是个数满足: [ceil(m / 2) - 1] <= n <= m - 1
    3. 非叶子节点的指针:P[1],P[2],... P[M], P[1]指向的关键字小于K[1]的子树，
        P[M]指向关键字大于P[M -1] 的子树，其他P[i]指向关键字属于(K[i-1], K[i])的子树

#### B+ Tree

B+ 树是B树的变体，其定义基本与B树相同，除了：
    - 非叶子节点的子树指针与关键字个数相同
    - 非叶子节点的子树指针P[i],指向关键字值([K[i],K[i+1])
    - 非叶子节点仅用来索引，数据都保存在叶子节点中
    - 所有叶子节点均有一个链指针指向下一个叶子节点

#### 结论

B+ Tree更适合用来做存储索引
    - B+ Tree 的磁盘读写代价更低
    - B+ Tree 的查询效率更加稳定
    - B+ Tree 更加有利于对数据库的扫描

#### Hash索引

优点 查询速度O(1)
缺点:

- 仅仅能够满足'=','IN', 不能使用范围查询
- 无法被用来避免数据的排序操作
- 不能利用部分索引键查询
- 不能避免表扫描
- 遇到大量Hash值相等的情况后性能并不一定会比B Tree索引高

#### 密集索引和稀疏索引的区别

- 密集索引文件中的每个搜索码值都对应一个索引值
- 稀疏索引只为某些值建立索引项

##### InnoDB

- 若一个主键被定义，该主键则作为密集索引
- 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引
- 若不满足以上条件，innodb内部会生成一个隐藏主键(密集索引)
- 非主键索引存储相关键位和其对于的主键值，包含两次查找

myISAM索引和DB是分开的，InnoDB索引和DB是存放在一起的

### 索引问答

Q: 为什么要用索引  
A: 避免全表扫描数据，提升检索效率

Q: 什么样的信息能成为索引  
A: 主键、唯一键等有区分性的数据

Q: 索引的数据结构
A: 主流是B+ Tree，以及hash结构 ， bitMap 等，mysql不支持bitmap，基于innoDB以及myISAM的mysql不显示支持hash


Q: 密集索引和稀疏索引的区别
A: 密集索引文件中的每个搜索码值都对应一个索引值，稀疏索引只为某些值建立索引项

#### mysql

##### 如何定位并优化慢查询sql

- 根据慢日志定位慢查询sql

- 使用explain等工具分析Sql
    - type
        - 表示: 找到数据行的方式
        - index 索引查询 / ALL 证明是全局查找(需要优化)
    - extra
        - 出现以下两项意味着MYSQL根本不能使用索引，效率会受到重大影响，应尽可能对此进行优化
        - Using filesort —— 无法利用索引排序
        - Using temporary  —— 使用了临时表，order by 或者分组查询 group by

- 修改sql 或者让sql尽量走索引  
    - 使用有索引的字段代替
    - 添加索引 alter table tb_name add index idx_name(name);


##### 联合索引的最左匹配原则 


#### 索引是建的越来越多好吗

- 数据量小的表不需要建立索引，建立会增加额外的索引开销
- 数据变更需要维护索引，因此更多的索引意味着更大的维护成本
- 更多的索引意味着需要更多的空间

#### 锁模块

##### MyISAM与InnoDB关于锁方面的区别是什么

- MyISAM 默认使用的是表级锁，不支持行级锁
- InnoDB 默认用的是行级锁，也支持表级锁

共享锁和排斥锁的兼容性

<!-- Share && exclude

|   | X    | S    |
|---|------|------|
| X | 冲突 | 冲突 |
| S | 冲突 | 兼容 | -->

行级锁不一定比表级锁好，锁的粒度越细，带价越高，需要扫描表到对应的对其上锁，代价是比较大的。  

InnoDB 相比 MyISAM 带来了更大的开销。

##### MyISAM适合的场景

- 频繁执行全表count 语句
- 对数据进行增删改的频率不高，查询非常频繁
- 没有事务

##### InnoDB适合的场景

- 数据增删改查都相当频繁
- 可靠性要求比较高，要求支持事务

##### 数据库锁的分类

- 按锁的粒度划分可以分为：表级锁，行级锁，页级锁
- 按锁级别划分，可分为共享锁和排他锁
- 按加锁方式划分，可分为自动锁，显示锁
- 按操作划分可分为DML锁，DDL锁
- 按使用方式划分，可分为乐观锁、悲观锁

### 数据库事务的四大特性

ACID

> * A:原子性,Atomicity
> * C:一致性,Consistency
> * I:隔离性,Isolation
> * D:持久性,Durability

### 事务鼓励级别以及各级别下的并发访问问题

并发访问引起的问题和如何避免

- 更新丢失-- mysql 所有事务隔离级别在数据库层面上均可避免
- 脏读-- READ-COMMITTED事务隔离级别以上可避免
- 不可重复读-- REPEATABLE-READ 事务隔离级别以上可避免
- 幻读-- SERIABLIZABLE事务隔离级别可避免

#### 脏读、不可重复读、幻象读概念说明

1. 脏读：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。  
2. 不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。
3. 幻象读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）  

#### 如何避免

| 事务隔离级别 | 更新丢失 | 脏读 | 不可重复读 | 幻读 |
|--------------|----------|------|------------|------|
| 未提交读     | 避免     | 发生 | 发生       | 发生 |
| 已提交读     | 避免     | 避免 | 发生       | 发生 |
| 可重复读     | 避免     | 避免 | 避免       | 发生 |
| 串行化       | 避免     | 避免 | 避免       | 避免 |

在mysql中的innodb引擎,原子性,一致性,隔离性通过redo和undo实现,redo 就是ib_logfile物理文件,而undo默认在共享表空间ibdata里面,通过设置参数可以独立出来.

#### 数据库操作事务隔离

##### 读取未提交的事务里面的数据(脏读)

设置隔离级别方法

```sql
set session transaction isolation level read uncommitted;
```

开始事务

<!-- show variables like '%tx_isolation%'; -->

```sql
set session transaction isolation level read uncommitted;

begain
update propagation set count = count + 1 where id = 1

rollback (回滚操作)
```

另外开一个session 进行查询，可看到并不还没有更改数据。

```sql
set session transaction isolation level read uncommitted;

select * from propagation

```

begain中执行的操作  被第二个进程读到了，导致脏读，一但事务回滚，第二个进程保存的是之前的结果。

#### InnoDB可重复读隔离级别下如何避免幻读

- 表象: 快照读(非阻塞读) -- 伪
    - 当前读是上了锁的增删改查， update,delete,insert
    - 快照读: 不加锁的非阻塞读,select 

### 语法

关键语法

- Group By
- Having
- Count, Sum, Max, Min, Avg

#### Group By

- 满足 "select 自居的列名必须为分组列或列函数
- 列函数对于 group by 子句定义的每个组各返回一个结果

```SQL
# 查询所有同学学号、姓名、选课数、总成绩
SELECT
	s.student_id,
	stu.name,
	COUNT( course_id ),
	SUM( score ) 
FROM
	score s,
	student stu
WHERE
	s.student_id = stu.student_id
GROUP BY
	student_id
```

#### Having

- 通常与Group By 子句一起使用
- WHERE 过滤行，Having过滤组
- 出现在同一sql的顺序: WHERE > GROUP BY > HAVING

### Mysql(InnoDB)如何处理死锁

#### 为什么会出现锁

MySQL的并发控制有两种方式，一个是 MVCC，一个是两阶段锁协议。
为了提高并发性能并且要求如同多个用户的请求过来之后如同串行执行的一样（可串行化调度）。

##### 二阶段锁协议（2PL）

两阶段锁协议是指所有事务必须分两个阶段对数据加锁和解锁，在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁；在释放一个封锁之后，事务不再申请和获得任何其他封锁。

对应到 MySQL 上分为两个阶段：

扩展阶段（事务开始后，commit 之前）：获取锁
收缩阶段（commit 之后）：释放锁
就是说呢，只有遵循两段锁协议，才能实现 可串行化调度。

但是两阶段锁协议不要求事务必须一次将所有需要使用的数据加锁，并且在加锁阶段没有顺序要求，所以这种并发控制方式会形成死锁。

#### 如何解决

1. 等待，直到超时（innodb_lock_wait_timeout=50s）。
2. 发起死锁检测，主动回滚一条事务，让其他事务继续执行（innodb_deadlock_detect=on）。
由于性能原因，一般都是使用死锁检测来进行处理死锁。

死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。

检测到死锁之后，选择插入更新或者删除的行数最少的事务回滚，基于 INFORMATION_SCHEMA.INNODB_TRX 表中的 trx_weight 字段来判断。


#### 避免死锁

##### 收集死锁信息

1. 利用命令 SHOW ENGINE INNODB STATUS查看死锁原因。
2. 调试阶段开启 innodb_print_all_deadlocks，收集所有死锁日志。

##### 减少死锁

1. 使用事务，不使用 lock tables 。
2. 保证没有长事务。
3. 操作完之后立即提交事务，特别是在交互式命令行中。
4. 如果在用 (SELECT ... FOR UPDATE or SELECT ... LOCK IN SHARE MODE)，尝试降低隔离级别。
5. 修改多个表或者多个行的时候，将修改的顺序保持一致。
6. 创建索引，可以使创建的锁更少。
7. 最好不要用 (SELECT ... FOR UPDATE or SELECT ... LOCK IN SHARE MODE)。
8. 如果上述都无法解决问题，那么尝试使用 lock tables t1, t2, t3 锁多张表
