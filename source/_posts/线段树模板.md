---
title: 线段树模板
date: 2019-09-23 08:22:37
tags:
    - 模板
categories: C/C++
description: 线段树的模板。
top:
---


## 线段树区域加模板

```C++
# include <bits/stdc++.h>
# define ls (p << 1)
# define rs (p << 1 | 1)


using namespace std;

const int MAXN = 100010;
int n;
typedef long long ll;

int a[MAXN + 2];

struct tree{
    int l, r;
    ll pre, add;
}t[4 * MAXN + 2];

inline void build(int p, int l, int r){
    t[p].l = l; t[p].r = r;
    if (l == r){
        t[p].pre = a[l];
        return ;
    }
    int mid = l + r >> 1;
    build (ls, l, mid);
    build (rs, mid + 1, r);
    t[p].pre = t[ls].pre + t[rs].pre;
}

inline void spread(int p){ // 向下传递懒标记
    if(t[p].add){
        t[ls].pre += t[p].add * (t[ls].r - t[ls].l + 1);
        t[rs].pre += t[p].add * (t[rs].r - t[rs].l + 1);
        t[ls].add += t[p].add;
        t[rs].add += t[p].add;
        t[p].add = 0;
    }
}

inline void change(int p, int x, int y, int z){
    if(x <= t[p].l && y >= t[p].r){  // 覆盖
        t[p].pre += (ll)z * (t[p].r - t[p].l + 1);
        t[p].add += z;
        return ;
    }
    spread(p);
    int mid = t[p].l + t[p].r >> 1;
    if(x <= mid ) change (ls, x, y, z);
    if(y > mid ) change (rs, x, y, z);
    t[p].pre = t[ls].pre + t[rs].pre;
}

inline ll ask(int p, int x, int y){
    if(x <= t[p].l && y >= t[p].r) return t[p].pre;
    spread(p);
    int mid = t[p].l + t[p].r >> 1;
    ll ans = 0;
    if( x <= mid ) ans += ask(ls, x, y);
    if( y > mid ) ans += ask(rs, x, y);
    return ans;
}

int main(){
    ios::sync_with_stdio(false);
    int n, m;
    cin >> n >> m;
    int s, x, y, k;
    for(int i = 1; i <= n; i ++) cin >> a[i];
    build(1, 1, n);
    while ( m -- ){
        cin >> s;
        if( s == 1 ){
            cin >> x >> y >> k;
            change(1, x, y, k);
            // cout << ask(1,1,n) << "\n" ;
        } else {
            cin >> x >> y;
            cout << ask(1, x, y) << "\n";
        }
    }
    return 0;
}
```

## 线段树区间加，乘法和查询

```C++
#include <bits/stdc++.h>
#define rs p * 2 + 1
#define ls p * 2
using namespace std;

typedef long long ll;

const int MAXN = 100001;

int n, m, a[MAXN];
ll mod = 0xfffffffffffffff;  // mod 注意修改
struct node {
  ll sum, l, r, mul, add;
} t[MAXN * 4 + 1];

int read() {
  ll x = 0;
  char ch = getchar();
  while (ch < '0' || ch > '9')
    ch = getchar();
  while (ch >= '0' && ch <= '9')
    x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
  return x;
}
void build(ll p, ll l, ll r) {
  t[p].l = l, t[p].r = r;
  t[p].mul = 1;
  if (l == r) {
    t[p].sum = a[l] % mod;
    return;
  }
  ll mid = (l + r) >> 1;
  build(ls, l, mid);
  build(rs, mid + 1, r);
  t[p].sum = (t[ls].sum + t[rs].sum) % mod;
}
void spread(ll p) {
  t[ls].sum =
      (ll)(t[p].mul * t[ls].sum + ((t[ls].r - t[ls].l + 1) * t[p].add) % mod) %
      mod;
  t[rs].sum =
      (ll)(t[p].mul * t[rs].sum + (t[p].add * (t[rs].r - t[rs].l + 1)) % mod) %
      mod; // add已经乘过mu啦

  t[ls].mul = (ll)(t[ls].mul * t[p].mul) % mod;
  t[rs].mul = (ll)(t[rs].mul * t[p].mul) % mod;

  t[ls].add = (ll)(t[ls].add * t[p].mul + t[p].add) % mod;
  t[rs].add = (ll)(t[rs].add * t[p].mul + t[p].add) % mod;

  t[p].mul = 1, t[p].add = 0;
}
void add(ll p, ll l, ll r, ll k) {
  if (t[p].l >= l && t[p].r <= r) {
    t[p].add = (t[p].add + k) % mod;
    t[p].sum = (ll)(t[p].sum + k * (t[p].r - t[p].l + 1)) % mod;
    return;
  }
  spread(p);
  t[p].sum = (t[ls].sum + t[rs].sum) % mod;
  ll mid = (t[p].l + t[p].r) >> 1;
  if (l <= mid)
    add(ls, l, r, k);
  if (mid < r)
    add(rs, l, r, k);
  t[p].sum = (t[ls].sum + t[rs].sum) % mod;
}
void mul(ll p, ll l, ll r, ll k) {
  if (t[p].l >= l && t[p].r <= r) {
    t[p].add = (t[p].add * k) % mod;
    t[p].mul = (t[p].mul * k) % mod;
    t[p].sum = (t[p].sum * k) % mod;
    return;
  }
  spread(p);
  t[p].sum = t[ls].sum + t[rs].sum;
  ll mid = (t[p].l + t[p].r) >> 1;
  if (l <= mid)
    mul(ls, l, r, k);
  if (mid < r)
    mul(rs, l, r, k);
  t[p].sum = (t[ls].sum + t[rs].sum) % mod;
}
ll ask(ll p, ll l, ll r) {
  if (t[p].l >= l && t[p].r <= r) {
    return t[p].sum;
  }
  spread(p);
  ll val = 0;
  ll mid = (t[p].l + t[p].r) >> 1;
  if (l <= mid)
    val = (val + ask(ls, l, r)) % mod;
  if (mid < r)
    val = (val + ask(rs, l, r)) % mod;
  return val;
}
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    a[i] = read();
  }
  build(1, 1, n);
  for (int i = 1; i <= m; i++) {
    int ty = read();
    if (ty == 1) {
      ll cn = read(), cm = read(), cw = read();
      add(1, cn, cm, cw);
    } else {
      ll cn = read(), cm = read();
      cout << ask(1, cn, cm) << endl;
    }
  }
  return 0;
}

```


