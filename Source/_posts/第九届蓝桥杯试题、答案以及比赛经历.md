---
title: 第九届蓝桥杯试题、答案以及比赛经历
date: 2018-04-05 15:04:32
tags: 
    - 经历
    - C/C++题目
categories: C/C++ 
description: 第一次竞赛经历，第九届蓝桥杯初赛。
---

时间:2018年愚人节
地点：南京航空航天大学(江宁校区)
事件：第九届蓝桥杯省赛


废话不多说，直接上题目：

## 第一题： 第几天(满分5分)
### 题目描述：
> 2000年的1月1日，是那一年的第1天。那么，2000年的5月4日，是那一年的第几天？ 
> 注意：需要提交的是一个整数，不要填写任何多余内容。

个人感受：
    很简单的一道题，学习了各位大佬的比赛经验，这种题目也不去考虑编程了，不仅要判断几月是几天还要去思考是否闰年

### 题目答案：
答案：125
方法: 日历/excel
例如：用excel快速求解，第一个单元格输入2000/1/1，第二个单元格输入2000/5/4，然后在第三个单元格生成，第二个单元格减去第一个单元格的值
哦，对了 ，算完是124，还要加上1！5s出答案。

## 第二题： 明码(满分7分)
### 题目描述：
>汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。
16点阵的字库把每个汉字看成是16x16个像素信息。并把这些信息记录在字节中。
一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。
把每个字节转为2进制表示，1表示墨迹，0表示底色。每行2个字节，
一共16行，布局是：
    第1字节，第2字节
    第3字节，第4字节
    ....
    第31字节, 第32字节
这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。
题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。
这段信息是（一共10个汉字）：
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16 
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 
0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4 
4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64 
16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128 
0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0 
2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0 
1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0 
0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0 
**注意：需要提交的是一个整数，不要填写任何多余内容。**

个人感受：
    很有趣的一道题目，一开始有点懵圈，这么多的数据，想到的就是转化为八位二进制，然后两个一组输出 然后换行，
最后从一堆二进制中看出 题目：九的九次方等于多少？(一开始我还以为时输入转化得到的话，结果看到了最后一个翻译出来是问号==emmm，又看了下题目最后一行，整数！emmmm)
PS:负数直接用128相加一下就差不多能看了.
### 题目答案：
387420489
**代码一**
```C++
#include<bits/stdc++.h>
using namespace std;
void print(int x){
	int a[8]={0};
	if(x<0)
		x+=128;
	for(int i=7;i>=0;i--){
		a[i]=x%2;
		x/=2;
	}
	for(int i=0;i<8;i++)
		if(a[i]) cout<<"*";
		else cout<<" ";
}
int main(){
	for(int i=0;i<10;i++){
		for(int i=0;i<16;i++){
			//由题目很容易可以看出 两个八位二进制一行 
			int x,y;
			scanf("%d%d",&x,&y);
			print(x);
			print(y);
			cout<<endl;
		}
		cout<<endl<<endl;
	}
	return 0; 
}
```
**代码二**
有大佬用位运算写:
位运算不不用考虑负数的问题..直接按位进行运算
```C++
#include<bits/stdc++.h>
using namespace std;
void print(int x){
	for(int i=7;i>=0;i--){
		// x=4    100 &  10000000  = 0
		//        100 &  1000000   = 0
		//        100 &  100000    = 0
		//        100 &  10000     = 0
		//        100 &  1000      = 0
		//        100 &  100       = 100
		//        100 &  10        = 0	
		//        100 &  1         = 0
		if(x&(1<<i))
			cout<<(x&(1<<i))<<'*';
		else cout<<' ';
	}
int main(){
	for(int i=0;i<10;i++){
		for(int i=0;i<16;i++){
			//由题目很容易可以看出 两个八位二进制一行 
			int x,y;
			scanf("%d%d",&x,&y);
			print(x);
			print(y);
			cout<<endl;
		}
		cout<<endl<<endl;
	}
	return 0; 
}
```

## 第三题： 乘积尾零(满分13分)
### 题目描述：
>如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？
5650 4542 3554 473 946 4114 3871 9073 90 4329 
2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 
9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 
1486 5722 3135 1170 4014 5510 5120 729 2880 9019 
2049 698 4582 4346 4427 646 9742 7340 1230 7683 
5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 
6701 6645 1671 5978 2704 9926 295 3125 3878 6785 
2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 
3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 
689 5510 8243 6114 337 4096 8199 7313 3685 211 
注意：需要提交的是一个整数，表示末尾零的个数。不要填写任何多余内容。

个人感受：
    大数这道题。。写的时候还是贼开心的==  因为。。我以为写出来了==
对于这种数学弱鸡，简直不懂分解为2和5。。只会一行一行的去十个十个相乘再去模一亿取余
然而==死在了 我只保留了最后两位 非零数。。。。导致杀千刀的少了三个0(大佬说要保留四位（后我实测为3位）)
这道题 错的 特别 不该  代码也就三分钟的事==
{% asset_img 1.png %}

思路：两种方法
①直接将所有数相乘，然后每乘一个数就把后面0全部去掉记一下，不过中间会爆long long，这个好办，每次乘完只保留后4位非0数字，例如216037就只保留6037
**②正解：所有的0都一定是2*5产生的，所以将每个数拆成一堆2乘上一堆5再乘上一个数，之后统计下有多少个2和多少个5取少的那个就是答案**
### 题目答案：
答案：31
**思路一的代码**
```C++
#include<bits/stdc++.h>
using namespace std;
int main(){
	int a[101],cnt=0;
	for(int i=0;i<100;i++)
		scanf("%d",a+i);
	for(int i=0;i<99;i++){
		a[i+1]*=a[i];
		while(a[i+1]%10==0){
			a[i+1]/=10;
			cnt++;
		}
		a[i+1]%=1000;
	}
	cout<<cnt; 
	return 0;
} 
```
**思路二的代码**
```C++
#include<bits/stdc++.h>  
using namespace std;  
int main(){  
    int res2=0,res5=0;  
    for(int i=0;i<100;i++){  
        int x;
		scanf("%d",&x);  
        int y=x;  
        while(x%2==0)res2++,x/=2; 
		while(x%5==0)res5++,x/=5;  
    }  
    cout<<min(res2,res5)<<endl;  
}  
```

## 第四题： 测试次数(满分17分)
### 题目描述：
> x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。
各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。
x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。
如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。
特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。
如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n
为了减少测试次数，从每个厂家抽样3部手机参加测试。
某次测试的塔高为1000层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？
请填写这个最多测试次数。
注意：需要填写的是一个整数，不要填写任何多余内容。

个人感受：
    这道题凉凉，很凉，透心凉
教训，下次一定要先看分值==
看到题目，最优策略？OK二分！然后就算出了  九次吧==然后自信直接过
回来车上在复盘，忽然想到，等下。。那个。。摔手机？手机。。手机。。会摔坏了吧。。
mm了个大p，一问舍友(zl) ，他不是还给了三个手机吗？
我.....好的。。。题目都没看清。。都不知道我在干嘛。。

不过就算知道了，我也没算对。。。心理平衡了一点

后来我只能算出28。。。emmmm
大佬: 直接三维 dp dp[0][1000][3] 第一个0一定不爆，第二个1000一定爆，第三个 3个手机。。
emmmmm......还是不会

### 题目答案：
答案：19

## 第五题： 快速排序(满分9分)
### 题目描述：
> 以下代码可以从数组a[]中找出第k小的元素。
它使用了类似快速排序中的分治算法，期望时间复杂度是O(N)的。
请仔细阅读分析源码，填写划线部分缺失的内容。
```C++
#include <stdio.h>

int quick_select(int a[], int l, int r, int k) {
	int p = rand() % (r - l + 1) + l;
	int x = a[p];
	{int t = a[p]; a[p] = a[r]; a[r] = t;}
	int i = l, j = r;
	while(i < j) {
		while(i < j && a[i] < x) i++;
		if(i < j) {
			a[j] = a[i];
			j--;
		}
		while(i < j && a[j] > x) j--;
		if(i < j) {
			a[i] = a[j];
			i++;
		}
	}
	a[i] = x;
	p = i;
	if(i - l + 1 == k) return a[i];
	if(i - l + 1 < k) return quick_select( _____________________________ ); //填空
	else return quick_select(a, l, i - 1, k);
}
	
int main()
{
	int a[] = {1, 4, 2, 8, 5, 7, 23, 58, 16, 27, 55, 13, 26, 24, 12};
	printf("%d\n", quick_select(a, 0, 14, 5));
	return 0;
}
注意：只填写划线部分缺少的代码，不要抄写已经存在的代码或符号。

```
个人感受：
    这道题。。算了。。填空这种题目每次我都是瞎jb猜，然后看答案对不对。。
我写了个(a,l,r,k)大概对了，就交了。。宛如智障
以为。。对了的
好的

### 题目答案：
答案：a,i+1,r,k-(i-l+1)


## 第六题： 递增三元组(满分11分)
### 题目描述：
>给定三个整数数组
A = [A1, A2, ... AN], 
B = [B1, B2, ... BN], 
C = [C1, C2, ... CN]，
请你统计有多少个三元组(i, j, k) 满足：
1. 1 <= i, j, k <= N  
2. Ai < Bj < Ck  

>【输入格式】 
第一行包含一个整数N。
第二行包含N个整数A1, A2, ... AN。
第三行包含N个整数B1, B2, ... BN。
第四行包含N个整数C1, C2, ... CN。
对于30%的数据，1 <= N <= 100  
对于60%的数据，1 <= N <= 1000 
对于100%的数据，1 <= N <= 100000 0 <= Ai, Bi, Ci <= 100000 

>【输出格式】
一个整数表示答案

>【样例输入】
3
1 1 1
2 2 2
3 3 3

>【样例输出】
27 

>资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗  < 1000ms

个人感受：
    最简单的一道题了== 暴力for。。虽然不知道最后会不会爆。。但至少有60吧
一开始看到..emmm 不就深搜嘛，最近写了不少，好的。。三分钟码完。。挖草 怎么样例输入答案一直是3
心态崩了，换了三个for....老子就不信了。。咦。。怎么还是3
我特么。。dev坏了吧？？？偷偷换个VC还是3  VS2010  还是3
心态崩了。。  输出中间值明明有27次啊。。 
忽然。。发现。。 调用函数没return最后的cnt  。。好小子，你过来，不打死你
以至最后也懒得换回dfs了。。最后，如果有人看了我的代码，可能会觉得被欺骗了。。函数名=dfs，一看。。里面只有三个for。。。
哈哈哈哈哈哈

### 题目答案：
**dfs**
```C++
#include<bits/stdc++.h>
using namespace std;
int cnt=0,n;
int a[100001],b[100001],c[100001]; 
int dfs(int i,int j,int k){
	if(a[i]<b[j]&&b[j]<c[k])
		cnt++;
	if(i==n-1&&j==n-1&&k==n-1)
		return cnt;
	if(k<n) dfs(i,j,k+1);
	else if(j<n) dfs(i,j+1,0);
		else if(i<n) dfs(i+1,0,0);
}
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++)
		scanf("%d",&a[i]);
	for(int i=0;i<n;i++)
		scanf("%d",&b[i]);
	for(int i=0;i<n;i++)
		scanf("%d",&c[i]);
	printf("%d",dfs(0,0,0));
	return 0;
} 
```
**三个for 暴力求解**
```C++
for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			for(int k=0;k<n;k++)
				if(a[i]<b[j]&&b[j]<c[k])
					cnt++;
	return cnt;
```

**最优解**
思路：分别排序
先看b和c两个数组，设两个下标i，j分别指向bc数组，对于每一个b[i],可以找到对应的c[j]恰好大于b[i]，那么对于b[i]有n-j个c[j]满足b[i]<c[j]。令sumb[i]=n-j，表示每个b[i]对应的c[j]个数。将sumb处理成后缀和。
然后再看a和b数组，用同样的方法打出数组suma，不过suma[i]=sumb[j]；
然后将suma处理成后缀和，suma[0]即为答案。
```C++
#include<bits/stdc++.h>  
using namespace std;  
typedef long long ll;  
const int N=1e6+10;  
ll suma[N],sumb[N];  
int a[N],b[N],c[N];  
int n;  
int main(){  
    scanf("%d",&n);  
    for(int i=0;i<n;i++)  
        scanf("%d",&a[i]);  
    for(int i=0;i<n;i++)  
        scanf("%d",&b[i]);  
    for(int i=0;i<n;i++)  
        scanf("%d",&c[i]);  
    sort(a,a+n);  
    sort(b,b+n);  
    sort(c,c+n);  
    memset(sumb,0,sizeof(sumb));  
    for(int i=0,j=0;i<n;i++){  
        while(j<n&&b[i]>=c[j])j++;  
        if(j>=n)break;  
        sumb[i]=n-j;  
    }  
    for(int i=n-2;i>=0;i--) //b hou zhui he  
        sumb[i]+=sumb[i+1];  
  
    for(int i=0,j=0;i<n;i++){  
        while(j<n&&a[i]>=b[j])j++;  
        if(j>=n)break;  
        suma[i]=sumb[j];  
    }  
    for(int i=n-2;i>=0;i--) //a hou zhui he  
        suma[i]+=suma[i+1];  
  
    printf("%lld\n",suma[0]);  
}  
```

## 第七题： 螺旋折线(满分19分)
### 题目描述：
>如图p1.png所示的螺旋折线经过平面上所有整点恰好一次。  
对于整点(X, Y)，我们定义它到原点的距离dis(X, Y)是从原点到(X, Y)的螺旋折线段的长度。  
例如dis(0, 1)=3, dis(-2, -1)=9  
给出整点坐标(X, Y)，你能计算出dis(X, Y)吗？

>【输入格式】
X和Y  
对于40%的数据，-1000 <= X, Y <= 1000  
对于70%的数据，-100000 <= X， Y <= 100000  
对于100%的数据, -1000000000 <= X, Y <= 1000000000  

>【输出格式】
输出dis(X, Y)  

>【样例输入】
0 1

>【样例输出】
3

>资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗  < 1000ms

{% asset_img 2.png %}
个人感受：
    并列最简单的一题，emmmm  没啥操作。。就是循环到那个点
应该时间上会爆了，反正至少50吧。。

### 题目答案：
**代码：**
#include<bits/stdc++.h>
using namespace std;
int ex,ey,nx=0,ny=0; 
int check(){
	if(nx==ex&&ny==ey)
		return 1;
	else return 0;
}
int main(){
	scanf("%d%d",&ex,&ey);
	int h=0,cnt=0;
	while(1){
		for(int i=0;i<4;i++){
			h++;
			if(i==0)
				for(int j=0;j<(h+1)/2;j++){
					nx--;
					cnt++;
					if(check()){
						printf("%d",cnt);
						return 0;
					}
				}
			else if(i==1)
				for(int j=0;j<h/2;j++){
					ny++;
					cnt++;
					if(check()){
						printf("%d",cnt);
						return 0;
					}
				}
			else if(i==2)
				for(int j=0;j<(h+1)/2;j++){
					nx++;
					cnt++;
					if(check()){
						printf("%d",cnt);
						return 0;
					}
				}
			else
				for(int j=0;j<h/2;j++){
					ny--;
					cnt++;
					if(check()){
						printf("%d",cnt);
						return 0;
					}
				}
		}
	}
	return 0;
}

## 第八题： 日志统计(满分21分)
### 题目描述：
> 小明维护着一个程序员论坛。现在他收集了一份"点赞"日志，日志共有N行。其中每一行的格式是：
ts id  
表示在ts时刻编号id的帖子收到一个"赞"。  
现在小明想统计有哪些帖子曾经是"热帖"。如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是"热帖"。  
具体来说，如果存在某个时刻T满足该帖在[T, T+D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是"热帖"。  
给定日志，请你帮助小明统计出所有曾是"热帖"的帖子编号。  

>【输入格式】
第一行包含三个整数N、D和K。  
以下N行每行一条日志，包含两个整数ts和id。  
对于50%的数据，1 <= K <= N <= 1000  
对于100%的数据，1 <= K <= N <= 100000 0 <= ts <= 100000 0 <= id <= 100000  

>【输出格式】
按从小到大的顺序输出热帖id。每个id一行。  

>【输入样例】
7 10 2  
0 1  
0 10    
10 10  
10 1  
9 1
100 3  
100 3  

>【输出样例】
1  
3  


>资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗  < 1000ms

个人感受：
    很烦的一道题。。 思路就是先筛选 ts大于k的   然后再按照 ts在 某段时间内多少排序。。
道理都懂。。就是弱鸡。。。。没写完就交了==  没写完的我  输入正常，输出 print("1\n3");
哈哈哈哈 看看能不能 骗上10分

### 题目答案：
```C++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+10;
struct node{
	int t,id;
}e[N];
bool cmp(node a,node b){	// 对结构体按某个条件排序 
	return a.t<b.t;
}
int sta[N],top;
int c[N];
int n,d,k;
bool insta[N];
int main()
{
	scanf("%d%d%d",&n,&d,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&e[i].t,&e[i].id);
	}
	sort(e+1,e+1+n,cmp);
	memset(c,0,sizeof(c));
	memset(insta,0,sizeof(insta));
	top=0;
	for(int i=1,j=1;i<=n;i++)
	{
		while(j<=n&&e[i].t-e[j].t>=d)
		c[e[j++].id]--;
		c[e[i].id]++;
		if(c[e[i].id]>=k&&!insta[e[i].id]){
			sta[top++]=e[i].id;
			insta[e[i].id]=1;
		}

	}
	sort(sta,sta+top);
	top=unique(sta,sta+top)-sta;
	for(int i=0;i<top;i++)
		printf("%d\n",sta[i]);
}
```

## 第九题：全球变暖(满分23分)
### 题目描述：
>你有一张某海域NxN像素的照片，"."表示海洋、"#"表示陆地，如下所示：
..\..\..\.
.#\#..\..
.#\#..\..
..\..##.
.\.####.
..\.###.
..\..\..\.
其中"上下左右"四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。  
由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。  
例如上图中的海域未来会变成如下样子：
..\..\..\.
..\..\..\.
..\..\..\.
..\..\..\.
..\..\#..
..\..\..\.
.\..\..\..
请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。  

>【输入格式】
第一行包含一个整数N。  (1 <= N <= 1000)  
以下N行N列代表一张海域照片。  
照片保证第1行、第1列、第N行、第N列的像素都是海洋。  

>【输出格式】
一个整数表示答案。

>【输入样例】
7 
..\..\..\.
.##..\..
.##.\...
..\..##.
..####.
...###.
..\..\..\.  

>【输出样例】
1  

>资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗  < 1000ms

个人感受：
    为啥样例 淹没是1.。没被淹没是1
我傻傻的看错了==  输出了相反的。。 阿西吧 心痛
反正我的就是两个bfs
还有一个很有趣的
有人给了一组这样的数据：
\### ###
\#######
\### ###
只有一个岛屿但是淹没后你会发现“岛屿”还会多出来一个！如下

\# # 

这个。。输出0还是-1.。我也不知道。。等答案了。。。


### 题目答案：
**这个 有一个正解代码**
```C++
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+10;
int dir[4][2]={-1,0,0,1,1,0,0,-1};
bool vis[N][N];
char mmp[N][N];
int n,flag;
bool check(int x,int y){//check if sea;
	for(int i=0;i<4;i++){
		int fx=x+dir[i][0];
		int fy=y+dir[i][1];
		if(fx&&fy&&fx<=n&&fy<=n&&mmp[fx][fy]=='.')
			return 1; //sea;
	}
	return 0; //no sea;
}
void dfs(int x,int y){
	vis[x][y]=1;
	if(!check(x,y))flag=1; //remain lu di
	for(int i=0;i<4;i++){
		int fx=x+dir[i][0];
		int fy=y+dir[i][1];
		if(fx&&fy&&fx<=n&&fy<=n&&!vis[fx][fy]&&mmp[fx][fy]=='#')
			dfs(fx,fy);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",mmp[i]+1);
	}
	memset(vis,0,sizeof(vis));
	int ans=0,ludi=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			if(!vis[i][j]&&mmp[i][j]=='#'){
            ludi++;
				flag=0; //yan mo
				dfs(i,j);
				if(flag) ans++; //remained
			}

	}
	printf("%d",ludi-ans);
}

```

## 第一题： 乘积最大(满分25分)
### 题目描述：
>给定N个整数A1, A2, ... AN。请你从中选出K个数，使其乘积最大。  
请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以1000000009的余数。  
注意，如果X<0， 我们定义X除以1000000009的余数是负(-X)除以1000000009的余数。
即：0-((0-x) % 1000000009)

>【输入格式】
第一行包含两个整数N和K。  
以下N行每行一个整数Ai。  
对于40%的数据，1 <= K <= N <= 100  
对于60%的数据，1 <= K <= 1000  
对于100%的数据，1 <= K <= N <= 100000  -100000 <= Ai <= 100000  

>【输出格式】
一个整数，表示答案。

>【输入样例】
5 3 
-100000   
-10000   
2   
100000  
10000  

>【输出样例】
999100009

>再例如：
【输入样例】
5 3 
-100000   
-100000   
-2   
-100000  
-100000

>【输出样例】
-999999829

资源约定：
峰值内存消耗（含虚拟机） < 256M
CPU消耗  < 1000ms

个人感受：
    别说了。。我 也不知道为啥。。第二个案例一直是-1.。。。脑阔疼  还是交了，毕竟如果都跟第一个案例一样。。我还是能对的==
瑟瑟发抖的提交了。。
看了大佬的分析 我终于知道弱鸡的自己错哪了==
### 题目答案：
【分析】像贪模拟贪心。

分了三种情况，1.不含负数，2.不含正数，3.正负都有。 0的情况可以同时放在这三种情况中。

情况1：从最大数开始选即可
情况2：先考虑能否为0，再考虑选偶数个最小负数，若都做不到，就选奇数个最大负数
情况3：最难。先考虑用尽量少的负数，尽可能用正数，再从最小负数开始考虑，每次拿两个，乘积去和最小整数的进行比较，若大于，则可用这两个负数替换那两个正数

**【代码】**
```C++      
#include<bits/stdc++.h>  
using namespace std;  
typedef long long ll;  
const int mod=1e9+9;  
const int N=1e5+10;  
  
bool cmp(int i,int j){  
    return i>j;  
}  
ll a[N],b[N];  
int ta,tb,n,k;  
int main()  
{  
    scanf("%d%d",&n,&k);  
    ta=tb=0;  
    int x;  
    int c0=0;  
    for(int i=0;i<n;i++)  
    {  
        scanf("%d",&x);  
        if(x>0)a[ta++]=x;  
        else if(x<0)b[tb++]=x;  
        else c0++;  
    }  
    sort(a,a+ta,cmp);  
    sort(b,b+tb);  
    ll ans=1;  
    if(tb==0) //positive and 0  
    {  
        if(ta<k)ans=0; //0  
        else {  
            for(int i=0;i<k;i++)  
                ans=ans*a[i]%mod;  
        }  
    }  
    else if(ta==0) //negetive and 0  
    {  
        if(k%2&&c0 || tb<k)ans=0;  
        else {  
            if(k%2) //k is odd, but no 0  
            {  
                for(int i=0,j=tb-1;i<k;i++,j--)  
                    ans=ans*b[j]%mod;  
            }  
            else{  
                for(int i=0;i<k;i++)  
                    ans=ans*b[i]%mod;  
            }  
        }  
    }  
    else  //-,+, 0  
    {  
        if(c0&&ta+tb<k){  
            ans=0;  
        }  
        else if(ta+tb==k&&c0==0){  
            for(int i=0;i<tb;i++)ans=ans*b[i]%mod;  
            for(int i=0;i<ta;i++)ans=ans*a[i]%mod;  
        }  
        else{  
            int fu;  
            if(k<=ta)fu=0;  
            else fu=(k-ta+1)&(-2);  
            cout<<"fu"<<fu<<endl;  
            int t=fu;  
            for(int i=fu;i<=tb&&i<=k;i+=2)  
                if(i>=2&&k-i>=0)  
                {  
                    cout<<"i "<<i<<endl;  
                    if(b[i-1]*b[i-2]>a[k-i]*a[k-i+1])  
                        t=i;  
                    else break;  
                }  
            for(int i=0;i<t;i++)  ans=ans*b[i]%mod;  
            for(int i=0;i<k-t;i++)ans=ans*a[i]%mod;  
        }  
    }  
    printf("%lld\n",ans);  
}  
```

个人总结：垃圾的我!
	一开始以为 对了8题(不难吧~)
	好的，发现两道题看错了
	对六道有省二嘛？	
	等到答案出来。。填空再去两道== 傻逼答案
	所以 愚人节快乐
	其实真的不难。。看到答案心态易爆炸
笑死人的讨论区，值得一看。。。
https://www.zhihu.com/question/270622751

想想是真的菜
好好努力 尽力试试能不能进入ACM训练队吧！
PS:其实省赛的难度真的不大，好好准备一下明年再来！



PS:居然水进了国赛。。。。美滋滋哈哈哈哈 开心了好久。。公费游北京  我来了！！！
最近多刷刷题 争取能有机会冲击国奖吧(虽然没啥可能)
2018/4/9