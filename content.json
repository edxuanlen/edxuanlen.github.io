{"meta":{"title":"edxuanlen's BLOG","subtitle":null,"description":null,"author":"edxuanlen","url":"https://edxuanlen.tk"},"pages":[{"title":"about","date":"2018-03-29T04:44:04.000Z","updated":"2020-02-06T22:40:22.808Z","comments":true,"path":"about/index.html","permalink":"https://edxuanlen.tk/about/index.html","excerpt":"","text":"人群： 广东潮汕人学府： 国立中央大学皇家林学院(南京林业大学)院系： 信息科学技术学院专业： 计算机科学与技术简介： 热爱计算机技术，虽然有时很宅，但也很爱运动。总之呢，开朗、骚气十足的程序员未养成。。。。。 so~ now! MAKE MORE TIME!!!"}],"posts":[{"title":"Zookeeper","slug":"Zookeeper","date":"2020-03-17T11:40:33.000Z","updated":"2020-03-18T05:12:14.290Z","comments":true,"path":"2020/03/17/Zookeeper/","link":"","permalink":"https://edxuanlen.tk/2020/03/17/Zookeeper/","excerpt":"","text":"Zookeeper是什么它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 上面的解释有点抽象，简单来说zookeeper=文件系统+监听通知机制。 参考博客 zookeeper 在底层其实只提供了两个功能 管理(存储，读取)用户程序提交的数据 并为用户程序提供数据节点监听服务 文件系统Zookeeper 维护一个类似文件系统的数据结构 每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。 有四种类型的znode： PERSISTENT-持久化目录节点 客户端与zookeeper断开连接后，该节点依旧存在 PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点 客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号 EPHEMERAL-临时目录节点 客户端与zookeeper断开连接后，该节点被删除 EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点 客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号 监听通知机制客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。 zookeeper 基于异常的分布式锁临时节点 他会监听节点 zookeeper 基于相互监听临时有序节点","categories":[],"tags":[],"keywords":[]},{"title":"Kubernetes","slug":"Kubernetes","date":"2020-03-16T01:00:12.000Z","updated":"2020-03-16T02:53:42.152Z","comments":true,"path":"2020/03/16/Kubernetes/","link":"","permalink":"https://edxuanlen.tk/2020/03/16/Kubernetes/","excerpt":"","text":"安装kubectl 1curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.17.0/bin/windows/amd64/kubectl.exe minikube 1https://github.com/kubernetes/minikube/releases or 1choco install minikube 在 Kubernetes 上使用 Kubernetes 命令行工具 kubectl 部署和管理应用程序。使用 kubectl，您可以检查集群资源；创建、删除和更新组件；查看您的新集群；并启动实例应用程序。 Minikube 是一种可以让您在本地轻松运行 Kubernetes 的工具。Minikube 在笔记本电脑上的虚拟机（VM）中运行单节点 Kubernetes 集群，供那些希望尝试 Kubernetes 或进行日常开发的用户使用。 Minikube 支持以下 Kubernetes 功能： DNS NodePorts ConfigMaps 和 Secrets Dashboards 容器运行时: Docker、CRI-O 以及 containerd 启用 CNI （容器网络接口） Ingress","categories":[],"tags":[],"keywords":[]},{"title":"面试专题","slug":"面试专题","date":"2020-03-13T06:46:51.000Z","updated":"2020-03-18T13:01:50.574Z","comments":true,"path":"2020/03/13/面试专题/","link":"","permalink":"https://edxuanlen.tk/2020/03/13/面试专题/","excerpt":"Here's something encrypted, password is required to continue reading.","text":"Hey, password is required here. 8b4df3bffb7f207d6d0efbbbdf157c24fe863e6bb15ce3b01ab3d8fa8b6b8e2e8192ba99959a7aedc2f4e5a865ac1f7b886353b6f093a13ac1be13fd8ad99ea503a171af641d4df796b9706c8e2540c7e05cd6c0e637a06793dc7854f053a6165c807c21d3c02c297d574f74a2e4f2accbcf61acd632c63c31262edf6f62534cb932df391973e59209f57af320d46dfd2c3c72a66580514543b47b7de2b31c72ff758342beaed450510eb2ba9e347faf5e1c719c4204e39f2a9cb1f150438760b53af04bf1a9308d9b712a590e49a5d2fe96c59a30e30b8da548f011f8c696663cc47e5f7437988259507a444e589090521ff2d06ecb0d4ab0a495f2286b26fc90b7ecfe06055f46b5db83999eb3654e3bfac3b161ed29fe8c9866ed5fa05977e7f6c33b7ea5d1e0086f348957ccc9dbbc941915c76ca9f1719701fecbd75c9d515debd5c14b1eb46ccb693d85266f022db1f1aad603b407468975ab8dc38c6446f464be8e186131bf971b1109d8438cb4c9bbf869211ddc17e3845f6bd587b5a4ebb99c9150289056811cc5da4309c3e4f9b84df8d14402885e3fff79bf109bdee16f537d40049c45ce76b35699e683bbf1005d8213dfc2d965e776da0a308011ce51468fbf93ef9097e9a79e0a5bfe0370e27624bc643a1d5b20d3a8d9089275a9b27d783fcbe884e204e98c65f993fff090aee2e52d38007ff71f2cb47ec2c9124ad8d3f00bf1ac79a96cbbe1ffcbe6a31d7d1421879b10f8295b7567eb5fe837d4ffe9bd8974b744a3080f4084210ac15f87f8501016f82b00ea0525a48ecf28bee11e8cf7759a776e271f870e9440ff9340257fa29e3705504db1b0a5f5046f3fef0bff4443102bd1781a8886733b9f3ea8b861e7f60507f3f23df71afad74540aae0491425e68e0c7de5227751629608d5b7bd2b2bdcc70b0c8b023e59935a0db7d8a243a03f893453e06200fd54013065fe6877fee2e6ef512bff28db8dd1b4db71dd658e0f322969ae12a1ab586d03d85b3a310d9201c28548a769d5f66089aafd49931f818e83ff81510ce9e70ad377547238a78474f5c4dcce64238ef12b936b9dcf0c7c2265bdb14abfdf1fbe51b8634220435577c74a5bcb1982064a548343d9f459c5cc90eebef94c00ad0d1fd350bcb20fe0be445d997e664e92df9dd9d435d07286ef69692e97525752e6e3a991c50e9c615b6fc050b04687a9db4e4745ef369339f226b90099285d4464a32183657a2b60ef66f703c00edf80e218cd42947cd1394ea9f992a47aa3f989e4998d350b08eef1422623efa849abdfb436ad05c3bfd2260b232d37a5f24220d49e32944aac7afc4e47d10dbb1f3f9e6f76905fc1c3e5e5daf5596dc546c31b3b598dbf2804a65893c7ab866961e177636e8dbd16eb472fe5735fcebf792544540a7495bfd087fe9ccf058d9f06b1264dcd253dc767a004deb196b6b985f745a63493c62e706f62d5e1a85c6e5593949d8e79f7eee1947ef2a16f0e08fe6828784ccc531264411dd8338560ebd7cf0577eae0354a2c4c64bdf68cf3cc51b99172f28f8d2b61c75a1e9b22fc48f183761109008de354f2a8d56b486da1a6bb25bb178b96896adf2f11a5a603f0fa7a240714766e19e1ef622661285cbff13f50b5551b9a41f4d0516783288eaf7dfd054a974825f1dbbe822ceaf84348451f7e68ffb2cd787b6d487706c4171ed73f72e7e22decb5cec2d5300956d4a60682545ee1021c3f12daa61409affcb823f2490f5c7593b98e6b4291ef0d1be9c6edc0faadf91ab9943b4067240b678a4194366ab86417217a833ad943d7a70f618967b6b8bfe196666546c6d73bd348bc80b732110e58f96d9c81e6d46d7cef4171d7e61cd3d421e151b74d6de05ae94267bbe8e4a4a216b5a72968fb6b80b292634523994acb59fc3219e3f9ea9f033587a47559d22157d1f1dc6713a5d07ba796e55a7e529a35b69ce631165b1036f003ffd37a94c0e1b93297236278ad6811b79ff2bf06192d343e2a4d697b5e1a1cd6d20c5f88b6199a9ea23059a7e5842dab7fb6fffcdb99a2c483bac00dafa1ff8a62f1ae7d1e70ae5d54bd7891c81206df99a4480d56092be41996de16ef38bd7662c2d9e33ec71d2407c0030c2a208696ad81b1d5f04ef10d8075d09186050d8beea46e42be6b729ac45c23a7af8f2e12274473375eeb6594beda9cce909a7d88823aadac03ddf1b6a2542010c015be8ddcea2bea47cd287284c1f870039296964d398243a86eee2ecafae78e676836bf50198b5caf97a7a6045ff5fe270ba45ceb719d71973e549e5eb36175f82815cd7117d8aafa87be0b322b36b0d563d00c373470a0bfd9e0ac2df8ecc6a572e93bee5b3fa6ec53e0c0227e09fd8dec3cacb5923a2a05326d07c32f7de1ba8cf5a6b0464e19e98f0976664bdc53595eb5df0cda2da8145fed8a15cd58e1b6fcbfae2e120ec4d26b69b8f75123a1fd3ac78dc4f8416d4fc0a93a1a9b05f98156b29aee2e6b50f1cfb594fd2b521644154844617595a62caf9cb4164f6fd9f3f3fa7b478f9dc70847eedc274110efbcc21962a7eef1ed74e4b3e6196f57d8943973cd7d54eae39cd7a219ce79c22635f22887aaefcae02fc5393b1ce0dba45f4a4bc193b78ae89ac7ab5d55419e4cf50ca77ad3fcae178a326cf9dd474f5755a8fa12efbb6f9f73b6b5129a3295610d4b9c02935fd0339ced05ba53bb5d233ffeabe8ddab83a628fbf0f465d469a099e59277a6edf2de25a2659fd48e4fb735d49a24e0a7e0419a4de5f63ac3165b45ef15d4a0217781bba717da5f66d42877f2fc2bad7a714f5a1196a934e4a51f403504836dded7e157b7922ddd229b219bf8da65b7bcd792267e3f8f9e0c52571da9d28b3044cc476c5e9ceb8fb6b89b59eb47056bba7e08070f40d9c00e842f50ecb52165d939d989dfd5080b7029ff376d9e9c402ac500553c40cddf1d6e299747773e82c51341aefcd606410674598ca4d512a4dc279f4411e8936d732851e296c3981aeb4e5678d5ea701a5395164a6b0d9092d639a7fbffafa6c8b861683dcff30ed0b980b0e999ac8cd5d57fd22cd8cc6bb18bd497c18504074d15e0f361e5cd023fce0c1bfd3a76995f4d657354a4eba151fd7815e8c6175906f63fd5ed353ebf08a99bec9006c1d3a58d0c88c1fbaf7b34b2d2c401abc738f6baf9b5e2779417f10f8ad8383278530b357f3edd57990143f27d1577958c6fd83e40f82b2e3871eb3069f2ba9dfb40e30fe9f1b8d5ce3de0205f524a1dfb0e25c4d00e4ebb7aaa8c9c5949ae272084b2e3181566f38a626ea0d6f583f18b2c791e5253f0c289197fe7aae89008d88eaa8ae1075f0554525eab916428fe7f60f71f301140e1c5f59037cffb97c067a9dcfc1534d37185923a9e26706b55040d21745996ee02a79e54e1b33d1ccc1f870e7d941a4925795b61e91fc23f9d4a4dd19b044ce7a40164a230bbce42e680712ae6e5daadd96facf168e63edfce6435c4c737abab6356ab47f08f9b7a14470783acaa13b04688bceeb05f9f1b2b3b8c9f96cba598ff04e62bb31051d2a13ce9d7631884c322753273c990b6f955bc3caa0aae067ff585f3617194595ca4a0a0b7b5f387a48dfaea94c56c65fd347f7591b5e09abd15748592b78183cb7ec99fc6d356d416192fbf639281cc8e7d26739a88d1f99d472bfd01c4638d4fb6c0d69e45f7c5dbbba11dc1e336c277b4764d57bb504424c6ad157e350ac9d98cfc7eea60e70255a4f8e963bcc5376b0b6f94c1aa938b5199420418bed85c4dc461eef5b67fdf6477b417678370296ad45c10442a9e9ef761e2c2b3aa6d8b45e5457ee7af722b7a0f75ece98c538503136f45b8421a1d70ec5af4c4a7f266ac9d5545ea8e3db2471cf46a55ac25bda14f3681f4a990303e79dcbb7400f17480909f764f4af0bda3f8253d7eccc657f3cf75307a2f3fc3be478ac7b875a79ca3a46e2d70a687a1cc8fdb01ecc1a9279e850b33b156d26a64d38b909ee6d5b08c12aac7013576fd0c461e11b75d4212a1312e9b7c534200eed821f74087dfbb33cdf6cb94a753331f8c41807ef27a04688dd4b0c521d055abfbb06c5003c0e01daa3d3bbabbbd9508e57fa11842e1c103c4b4d75b0659eb92a5c832d7f9b9777c99abc8909bb6d2a5a89766d02ea5b4f8b2547da812fc7a752031b83f959f8aa60ce680be791cfaea0e74e7b2f2656a71c0f860cb6656057d1654dead11180a246813bd2939e401b011c027bbe854a97c706e2e21130851d88e64c9dfbee6a97903ce0590ccf5311072c5c2562b2d8090c01630dd6cf457eb4d27e69a2939c790a4825ebdd25a259938ca8a91074e84eda5e2442b40859b4b981e0894095600139abca6807e573b5877d63f6670c2f2eae8fd255fadd245da5e1ddf186edba741c7d22e18b2dd2b8f71871bd29af40708fa9642d4f8c2ad7bc3fafe74fa62e59d12049c29eddbfe2efb1f34bc572cf962078abb2ddc3b32fae9ea65fce8dd1d5359f5ba3ff5afcab80550ba1594b0f20da3668c111cf47996ca98e3c9d53f862f3d1f458ed38f575cabc2dbf9f4bef78d749423cc247c85f5da5a3da61c69ef4fdebc030274175cebb9b268d502e0ef04d79ac24ab207ca621b173fcb6b4936dfd12fd38e380e4eb40a1a931d6c51a75ec5d7d1ba3369882f95a354143b3b15de0113de125feeef596a353984c7cb804d7ba071317af760101b0e8c1b513730e07c8ae0085b3678871575d2eff4ecab4de229d75a94b302bc8cd1f21a587ad5df29ad3240b150be24dd93f097b1ca9b37208d12868da962ca69102695124d72cd8ff01d8fb3818ef5d198609965b081cbf210db15202e8c3becdf7136c097894580c8a272d36136d31af0e07d8c3157966e9846747c0d8421e5f64bb535d676f05fe5653839cf4fa531d2cdc35495fab7d350e1ad5a2ffd46f40cb9c617d37371e436fe2bb857e404b8e58698564c7073ea7d302dcb9aafbcf30889c96c6e03a7728268d9f5e262923503060935a32e23c100deb1922ea95afac39016dc02f061159b674ed374e2098911f97301c327e7a2ee521800208a472a6018cc6a2d7eecd04b60df68a888e5a58429fcbd69583d8b074f30996530cfc0cfe8348d44ac513f275b3485233b735369e70a065b0a19fd1ff60b95ac3694743f450d6ca9950bff2b2197d67018d501e42cb0dfbd95770368ac9398c37912d0d1b17285bd3692be32f24301a5b4b28e930db66576faccd645a8a602abbfeffbeaa72d2a3e57ac4474bf5ba68b4e3b4b7f3dd641f37f2b969adac907ca18431c3e5dfa20627a25f95c1065060074a249e2aa3a8dd0999203fb55ee0a58d8dd28226c791e9c5d4ea69bedca73ebb2e43c93ee37f6bd836d35729d4393dadef211065ebf7419ef53d453f27986c5c553dc198bf14692bbdb3bd5711fd8f7bbac837d938d900b1092c63412cf598aa2b4e86b4f73b21c1fde751c502b8ae2d49305a81df3299617c04a570bbfabc0c747e575c2e4decd27cab7051905ac389dce92f46a9fea018a770b0d70cc3073add5387cc7ed2c36da291d86437d7149028f4bf8873ab81cf8bed0534cf881e180f92fc527e8e8491bfcf3e7a061cd8a50f3ff4b744cfe1e6dc7440a4655d4d9c488dd90fb5f006f63951bb941818f4cafeff013d86173c2e052440f20d60815b94cd1e253b50c5ab9195bea3a7f484dabc3777ad1826367a632b264a14e9843a07a4293af60c613059505656890e46ac645e0712ff868a795f6790451509e6c9bfee05da1f80f33aad2e1332a20f8daee76ec6895800cc67e1e8897262adc99d7a7291badc6556f7e61dce5c1d5637e611c425b205351d0b95be1881f5ddfd6396fd6d64eba95876398709a5aa8253f32df616e45671abe07769ba6e7e0fb5d96d1a31d2456a808a9517ab34c97d17da7870d3a6262920df20d1c915ed2ed0e3c96dae3a0f544bd28a635b1872e73d3b97a5b3b69e61a81fb5aae2c2ca7ad452abfe502793088d972f9e6f8a1d9f02dbdd3dac59f5f9c29240b1287d081de11b4f196f4e23e92024794d01d10474bc5eb3d2f9d3368369279360211c23fe921430b9ebf2cf52c44ea797ae8e836173a0a52ef4ed4a8e3c5c9d8008b96ef58ff037f80b9e00e950dd7a7c657808340072b134ddc49f67347ce0715693876ab4eace34c780fbb5f0b3a17a2b32d2b55daf0066c010b3a7b6ece79cc6e808b72bac969a67bc9a95fe7687d284c64c315cdbce30d1fa9e6bdfc7b6ddca4ddc1c10236ccec29a89d6e28a00a557ade55c34f1ec858ab907cfc8ec465749c49ccd4d0d93bfa9e53b2df2a69ecccbcb35b7bea751c8979d012c8daf4aed1ca79618d3e74435092910fb6675eb5bafc0253d448e22c9c5a897ca5ad32a2ce113e168bb9380aa0b0245cd263745250a6c1bba1b4fdf0f150f27ca34f05a124a914e7d3e9ebf5877fa8b7607fa73b7f18341ab8cd9758b8d6882b9c8c22e9916d84c6ad7ccd5fcdb91db002945acb920a2f8b89d305e1488e57164d4c1213e598b84a95d9449dd24b06f46b76f5abeb3fb1ff1cfc81bb2198b99a7ae777910f94c4aec8ff887018257566a4c17815255f75febdee6cfd2bef9409edc9aa1ad55c3463a0366cf540232170068a1aaaed8bddcb8043c254d18ddf1d38c3558b0a9f59ece6eab9c891adaae6c30438bdd89b1ae570b5474c0cf42821a0238e838e7d70bde821ff8632e6fe19b0d36ff62019fb2fc0724447d174c6f27e03db843c1d150553b19558da8f72c74b998912fe24edf639e4901639a75023b10ee92259397a66bce314ed0ce7336fa429b59cac5183e13cdd5c427b01c23e14dbc056d1d51d48d2db3759219a158e38963d298b45d483715a38f3b3280c186e16c7c8e9a6b3d88b6b281373087f8a58d1e412af091526698afff219ee1702296a417906fb5c85e08d82d7c3421d66e0203c201fd57493abe499165457bc0ca6496de4bc716d65950f30eb706d4ccffa90d00d530c79bafd8659084266557422e0573928d4b0db89e27cca75c83f79c871090bedcb34bb9190fce187894ff024e2d035bd5c41a5f25c938bbd5fa81ac18de275337e22f09f86d042872e661ca503b4aaf378608177d78cea9feff87d32912577c24ae984d257a2ef867c7d16c46fe600d7186d8386c29e7469846db6738de1dfa10c938ad6fc4475b73f323275101c5306d5948b3d22a44e9c2c1b53012210ea35c0ceb8d4aca9afc1bf346b183d15cab6abb0e033c6318fcc597aa7de437dc866af5879906d59d3c7f15d0eb26dce301f602ae1e9e6b7c24080baabc48d9498aa0fb1fa2c64a8434d04ff6f1d65d1ca2fcec9e8bc70b9a7c4a76f0400ce6302ad0866445e7f1999f0dfabc1d5f9957438818cf34e30e92e649af448f5626cbb327d5cfb35fac6c7eca4d2bdba9885accff972d5e30961939bff1e889de0b1455d071c2909795cd977f0544bcac0e8cd81094164d9c971b6b64da805584e4ffcbf1ab944d9326b07e90edb3b5191db060f8470af32def9979f6337a7f659826463f24f8ee007b4ccbcf2cdf0dac8851e2545cd00da54792879f2614e97928438cd1b57c7a5c99174055df6289de49004a1f1c53e9373428f4b84866a53aea6147872f17ef9e013612532578868bc52d252ff8ca0295401f777e2a2e4583d657772c6b64a82cc08a9cad166e3fbd3a6d8a0de2f9f942277ab33aef6a9f8428711bc8b440a30919b4789d7a14fbbae30d53f700017f29b6774d638ec89a39fac8851faf6c86b9d58c0570b568aca7620abe279caa438b44a728c27dd4dd64c6a4ec462115199f3b6b7270a4bf676ac3cfb8892a0f753a49b60d09df2336a7d38b8bb09978da580b6c1f7d98312874de5e12fa7ea3a89dda909f7e75337637dbc4327b2b4e74895efe3a9e6f66328672166b86931e12d53209bbea4a1bab01154bf4c68282191996f8ec4a825a45e4b82aa438bc8d976442f606018feab54eb67c08d140f8443c6aa6f6a0150ee22ed6147a4287265ccff36668029b11f5873b1906e3938f16af89b51eee27f17d3dc5e2db889ca606981d8c76e43168a56df365d1af6aa3e2fc787e9875a050371e4946a9278452ae8c9df8688c3a80a6d152c2cc5dc680b2d1ad5823f06eb593cc34620562dd1c55780b01f164e85a78fe9334db09ee31f0f8461b1807672bd2230f0479baed9400e7b4ab4084c6b26c7a04c86fd1647c010ba86fec6b212d798b8e3b8e276efab349f1de29418a341880279c403c44e46e0f27457e018320800b87a49eea66af9d5e355083cc60009ccc338f3017eeba5b4b379da87009bba37a1c70d896ad3d0c46f9fa5a524aa38277d14c716bd28a5b09d30089ff2a3fca28a9758c87ae5ad964b52372e0ff1405002a4b8942d55fad01a89eb652488468a490dcd9dcd0aa34931f6e70e1fade56153b48016eb5a5d487a6a3faba6b1d3b6786cadb17e319a853de0b3d262b9828864bf8674c26b020d55bfe1155e2cc3012c98a72dbfc7587cc53a4c43b2b81c0afb5235fda1d37b47eb1376750dfde7065dd8067fd27d2d4395262f3ef25b1bd7b42d276e46533f623532010467ef7cfd23416094310c311dccab996ab886679466e4aec9cd8d87d0265c58a4a79931e415ac820f6f5899703dcf24f4a09bd54ac0276066ec9da9911db092323222bd898ee30d25a66e0b6ab6aed56e7d0c7e249ebf5b411b6d4acfecf33a9d366c6f39ce652c851a6fd6fa8ab462add717cbbb0cc2ba588775e790a8088ffadf6d23d4621455d5a7a9a55145a7e75edd8e4d8cca9830c62befa3287d296869b9143663f28bd9a0d78e7b2cee3d3c26959987744d9acf344c4c9bb34df5ea2016d564f367c14175f3bcbca4e3b1085f2303c282603a52861aa0a829d7c4f08de22c7e454898799539d521daa45e92196d7a3225d83d5b06b6a1ddc43b499cdd5f346df3b37d8bd2cc89c0e2342330bf41085233c30996c03081f61139277cfb3de8daddd884b3f90b230ec87f5638ceb3afbaea883d16abef0680c495ddf0645888fc66d373996aeecc9c96a85d1a55c4f1686998f28f0e700d09e8a9011a2fae3c2ca544ffdc7076137359d5c5c10d0919054fc14a349d5c97ac3c60398a9d75f5ff81a51a1d1c4237a3c0450f6c4684651f48c4b6d2145fd1143c1d5bdda42d69c450a18b7a51620c58478d0f64ba793adfd290605a7811195748327365f13c68be0f8c0d45d1260f804b43aa6777839ec593f47467c7f521dfee6d652c34f4c1434ff3fe89b24f80cf30a348a9fdf6cd9b9a2977dba39482158ea24579867dc862907df086de3533c3018df7000cf3e1d5465ad33383ce4ba57c74d24fe88a383ba9a73f96992e020ad2377783020155796866778cc16484fa4f7abb65c81b95071c55a3ca1bbf4b6a1de8625724f0bf9fe73796bb9e98b7a659234d1f4b320cd6e7d30ed140835b9e4b704cdba218a9148ae684544229cc79288a537370c2e679b6b7311b61d75ef30b2878effe76b6f77d551cb5eb7b615e244e311922a40cceccda003b105e5f2b5f4dd68331a1810885ba32be1e0dd4fb5791970e831c8664c2391be155f6f53380cea0d119084a384dd0be8acfa7af3cb0efed5b14394372a4a1e4f3f44f047f1f63ae9b2424781f8095ccf890901fed86095fc319a856bc75a15f2314219039855b7a3f47ec54bd65b306ef5341509254b3dbb17d175420deb84442d9fdd3caaa2735b3d6b5394cf2989a358394c1bd0111295233b39bfc998d12dfb4e31bce00dc4cc6524449b7ef88c7fb5fbdfd226d12ce5a9c1502f9a7504bf5f578a0cb5e5c0a0bc6bfd0b547ac48aa5eca9b327bae20a1df8991d49b78bdb45ec3c05ce65a645069c02d1a99ebfb4aa5d5714becbe08898ad6da9205958082c4130903cc5e9448b120449215e21f791be4eecc213cac106fb8bb4542e7ad72a9d077c935a71407ac80cf02c3d46ba5a2769f34ba58b9e96d91eb0f60d07dda1749c09b7b274999ce90744eb632925bed5b4064897e8f0deae2fedb9b45dcf0c8c3132d101253e880958f19a0775737edeb14d244c1a133af8208d4a86a9674f0537a93054f8ed607642152d0f1ed9b9dcc531c381244cba441abae8e47a466e1c09fda1ea0310f4323c2bde3b1f9b2221795456478cee4de272698858563088f47a2b547b8e73284fdbc7159495503c3640b71062a0f67a966d7823a6c2e5102621b42da70309667304d4c551751b905d8ef5bb8fc7194df5e9ce6370e84327eb5f623d08b25c34994e772e0a644ac96d2349f562a35124a1ddc2b8122f4572adf67158498d4e3e0ceed2362fde445d69bcec563398f153fe72e5961561f0215445bcc69b11d57c0a1fb74a93bf439faa6b24eabec5dd949213509b0ac31bf41c6549e30b648749e6fb885d319a4ab593f1653d28438302447285d5e24aa206e5ba26689a5af408e9b138298487f1e9452ecdfbdd5b0ff8afa7c768eb9d0de45aee86908fc080073a8c9263d9652ac985fd53fa7e79651c73b4a1fed66d0e0f362009cadf4f2a5ead9f081d8b0daefc719fd756cf8ef64b3f7e1124f8e32f13622426b5b94f2a1576ae2ba9676a375ddb11fed721c781ae9a26508fc06a4e66efff220fe50d3abb380f3fd7c58f56db3a19fc9c6da489058e615fd047202e79bd46b0ab59962c6668bb56285a6b9cf2900a0765b7281fddfe969f3e5832670ec5c0d2d2b55538219622ec0f14a19f300dff963fc6b7ee57dc322d43eccb73626691263a4d8e6f74b024dec53fc9b37e2a3ba04e724c5257d2590b00066ca8786fe25e63f2808874b7e00a329f8934c6b8e06fa79c1c5180a7fba7cf5f97bd985d2de1240b271791386baf5a2fbb541716761ece8f7fd1bf6f88fda6e80f82262a8bb3f1a6917c4c78673ff4d387bdd2827e6555132799597d96021a5e6e7cee9873abc9514c16332c905e03a2579b67481f1ebe01446452c229ba08b6ec272f8288a51f97bb0efefbedcabff2a8938f0c469794af4ddcd61d7ff5413b2107bf2fe58fa4f77788cd093201f95f0feef9a6206c674fdf7bcd0194cc51093a12d4a9b1568aa3d180252b78b67ba5a80d943b75c877e66011cc85b7240b687d788ee0b36ec1d842c5afa36bf80f26d04dee7b9e865ada42a9b08f0cdc9df56fb75f026eaa88677e7f2ee05d1b3995da5dc934547922822ef46e0e383df05efd186af611fd7706ad76d2c14c26f5f9815a4a88d6dfc1bc1612c87fbfad444f9550260b45de3270183076187bf804bed2369d945cf14fac710d01e64f46a657dd8c2990638fbe35bd0a8277ec29f181df8bd03232d7ed2ff323524a44733fa603588263fa2175b007acdf696228c81802a02c5e150a7342feec9f5807e02bc0c80f7417e0345ab1aa8f1eb643d256192ae84eb002e6b1e0d87e49f0b04aa99cab85eb4970ec94b140f254ba3a3cb61ee2dbccb5877affd8fb644075d17a58948ba1a93b9c3cf6c6bd3ed255966d9530a12b2aea16ee39097f2d4e8775fd71adeee027a88cd72eb925be65ee820094d3cc64bd5a11cbb08671ec1d71130794428423ee1ffa53c9a4cbe4d9d4cade4ca51fe4a98f77f6005ea44c3d3795039fd3f3b39b5ab3ad288955acaa0b978cc20b2d646823d02edcbbea635c1d242a559b287979a7b0120ff103ef9056708164670377b9b58e92fdca22bd268876ee24c867cd74e5a337cb802ff9e0ff8a223f341135cb59bd0da3fa94a1a8df75da4f1c0a9d908fcec7bedd1b40bb384642a81c209c5661ee3bf9e90d563501a12d9370a1d03ecf26eea876d56612f397a78931e34b1d4cc20201a4030e1fe0a98e18575ded9ca067d71e4085b8027acbd3c617e9a08ec4ddc9d1f01db398862d37086f563f5bf9d892f3b7dfcf10cfdebfa7f5940a633ced7e46d494ad0b7a43868f358df545e1052d8b6489a1101916c1b420ae649c707504cbad2bf3f8bc4e8010b75dc4aae135f92099dd0fe757be2bf2b88dda133765117d57c7ea5eda1ce6b88e6fcce69778cf0f3f6790cba0bc3a40360133356c42538324ed6a0703e4e866a064a2ab3319f6e4c54ea409231859cdb54402b204730a1533940a3d609f4f741842d1e4e9fa9a28086c506ab099cf24cb26110d823c0a52b176b08aca48436fe7080dc927f6ec62bc7a2ead488300027b17dd83049ef3d3c1640395d45f362e32456461e0b0db6c1eb208f7f313cfa0408671e6aac71804ac5612f80b79bd8ad5f0b7749c8ad706f6961f003259b590ce660568b8f618113dbe549ce3672d4de9c1dae94a64f5f873987defeff27b3b960ec84a16af0b518f76d143705f088ce3be4d1f3b42eb5337b79ace5cf18cc90af7b8ff973ef794439096b0a897677182cdf8d86d120f54bbdf6914accc5e551a87343fda8b7e0fb3cbde51b17d1db0be1df3b5ab14a54ec2121504c69f17b581702e198b93e19b3e5b7209aabea779ec8560476a42c8c4929ee24b08fa506ccb3991db921712211f542224bf774cb544bd9f7bc6485872a32299a575031b949c278ca0339c24f1b90866279ad6f6deb438e7b435ba4f27a1527f40d25bc08db86cfdb855f1dabb7cc3c9630099f2bfb8e0e35c0618e06207190e93f8b135e95e967bf267066498be2e4a9150e69db71c72d3073c5522ef7f571294a9275d20e1ccf02f54dfa572816263524d62083a539f4c874a08e7caab2ed3308c06b9deed2f3e427a461ba1ffc81876fe5d78d6863130d9f930bf0eace9276453580810f0c97e28eeb395ea809de7f6d3693759a20d646f4b89786d26a684036d0a77215c2207c868e13abdaeab175e3551323dae44e188ce2a1a8b50c02eccc7902d897f9ceea1cb3d73312756d0a61dabaa691cad4db4c06627bc88d4a0d9c96a7ef589d176d41c8950642d7119d1f8964e30e3c6b43b5ffd206665b1d9e7f382c38427f663ac6f12ab510b70d5cae4ac866118dd5f2d55e2963de54ebd370d1c064f5af1109a72bb258a2a59cb3b25bb4482a7424f9076fa5cfd4b96d8c497a4960bda6cac11576c17325a81b4a22027d1f48ef5e62bc7e72b78fab022a9f1f95fd1dc61541c51a8651aaedbb88019b6c8f0b84167b0302532c599448a6a76bf3ec83b26015f7e236b8a52b7557af338357ed497a2880354bcf363012cfe62071cd4961e19369a703539b312e7077fe58afa5dffcbe91789bc165754ef76fbd6b292a7194374d62af6d5b458de0f47b7c99291e5c4e3cb4bdf5c46ecc0557e7ca64529772f047488984ba8cf2c611befdd445557e9b240f7e6024a8e626f123c8f6a26dadc3ad29e472355948084f4e6209b2e9f74eb2a9567819e960e50261b19cdf3cd40c2bcc40aca7dd5460bd4bcf1a1dae2dffdc3bf8fc8263fbd2dfdba6a0ddef4b11065f2aa4f8c6c90228fa16777fc27cb36079aa61aacb1bcc8469acf04f849ae7339d0e220cfb74aced0dbde147208450b36bad3a9852e251de7d14866d7a8668e8807ba3bfd91ab9548ac906380fafa2669f2356cdef018766d4fd7a157817eca2334af910ff66e62e028d66acc24bb4021764e62140865ff993bdccd4819e95285a080ba410ab83ae7b6bfa8e18cb6293f6c0d076f08a281e86ebc2d9b5375422f11da8826ede5cc8203853e6935ea523de8c5280f3e37c007065fd0d017b823941baca6c27d80234368c15b856d7e4a763b56d6314ae663f8191ab1de55098a444b7ea35fe93fb149b72eabe5b723117830dc381a5f7dd859b8fcf471fc0a744fe0ddfe37577fa885f72dad77ae42ad98437850daf9e8bd95a74d3803139da9f0ec178da5303858a699d8649abbd1e37f8679eded98ff13ab142f19022f41b0b28435692224d2b869656f9226d61703832c8d5f4897c4f0064c4d5ef9e4037777188850331103c59d879467030ce5b19c4b534a030eaec186fc32599b1a4431bec24dcd91e7ba36fe9f3125e8aa2fe9463c5470c1cdc730a57e1901c2b6b3abdf3227a09834c81aab33c502515bfdbeeed4ecf08827d0d3a46911e8d93da434392bb691cf7b2dd838836225d4ece265f08c2826fd8ca8fc027fe9bd642e6165ed29029d35baf21b6e3e2682de41bcef17eb1e0813a9c3b4fea5ce5848342e7be9c516c0ec963f027b27b4e0a2e5967d879620b45a653c76e1b634908fd14f7b0d9402a5b15d3db00162bb4c09b46c5e45d90b6a3b429fa0f68b48bc28bdbf4aab3e5bfffcc7b6ddc99d075048c660313d04cfe6866e19b32ca773cf8b25ff47495ae4ce7a090e6615d29f99b4a6ca448ee66c7abfd043f08a863d1602d057e9cf7cbc1e9cbda82a334a53b315e64874a1a63d4b611925a964edb78f6cb840e2caa3a4457b018e4b2b4d50de6e89bcc01d0f23ad3f03a2baf6e2bea2d1c98960989c8c8af4fc1c5c3ab9228b3e04f82aa3d56ef63715168a079d0146ff4657689a08b49d9becaf294cbb1232ca96d67b5fbd1d9fdc49a8c4e575c23cf6c60c432353f0e6043057c15afded4f2bbc1e022a5ecc5d5ac93cd25205f6879ab43c7a24df3b0e40bcec96bb727b804b8b2591a412639d0e0357190f31e49261f2aaded01bcd9f3f43081f6f946bf35907deea9e2dcd579c5b5c9dd8a67bdc99391d2119dfd45857e04fb918b1528ceb62a5fd2460e9d95e9a487f99fe7786a63672c5e30fca796483bff295d2c7c6419eb16a0f144a21e343af77edde1f45e224d739883be5efd9d327ccc80265e191a7c39e220d71e663db13b0e94ddf5c87da016224f23daa7d0284e71d89cfa058d1151440f04ba59f13a8de34826fd1bbfcb5badbf16a8087d623260ae4440d77cdcecc90c245f48da92935760a62ee208e16e2d3f9fcd7d58670df332f4ba5e39f5e5e5f56d175ae58f592db9d62f71a6cc6c6f9af9eebe7323eec95a3ab619f28540fd1a3c9d22f169cbab1ba6569ef7e1569440029dbb7276e55a97be79c425024547869838ac71837209b9e85d4dbfc0297487898d417dbe7796b715e3ae36e93fe8624510434979546d9e893d9bc7d1ec2fab480ba25141f335550710f4984441886af64c9e8107fbe39356caae5c29f9c24eb9c21ab7e7a2b503b0ad4365b3132337895ce3776ab50c703d5a657ade0b78b1db548222b14f9a9f57c883c64e4568dfaf510102702e6120967604abe2933ca850d2f368e03016b6c9a8cd3de4eed5a6b5317be7a413f930280c94304af94ff032482c4435c0383bf9e7d18a0893779224f4bab1112b5cdae1b1e86d83d55fdfa7ae5bd834a0847a3712852b5a65a36e28878d19952afdab95e3a1e61cb8d204b21f988ea693866046e890b35f4eecbd9563c97543af82eaac29cf4c2d0af0549ec323a9d65f0821e043b3e8eb26ee2bc9a5685adc871963277d6ec80f7114501b56dc3459dc4fac52ac118ff171ff40d3afeb5fe792554ff11f25aef3ac4c0a20f5995ddf9363eb4ff69173040d1016bee9621e9ec9e093aaab04ed66009c7764d23fdaafbf28418d630b3504b4a1d32cc7d4177d55a9230f23bce3464b0ac6bbcf8004be6615fbea749bebbc1cc1b28218c7828fd18d956bf877a0fedfdc9bb236b5087aa68543b0baddbd54d334303af2e15b33550d29cadacc36064487a53269899673c7bbcbacb2d0e0b3da0f63a60578206927c590b2ca405c48989dee1f8eb2597363bc00f8cff92c28da7818552823a1dc0ec37d12a7e2fb8f0676bb024ed566b5a4329155ce9f4607717d34f3064dddcbdcc7eb91407af89210acb71fc669f0e21fae35c8704b41280aac55f8a0e3fc5aaaadf64c0e4d8a7845f44c58b2d8427234b2cd05d3fe8d2a6acbfad519c985d1ddcc1c632b8452ed21dcde1bb22d0964b67bc09445802a5f37b1c9b7dcf7ff83a46cb230de79d92990a7aa697d782e53b2d485932bdb1db22c4774b89c087d6a6e2e6b5778ee717bcc1532e1c660c239bed016d25ffad74abe51cc76dd2147b6f4fa5683e2c32851165bb2ab0d6db2448271b70900120743d81f86cf13ecb62accd154f97c7af3081ab578e08b395aaacdfa5dabeba2ba3a9bc971e7af181b7a931122e321b96b3d2f00b42f271b0cfdf1270689af32d49518eb72b903055a43e0e85abf728c83dc1ed216c3acb5a5b3c7368f064791db8e40d53c2c3a5c74efa59c4994b932017cadbdd25c120f50caec65a49f26b755562eada09e86d3a478fd64028dce431ec0704610e67cc0a36487c8d42038223c0c3ddfe436f6896dce41a40765b7e64f2b2cf8434b1e19c230cb17b8c74c13a34c6606f78f2eba25e6746efc743fb41e7384bf07bea3e3b4acb8a8ef424802223cbe7a2d3d0d98c9120a76d993fc927dfcf88d2d614be3511b1268e00f54e2920264efcb4b80c383ecfcda48ccd9cc14eaa3c9c0381176d5f95d0ded74d81e033ea379dfa4708b4fdd3cf77af7ae8a36ba93152604725a46b5314f07dcbef37c1a15761f92c8134c926044cbcdc5f3a724acbc48f3edbd7826e712f9a28473f0e956acfc84c48058f360035b4bfb2d53b9f92ea902a575b1b184627b3c2f7e5685b6786cc58ae6ac25bdc51b23ece9614650e208a7ea2ad0468e37571c7a47d2b76ab089ac6e3958be9bc016551bb70a0f894d668d73285faac6ef5fd64f71ecf581158dfc294057715c5162f5d35917ff9e6e84dea3aa90c6bf8838970b7cffdbdbfb9e05d4ab2895996cec50c57dc9f722e951c92b99d1da14da572e7482e139667534e3a8cdb89bc1cace32086b9b50a0e79a9261229175fb6d149e9947c3f943addcbd812ea294cd464fa8dce2f5b18a92bee96ed5333156bcc2581c97f88b5ba6401790437abdbfd675f4589781f58f25d0fb8f238e0d70636a70a178ac563cece3ed5e60413b7dceba96d1a6348d5f867d3c2354468a744985f5939e4c80cb25520bb57431de82636d9aa9ad5fa4ed9c7a6c771caa0eb97dc7e23581cb09aa0384e76eb48186a80abe5cf402eca8fae639fd02d65c4d52926246f727961e512235bb0b9cc96e637012fb73958c3eb6925c35b0f8a9f77ea92c6782d280fe98c7e3bab1ede0f47785b68a6f665bab164e289ea6ca985f01c6ab9db84e763cf013772999c87e91316f3d7c48ea5a110b3fb50d44c481e79cce7a4a317863649ee60f3c089069f2958ee761f636d6270eb0393b3946c13d79bfe74c6dcb20fd743faf7a71e38fa1e274fdf00828a4f983f0db26899facc5345e6d2c019b28178af3bfc3e7c7a9347dd1b346f811f5b2b28765f446ddee4ea942c9ce4b7d6e1ed11e09ab0c773f5fcc7f969b506cc0a17d9664e20f6d8563a8d631df0ba3e1129f61adc0e343a1799bb071b148a2f1aa851c5147596be8faa6be623f0b58358c7c2ec55f23f7c6c89fff71f2fb21fa4f6ad1311eaac1225de09f4d63b439c6a15df10dc691d39be8e1ff83289afc71537ac36954f956c6a68e15fedb574130b233ced659a313c1cfbca45009ad99dda0fe3c91b7849a8541fd9e2914160c91b9fa45f1bbc56165aa66ead4996dbfe4a88fc170d549b07465c614a27e88dbc602aefb482537ee49953767750fc892ce05fa07a7452ad14d69ff2fda734c01a56bc6500fd50e37e30c29b1643b1a8914efbc1ae63ba0bfe0a983566da4796d2448f293bfce5c90577e0fa99c367a49544f5bcb3b1d32587b722c1322586cb14000fa97969edd1e143a79abd21369781b78ead510de59741704af43aae9b6956b783ad7e162d9844396accf7a150c33b9acb2486e7394d86eba840624857d5426af47ca7547ee26376a8c8b1ef792d57c29e667b9cf613762ac32d6fad7554686dcd6c54fd684b3ccd7757395e6584a6185695d5ce9478cd3384e96c988ca6b495b33c3d0327417e6ede6e72cef3913a641dafc6f22cfe2566478e28e15f56a6b57594e30eba63a2c524ee6828429da6dcac4360dedaac6c4a6f160fc1aae9cf112dd951ea9fe51ab1162b0d14795b88bd285275333a0d99ec71f8750ccf20e92836f33ffcb9cfee3fa51aad60f9047137e3256700ca5f368216982d8e117ea3463a4034d8f4a61a082d067b2d156577d1cb0bc86a1d0ad476eed965d2afca1f9a6e72af69378a282f31860b50609e1182b953aa27258eecd2a95d932244bd4f74bec0b4bcfa85a1b01b160f8af58934c586abfbcb5d8e43ac55b5b4e2b380847da45fe45e73b53977b1bc371d7a3f3886460cef38052e7ebd9b0778eac34716ad5312e0f57fbb575189ce4ddf7b9118d0300c3660ff7c9d85205179bf3c8f7f73881bdf668b01bb8084e674dc69dbe8b27e5a1e58da237a6733746df647900078266a79593bdda50f1d81271e9818c1c9b05de2917785bc5aae614a929e2545d6638ee0a44f8ac292294a1c4118514038d727c21ed08a3a0f684c313603913b6a5025c45f404598c02e90afa3f3fba2424e2caf189ef9a9cd4efbf34ced8d32e6d648539899744f77830221d5593665e0009cb0249e142edd0517daee7763235aa320b708f5ffc0a3b10a8dda05b6856f16c6b5bd333e2533085a5d407b58775cf8fcc8943993b21c7b71d0c9be7b76f6760f2f212d7044679637e750660548bc3f5f4eb70601b97bdd2412c235cdd0061212b2200ea933799dfe12b5a2710366dd62d93148c3e23fbf6751fc2124b5215ea9af58aabd620ff8802712e1b1a7cba9904c86e760ecbeddbc21ce14e7cf03f61fe66a429f1af7ac4af7c5b9972f0df902fe614f8c97ee24472dac1813a12ae0de905efe7aa5f200ea8d9f16a41d394793549a06d192b2bafeb3144bcfb5ac170919a5b472042103c6ce60fe9bf13c043660606191aa64c43f905a3b33d43dceefdaecd0046c946afa4040e6d1116cd80f228735c4fc2da959a90e61888ebc1a34e563d95c109b53151f0c445d01fd7927c96cada028e1c1b3316323a2c10dd0306b8577828a9f4feb41024936ebbcfbb255aaa3058daba002710a0ab8afae8b3f400d80cf4aa2469d40a86f4f701a7a48583c3ce2cfb7b8149e3b8c571c4b8aae37d02fb304ab479c998dc8ff94073c7e3c33db874cb7d3951942edef768102592fcb988caaa35996f58deb29f9bf3e0dceff8103f3f4405252db59317d9d4b11385a235d476c456845f93c19a84533f894134a0bd608b48db5b5993afad4812c4314d5c809c1ac1497d5629c4de3d6bae36f6cf068ea3d44dbd18c895f61a45904f6c43f79ba3688a0d82db685c2e06158b676f2872df2c3cf8208e2640c0073f505c7211b4b9c36a7c44f141cb90fcda3fc0152b8c29a61b55059192df81ad891cdf79186c3cdda1a8e8262a447735a05c766f28965de5dab49cee570f67f3bfed76ba56449f9c0c400451534b070e19fa639ff8de7bc35ae8e2bf4f3076c9b6dc30d8d5af4557478c5e4f98dfc51e24ebc0d9ce56278df25adf554b4f0ca8f9ef9b2880914eca20347f0b4ff49b08308349325e171f1d58ca749d2926bdcd357b063998b70aa3eba033c52582aa9fea7eceac506cc4350d602498651d02047a61c39508b7726786006b67416dbf8989df8c35b8bac6ce543815868895fd1d187c2ea8cf7b015f6c9cc8930c1eb70678accb4bd91bad6b36a0fcc0155a44800a6af85c4a06eb2c335bc849afa3cff7b1c39cb617db7b2082425913159545b6b097e219ec01678477d9cdfdd3d557bd433c6c5ba054399b3dbfca45de8c0f756c96a118be7d907ebc3df089c446e86ea076dc08a96d1b235122f20fa223ac4a8116f544363d684dd844b52cd6308cb82ccd910ce975bfd92c113ab260b7e214ad3b512bd6d3128aa2775a652f3d4ac0a1c89bdca625241ceab9852d8a055ee0780afae9b4670920f7b6149002714e8b8af1793e260039d6a0547e4f01c44e2c80bcee780bc0146ac576238b655b1148290dc6548b296cefd7b4dfe506686ed56402a8b082df6d29cd0d3ac123314f1ad8c0d057a8a49de6fabf02f9a667c531069a47973768c1ea452ed39a9ea04c1e6da793994bb3f02f0378990300c8c7efaf432fd747322c6d52ad9b147fb99ce4d5d747fe94a6617106cf676e50784278b76ddf2f1ee0eb13c891bf5bf8f2df4d52431c5d87f4ff7e01ef8f9cec1cdf230fc638cbc5fd57c6fb00032b5b584a38837752ee035f4871fcacc4b0e6120cf72e8c503dc9e9c8f86eeaddb84f66647ffb01c524374c9ab0fe7963d48184d9f4980476b7a3741276b4e7d03fec8bbd2d075730d64183eaebee58","categories":[{"name":"Java","slug":"Java","permalink":"https://edxuanlen.tk/categories/Java/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://edxuanlen.tk/tags/Interview/"},{"name":"Java","slug":"Java","permalink":"https://edxuanlen.tk/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://edxuanlen.tk/categories/Java/"}]},{"title":"hashmap","slug":"hashmap","date":"2020-03-12T12:14:45.000Z","updated":"2020-03-18T02:32:39.862Z","comments":true,"path":"2020/03/12/hashmap/","link":"","permalink":"https://edxuanlen.tk/2020/03/12/hashmap/","excerpt":"","text":"底层执行原理HashMap的存储结构数组、链表、红黑树(jdk1.8) 特点 快速存储 快速查找(O(1)) 可伸缩 hash算法所有的对象都有hashCode(使用key的)hash值的计算是 (hashCode) ^ (hashCode &gt;&gt;&gt; 16) 数组下标计算数组默认大小:16数组下标: hash &amp; (16 - 1) = hash % 16 Hash冲突Hash冲突单向链表: 用于解决Hash冲突的方案，加入一个next记录下一个节点 扩容扩容 数组变长2倍 0.75触发条件: 存储比例达到 75% 红黑树红黑树是一种二叉树，高效的检索效率 触发条件: 在链表长度大于8的时候，将后面的数据存在红黑树中。 Hashtable 和 ConcurrentHashMap 如何实现线程安全 未作同步控制时，代码在多线程下是不安全的。 HashMap的线程是不安全的 HashTable 都加入了synchronized ConcurrentHashMap 保证性能和线程安全 HashTable 整个只有一个锁, 而 ConcurrentHashMap 使用了分段锁 分段锁的思想JDK 1.7 之前,1000个桶分为16段上锁,而1.8及以后每个桶都有自己独立的锁. 确保了数据操作的高性能.","categories":[{"name":"Java","slug":"Java","permalink":"https://edxuanlen.tk/categories/Java/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://edxuanlen.tk/tags/Interview/"},{"name":"Java","slug":"Java","permalink":"https://edxuanlen.tk/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://edxuanlen.tk/categories/Java/"}]},{"title":"JVM","slug":"JVM","date":"2020-03-12T06:52:47.000Z","updated":"2020-03-18T02:32:29.953Z","comments":true,"path":"2020/03/12/JVM/","link":"","permalink":"https://edxuanlen.tk/2020/03/12/JVM/","excerpt":"","text":"JVM的内存布局 程序计数器: 记录程序的下一跳，像代码行号的指示器 JAVA虚拟机栈: 每个方法在被调用的时候就会创建一个栈帧，每个方法从调用到执行的过程，就对应着一个栈帧入栈到出栈的过程。 JAVA虚拟机堆: 是Java虚拟机所管理的内存中最大的一块。被所有线程共享的内存区域，对象实例在这里分配内存。是垃圾收集器(GC)管理的主要区域。 方法区: 存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，运行时常量池(RunTime Constant Pool)是方法区的一部分。 直接内存: 直接内存(Direct Memory) 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 1.6 运行时常量池在方法区，1.7后在堆中，1.8移除了方法区，多了元空间 垃圾回收机制标记-清楚算法(Mark-Sweep)内存碎片，内存不规整 复制算法空间浪费，总有一半以上的空间没被使用 标记-整理算法(Mark-Compact)内存区域块的移动，性能有所影响 把算法都用上分代收集，分新生代、年老代并行式垃圾回收 传统的GC收集器将连续的内存空间划分为新生代，老年代和永久代（JDK 8移除了永久代，约会了元空间Metaspace），这种划分的特点是各代的存储地址（逻辑地址，下同）是连续的。如下图所示：传统GC内存布局 而G1的各代存储地址是不连续的，每一代都使用了n个不连续的大小相同的区域，每个区域占有一块连续的虚拟内存地址。如下图所示： 新生代 复制算法， 老年代 用了标记清除算法G1 不再是划分为两大块，划分得更加详细，提出了很多性能上的提升。 参考文章: 美团技术团队 G1 GC模式G1提供了两种GC模式，Young GC和混合GC，两个都是完全停止世界的。* Young GC：允许所有年轻代里的区域。通过控制年轻代的区域个数，即年轻代内存*混合GC：将所有年轻代里的区域，外加根据全局并发标记统计转换收集收益高的多个老年代区域。在用户指定的目标范围内进行调整选择收益高的老年代地区。 由上面的描述可知，混合GC不是完整GC，它只能回收部分老年代的区域，如果混合GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行混合GC，就会使用串行所以我们可以知道，G1是不提供完整GC的。 上文中，多次提到了全局并发标记，它的执行过程类似CMS，但是不同的是，在G1 GC中，它主要是为混合GC提供标记服务的，而不是一次GC过程的一个必须重叠。 并发标记（Concurrent Marking）。这个阶段从GC Root开始对堆。并发标记（Concurrent Marking）。这个阶段从GC Root开始对堆。 最终标记（Remark，STW）。标记那些在并发标记阶段发生变化的对象，将被回收。清除垃圾（Cleanup）。清除空区域（没有存活对象的），加入免费列表。 第一阶段初始标记是共享了Young GC的暂停，这是因为他们可以替换root scan操作，所以可以说global并发标记是伴随Young GC而发生的。第四阶段清理只是回收了没有存活对象的Region ，所以它并不需要STW。 是G1HeapWastePercent：在全局并发标记结束之后，，实际上是由一些参数控制着的，另外也控制着其中老年代Region会被选入CSet。 * G1MixedGCLiveThresholdPercent，我们可以知道旧时代地区中有多少空间要被回收，在每次YGC之后和再次发生混合GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生混合GC。 ：旧世代区域中的存活对象的占比，只有在此后的参数之下，才会被选入CSet。 G1MixedGCCountTarget：一次全局并发标记之后，最大执行混合GC的次数。* G1OldCSetRegionThresholdPercent：一次混合GC中能被选入CSet的最多的上一代地区数量。 除了以上的参数，G1 GC相关的其他主要的参数有： |参数|意味着||:—-:|:—-:|:—-:||-XX：G1HeapRegionSize = n | 设置Region大小，并非最终值||-XX：MaxGCPauseMillis| 设置G1收集过程目标时间，设置值200ms，不是硬性条件||-XX：G1NewSizePercent|新生代系数，预设值5％||-XX：G1MaxNewSizePercent|新生代变量，预设值60％||-XX：ParallelGCThreads|STW期间，并行GC线程数||-XX：ConcGCThreads = n| 并发标记阶段，并行执行的线程数||-XX：正在启动堆占用率| 设置触发标记周期的Java堆占用率阈值。默认值是45％。这里的java堆占比指的是non_young_capacity_bytes，包括old + humongous| 杂多线程下 i– 不是一个原子性操作 CPU 线程 1:1 关系，时间片轮转机制 AtomicInteger 底层原理 CAS (compare and swap) ABA 问题 Sync 解决 synchronized(非公平), Lock （ReentrantLock 可重入锁）","categories":[{"name":"Java","slug":"Java","permalink":"https://edxuanlen.tk/categories/Java/"}],"tags":[{"name":"Interview","slug":"Interview","permalink":"https://edxuanlen.tk/tags/Interview/"},{"name":"Java","slug":"Java","permalink":"https://edxuanlen.tk/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://edxuanlen.tk/categories/Java/"}]},{"title":"Spring-IOC","slug":"Spring-IOC","date":"2020-03-09T07:08:21.000Z","updated":"2020-03-09T07:18:17.429Z","comments":true,"path":"2020/03/09/Spring-IOC/","link":"","permalink":"https://edxuanlen.tk/2020/03/09/Spring-IOC/","excerpt":"","text":"IOC也称为依赖注入， 创建bean时注入这些依赖项。 为什么使用Spring？ 没有Spring ，处理对象依赖问题内部new对象： 依赖对象 对象频繁创造，依赖关系复杂 解决： 以来对象频繁创造 单例 工厂 创建对象 newIntance() 反射 以来关系复杂 外部传入： a. 构造器传参 b. 方法传参 c. 属性反射 field.set(x)","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://edxuanlen.tk/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://edxuanlen.tk/tags/SpringBoot/"}],"keywords":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://edxuanlen.tk/categories/SpringBoot/"}]},{"title":"Spring-AOP","slug":"Spring-AOP","date":"2020-03-08T07:37:30.000Z","updated":"2020-03-12T07:22:50.556Z","comments":true,"path":"2020/03/08/Spring-AOP/","link":"","permalink":"https://edxuanlen.tk/2020/03/08/Spring-AOP/","excerpt":"","text":"Spring AOP 传统OOP开发中的代码逻辑自上而下，而这些过程会产生横切性的问题。而这些问题又与主业务逻辑关系不大，散落在代码的各个地方，难以维护。AOP的编程思想就是把这些问题和主业务逻辑进行分离，从而起到解耦的目的。 技术本质AOP 底层原理： 动态代理(cglib 动态代理,JDK 动态代理) 如果是接口，就是JDK 动态代理， 否则是cglib动态代理默认是java动态代理","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://edxuanlen.tk/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://edxuanlen.tk/tags/SpringBoot/"}],"keywords":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://edxuanlen.tk/categories/SpringBoot/"}]},{"title":"自建SS服务","slug":"自建SS服务","date":"2019-10-09T09:47:28.000Z","updated":"2020-03-08T07:37:50.142Z","comments":true,"path":"2019/10/09/自建SS服务/","link":"","permalink":"https://edxuanlen.tk/2019/10/09/自建SS服务/","excerpt":"","text":"最近zf的净网行动导致了很多VPN崩溃了，由于科学上网的需要，我决定自己动手搭建一个VPN事实证明特别简单，费用也不是很高，($2.5/month) 服务器选用和购买由于需要外网ip的VPS才能科学上网，所以需要一个国外的服务器。这里要注意的是 千万不要选阿里云等国内代理商的国外服务器 原因是他不会允许你使用服务器代理流量访问国外的网站， 如果你这么做了会接受到警告和封闭 我们可以选用国外服务器的代理商，我选用了Vultr，因为对比下来价格最便宜注册送$50, 但仅限于第一个月内用我选用了一个美国的服务器, 最低$3.5/mo不同地区的价格和延迟都不一样，大家自己都可以试一下要注意的是，$2.5/mo的服务器是ipv6 only 安装相关软件123sudo apt-get -y update &amp;&amp; sudo apt-get install python-pip python-setuptools m2crypto shadowsocksssserver -s 0.0.0.0 -p 2333 -k \"QWERTYU\" -t 600 -m aes-256-cfb// 2333是服务器开放的ssr的端口，QWERTYU是连接的密码，最大延迟时间，aes-256-cfb是加密方式 这样就可以运行了，只需要本地用shadowsocks的客户端连接即可。需要客户端可以到 https://github.com/Alvin9999/new-pac/wiki/ss免费账号#ssssr免费账号长期更新 去下载 上面ssr服务器端的配置也可以写成一个配置文件 1234cd ~mkdir sscd ssvim ss.json ss.json 内容如下: 123456789&#123; \"server\":\"0.0.0.0\", \"server_port\": 2333, \"local_address\": \"127.0.0.1\", \"local_port\": 1080, \"password\":\"QWERTYU\", \"timeout\":600, \"method\":\"aes-256-cfb\"&#125; 然后运行： 1ssserver -c ~/ss/ss.json 后台挂起 1nohup ssserver -c ~/ss/ss.json &gt;/dev/null 2&gt;&amp;1 &amp; 如果有需求，但自己不想搭的话也可以联系我，或者在下面评论，可以一起合租一个服务器。// 5835 参考博客: https://viencoding.com/article/90","categories":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/categories/应用/"}],"tags":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/tags/应用/"}],"keywords":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/categories/应用/"}]},{"title":"Spring_boot第一个应用的开发","slug":"Spring-boot第一个应用的开发","date":"2019-10-02T02:45:00.000Z","updated":"2020-02-06T22:40:22.771Z","comments":true,"path":"2019/10/02/Spring-boot第一个应用的开发/","link":"","permalink":"https://edxuanlen.tk/2019/10/02/Spring-boot第一个应用的开发/","excerpt":"","text":"生成项目使用Intellij IDEA点击菜单栏 File ➤New➤Project ➤ 选择 Spring Initializr 创建界面如下图，可以看到图中 default 指定的 Initializr Service URL 就是 Spring 官方提供的 Spring Initializr 工具地址，一般默认即可，所以这里创建的工程实际上也是基于它的 Web 工具来实现的。 关于工程的一些信息： Group 顾名思义就是你的公司名，一般是填写com.公司名。 Artifact groupId 和 artifactId 是maven管理项目包时用作区分的字段，就像是地图上的坐标。这里填写项目名即可。 Type 就是构建的项目类型，意思就是你希望你的项目使用什么工具构建，可选 maven 和 gradle 一般选 maven。 Language 顾名思义就是你的项目用啥语言开发，可选 Java、Groovy、Kotlin Packaging 就是你希望你的项目打成什么形式的包，可选 Jar、War SpringBoot 项目一般选 Jar Java Version 意指项目使用的 java 版本，根据你的需要选择。 Version 项目的初始版本，默认即可。 Name 项目名称。 Description 项目描述，默认即可。 Package 包名，填完 Group 和 Artifact 后自动生成，默认即可。 选择需要的配置 其中web中的web必选 然后生成项目 spring 官网spring.io网站包含很多Spring Boot”入门”指南，如果你正在找特定问题的解决方案，可以先去那瞅瞅。你也可以简化下面的步骤，直接从start.spring.io的依赖搜索器选中web starter，这会自动生成一个新的项目结构。具体详情参考文档。 POM创建Maven pom.xml文件，是构建爱你项目的处方。如下: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.1.BUILD-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt; &lt;!-- (you don't need this if you are using a .RELEASE version) --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 这样一个可工作的构建就完成了，你可以通过运行mvn package测试它（暂时忽略”jar将是空的-没有包含任何内容！”的警告）。 编写代码为了完成应用程序，我们需要创建一个单独的Java文件。Maven默认会编译src/main/java下的源码，所以你需要创建那样的文件结构，并添加一个名为src/main/java/Example.java的文件： 12345678910111213141516171819202122// Example.javaimport org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping(\"/\") String home() &#123; return \"Hello World!\"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; 解析代码@RestController 和 @RequestMapping 注解Example类上使用的第一个注解是@RestController，这被称为构造型（stereotype）注解。它为阅读代码的人提供暗示（这是一个支持REST的控制器），对于Spring，该类扮演了一个特殊角色。在本示例中，我们的类是一个web @Controller，所以当web请求进来时，Spring会考虑是否使用它来处理。 @RequestMapping注解提供路由信息，它告诉Spring任何来自”/“路径的HTTP请求都应该被映射到home方法。@RestController注解告诉Spring以字符串的形式渲染结果，并直接返回给调用者。 注：@RestController和@RequestMapping是Spring MVC中的注解（它们不是Spring Boot的特定部分），具体参考Spring文档的MVC章节。 @EnableAutoConfiguration注解第二个类级别的注解是@EnableAutoConfiguration，这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。由于spring-boot-starter-web添加了Tomcat和Spring MVC，所以auto-configuration将假定你正在开发一个web应用，并对Spring进行相应地设置。 Starters和Auto-Configuration：Auto-configuration设计成可以跟”Starters”一起很好的使用，但这两个概念没有直接的联系。你可以自由地挑选starters以外的jar依赖，Spring Boot仍会尽最大努力去自动配置你的应用。 main方法应用程序的最后部分是main方法，这是一个标准的方法，它遵循Java对于一个应用程序入口点的约定。我们的main方法通过调用run，将业务委托给了Spring Boot的SpringApplication类。SpringApplication将引导我们的应用，启动Spring，相应地启动被自动配置的Tomcat web服务器。我们需要将Example.class作为参数传递给run方法，以此告诉SpringApplication谁是主要的Spring组件，并传递args数组以暴露所有的命令行参数。 运行代码到此，示例应用可以工作了。由于使用了spring-boot-starter-parent POM，这样我们就有了一个非常有用的run目标来启动程序。在项目根目录下输入mvn spring-boot:run启动应用：","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://edxuanlen.tk/categories/JAVA/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://edxuanlen.tk/tags/Spring/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://edxuanlen.tk/categories/JAVA/"}]},{"title":"Spring_boot入门","slug":"Spring-boot入门","date":"2019-10-01T14:17:28.000Z","updated":"2020-02-06T22:40:22.770Z","comments":true,"path":"2019/10/01/Spring-boot入门/","link":"","permalink":"https://edxuanlen.tk/2019/10/01/Spring-boot入门/","excerpt":"","text":"是什么 spring boot其实就是一个启动spring项目的一个工具而已。从最根本上来讲，Spring Boot就是一些库的集合，它能够被任意项目的构建系统所使用。其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。Spring 技术栈的大整合，J2EE开发的一站式解决方案 微服务2014年，Martin fowler 发表了微服务的设计思想 （What are Microservices）微服务其实是一种架构风格一个应用应该是一组小型服务，可以通过HTTP来进行沟通 安装准备 java SDK 8 &lt;= JDK &lt;= 11 Maven Maven &gt;= 3.3 在许多操作系统上，Maven可以与软件包管理器一起安装。如果您使用OSX Homebrew，请尝试brew install maven。 Ubuntu用户可以运行sudo apt-get install maven。 使用Chocolatey的 Windows用户可以从提升（管理员）提示符运行choco install maven。 Gradle Gradle &gt;= 4.4 使用sdkman安装 curl -s “https://get.sdkman.io&quot; | bash 安装完后输入 source “$HOME/.sdkman/bin/sdkman-init.sh” sdk install gradle 5.6.2 Sprint Boot CLI sdk install springboot 使用Spring CLI示例下面是一个相当简单的web应用，你可以用它测试Spring CLI安装是否成功。创建一个名叫app.groovy的文件： 12345678@RestControllerclass ThisWillActuallyRun &#123; @RequestMapping(\"/\") String home() &#123; \"Hello World!\" &#125;&#125; 然后只需在shell中运行以下命令： 1$ spring run app.groovy 注：首次运行该应用将会花费一些时间，因为需要下载依赖，后续运行将会快很多。 使用你最喜欢的浏览器打开localhost:8080，然后就可以看到如下输出： Hello World! 下一篇 : 第一个应用的开发","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://edxuanlen.tk/categories/JAVA/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://edxuanlen.tk/tags/Spring/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://edxuanlen.tk/categories/JAVA/"}]},{"title":"主席树","slug":"主席树","date":"2019-09-26T03:11:24.000Z","updated":"2020-02-06T22:40:22.785Z","comments":true,"path":"2019/09/26/主席树/","link":"","permalink":"https://edxuanlen.tk/2019/09/26/主席树/","excerpt":"","text":"","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://edxuanlen.tk/tags/模板/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"hexo的一些使用记录","slug":"hexo的一些使用记录","date":"2019-09-23T00:25:30.000Z","updated":"2020-02-06T22:40:22.776Z","comments":true,"path":"2019/09/23/hexo的一些使用记录/","link":"","permalink":"https://edxuanlen.tk/2019/09/23/hexo的一些使用记录/","excerpt":"","text":"BlueLake 的使用BlueLake配置 报错cannot read property ‘count’ of undefined百度的插件有问题 1231. npm remove hexo-baidu-url-submit2. hexo clean3. hexo g","categories":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/categories/网站/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/tags/网站/"}],"keywords":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/categories/网站/"}]},{"title":"线段树模板","slug":"线段树模板","date":"2019-09-23T00:22:37.000Z","updated":"2020-02-06T22:40:22.801Z","comments":true,"path":"2019/09/23/线段树模板/","link":"","permalink":"https://edxuanlen.tk/2019/09/23/线段树模板/","excerpt":"","text":"线段树区域加模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# include &lt;bits/stdc++.h&gt;# define ls (p &lt;&lt; 1)# define rs (p &lt;&lt; 1 | 1)using namespace std;const int MAXN = 100010;int n;typedef long long ll;int a[MAXN + 2];struct tree&#123; int l, r; ll pre, add;&#125;t[4 * MAXN + 2];inline void build(int p, int l, int r)&#123; t[p].l = l; t[p].r = r; if (l == r)&#123; t[p].pre = a[l]; return ; &#125; int mid = l + r &gt;&gt; 1; build (ls, l, mid); build (rs, mid + 1, r); t[p].pre = t[ls].pre + t[rs].pre;&#125;inline void spread(int p)&#123; // 向下传递懒标记 if(t[p].add)&#123; t[ls].pre += t[p].add * (t[ls].r - t[ls].l + 1); t[rs].pre += t[p].add * (t[rs].r - t[rs].l + 1); t[ls].add += t[p].add; t[rs].add += t[p].add; t[p].add = 0; &#125;&#125;inline void change(int p, int x, int y, int z)&#123; if(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r)&#123; // 覆盖 t[p].pre += (ll)z * (t[p].r - t[p].l + 1); t[p].add += z; return ; &#125; spread(p); int mid = t[p].l + t[p].r &gt;&gt; 1; if(x &lt;= mid ) change (ls, x, y, z); if(y &gt; mid ) change (rs, x, y, z); t[p].pre = t[ls].pre + t[rs].pre;&#125;inline ll ask(int p, int x, int y)&#123; if(x &lt;= t[p].l &amp;&amp; y &gt;= t[p].r) return t[p].pre; spread(p); int mid = t[p].l + t[p].r &gt;&gt; 1; ll ans = 0; if( x &lt;= mid ) ans += ask(ls, x, y); if( y &gt; mid ) ans += ask(rs, x, y); return ans;&#125;int main()&#123; ios::sync_with_stdio(false); int n, m; cin &gt;&gt; n &gt;&gt; m; int s, x, y, k; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; build(1, 1, n); while ( m -- )&#123; cin &gt;&gt; s; if( s == 1 )&#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; change(1, x, y, k); // cout &lt;&lt; ask(1,1,n) &lt;&lt; \"\\n\" ; &#125; else &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; ask(1, x, y) &lt;&lt; \"\\n\"; &#125; &#125; return 0;&#125; 线段树区间加，乘法和查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define rs p * 2 + 1#define ls p * 2using namespace std;typedef long long ll;const int MAXN = 100001;int n, m, a[MAXN];ll mod = 0xfffffffffffffff; // mod 注意修改struct node &#123; ll sum, l, r, mul, add;&#125; t[MAXN * 4 + 1];int read() &#123; ll x = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;&#125;void build(ll p, ll l, ll r) &#123; t[p].l = l, t[p].r = r; t[p].mul = 1; if (l == r) &#123; t[p].sum = a[l] % mod; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(ls, l, mid); build(rs, mid + 1, r); t[p].sum = (t[ls].sum + t[rs].sum) % mod;&#125;void spread(ll p) &#123; t[ls].sum = (ll)(t[p].mul * t[ls].sum + ((t[ls].r - t[ls].l + 1) * t[p].add) % mod) % mod; t[rs].sum = (ll)(t[p].mul * t[rs].sum + (t[p].add * (t[rs].r - t[rs].l + 1)) % mod) % mod; // add已经乘过mu啦 t[ls].mul = (ll)(t[ls].mul * t[p].mul) % mod; t[rs].mul = (ll)(t[rs].mul * t[p].mul) % mod; t[ls].add = (ll)(t[ls].add * t[p].mul + t[p].add) % mod; t[rs].add = (ll)(t[rs].add * t[p].mul + t[p].add) % mod; t[p].mul = 1, t[p].add = 0;&#125;void add(ll p, ll l, ll r, ll k) &#123; if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) &#123; t[p].add = (t[p].add + k) % mod; t[p].sum = (ll)(t[p].sum + k * (t[p].r - t[p].l + 1)) % mod; return; &#125; spread(p); t[p].sum = (t[ls].sum + t[rs].sum) % mod; ll mid = (t[p].l + t[p].r) &gt;&gt; 1; if (l &lt;= mid) add(ls, l, r, k); if (mid &lt; r) add(rs, l, r, k); t[p].sum = (t[ls].sum + t[rs].sum) % mod;&#125;void mul(ll p, ll l, ll r, ll k) &#123; if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) &#123; t[p].add = (t[p].add * k) % mod; t[p].mul = (t[p].mul * k) % mod; t[p].sum = (t[p].sum * k) % mod; return; &#125; spread(p); t[p].sum = t[ls].sum + t[rs].sum; ll mid = (t[p].l + t[p].r) &gt;&gt; 1; if (l &lt;= mid) mul(ls, l, r, k); if (mid &lt; r) mul(rs, l, r, k); t[p].sum = (t[ls].sum + t[rs].sum) % mod;&#125;ll ask(ll p, ll l, ll r) &#123; if (t[p].l &gt;= l &amp;&amp; t[p].r &lt;= r) &#123; return t[p].sum; &#125; spread(p); ll val = 0; ll mid = (t[p].l + t[p].r) &gt;&gt; 1; if (l &lt;= mid) val = (val + ask(ls, l, r)) % mod; if (mid &lt; r) val = (val + ask(rs, l, r)) % mod; return val;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; a[i] = read(); &#125; build(1, 1, n); for (int i = 1; i &lt;= m; i++) &#123; int ty = read(); if (ty == 1) &#123; ll cn = read(), cm = read(), cw = read(); add(1, cn, cm, cw); &#125; else &#123; ll cn = read(), cm = read(); cout &lt;&lt; ask(1, cn, cm) &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://edxuanlen.tk/tags/模板/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"给博客添加live2d","slug":"给博客添加live2d","date":"2019-09-23T00:11:23.000Z","updated":"2020-02-06T22:40:22.801Z","comments":true,"path":"2019/09/23/给博客添加live2d/","link":"","permalink":"https://edxuanlen.tk/2019/09/23/给博客添加live2d/","excerpt":"","text":"live2d 相关博客live2d 模型预览 live2d 它想动","categories":[],"tags":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/tags/网站/"}],"keywords":[]},{"title":"Docker","slug":"docker","date":"2019-09-21T16:00:00.000Z","updated":"2020-03-16T08:54:43.323Z","comments":true,"path":"2019/09/22/docker/","link":"","permalink":"https://edxuanlen.tk/2019/09/22/docker/","excerpt":"","text":"换源 settings -&gt; daemon 点击basic 变成 advanced “registry-mirrors”:[“https://docker.mirrors.ustc.edu.cn“] applay Docker中国区官方镜像 : https://registry.docker-cn.com 网易 : http://hub-mirror.c.163.com ustc : https://docker.mirrors.ustc.edu.cn 中国科技大学 : https://docker.mirrors.ustc.edu.cn 阿里云容器 : https://cr.console.aliyun.com/( 首页点击“创建我的容器镜像” 得到一个专属的镜像加速地址，类似于“https://1234abcd.mirror.aliyuncs.com”) 1234567891011121314&#123; \"registry-mirrors\": [ \"http://xxxxx.mirror.aliyuncs.com\", \"http://registry.docker-cn.com\", \"http://docker.mirrors.ustc.edu.cn\", \"http://hub-mirror.c.163.com\" ], \"insecure-registries\": [ \"registry.docker-cn.com\", \"docker.mirrors.ustc.edu.cn\" ], \"debug\": true, \"experimental\": true&#125; Dockerfilehow to write a dockerfile? Create an empty directory on your local machine.Change directories (cd) into the new directory,create a file called Dockerfile,copy-and-paste the following content into that file, and save it.Take note of the comments that explain each statement in your new Dockerfile. 12345678910111213# Use an official Python runtime as a parent imageFROM python:3.4-alpine# Set the working directory to /appADD /app# Copy the current directory contents into the container at /appCOPY . /app# Install any needed packages specified in requirements.txtRUN pip install -r requirements.txt# Define environment variableENV NAME python_web# Run app.py when the container launchesCMD [\"python\", \"app.py\"] Docker-compose官方文档 https://docs.docker.com/compose/overview/官方例子 https://docs.docker.com/compose/gettingstarted/ Using Compose is basically a three-step process: Define your app’s environment with a Dockerfile so it can be reproduced anywhere. Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment. Run docker-compose up and Compose starts and runs your entire app. 设置支持中文 -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。-v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。-v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。-v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 常用镜像mysql1docker run --name some-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql 官方文档:官方文档 外界访问权限 1234use mysql;ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root';grant all privileges on *.* to 'root'@'%';flush privileges; Mysql:5.712345docker pull mysql:5.7docker run -p 3306:3306 --name mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=19980504 --restart=always -d mysql:5.7docker exec -it mysql env LANG=C.UTF-8 bash nodejs1docker run -it -e \"NODE_ENV=production\" -u \"node\" -m \"300M\" --memory-swap \"1G\" -w \"/home/node/app\" -v D:\\coding\\web\\nodejs:/home/node/app --name \"node\" -d node 检查容器设置docker inspect","categories":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/categories/应用/"}],"tags":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/tags/应用/"}],"keywords":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/categories/应用/"}]},{"title":"蓝桥杯试题集_基础练习","slug":"蓝桥杯试题集-基础练习","date":"2019-02-20T08:22:50.000Z","updated":"2020-02-06T22:40:22.805Z","comments":true,"path":"2019/02/20/蓝桥杯试题集-基础练习/","link":"","permalink":"https://edxuanlen.tk/2019/02/20/蓝桥杯试题集-基础练习/","excerpt":"","text":"蓝桥杯基础练习 BASIC 1 闰年判断 问题描述 12345给定一个年份，判断这一年是不是闰年。当以下情况之一满足时，这一年是闰年：1. 年份是4的倍数而不是100的倍数；2. 年份是400的倍数。其他的年份都不是闰年。 输入格式 1输入包含一个整数y，表示当前的年份。 输出格式 12输出一行，如果给定的年份是闰年，则输出yes，否则输出no。说明：当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。 样例输入 12013 样例输出 1no 样例输入 12016 样例输出 1yes 数据规模与约定 11990 &lt;= y &lt;= 2050 问题分析略 AC代码1234567891011# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int y; cin &gt;&gt; y; if( y % 4 == 0 &amp;&amp; ( y % 400 == 0 || y % 100 != 0) ) puts(\"yes\"); else puts(\"no\"); return 0;&#125; BASIC 2 01字串问题描述 1234567对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是：0000000001000100001100100请按从小到大的顺序输出这32种01串。 输入格式 1本试题没有输入。 输出格式 1输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出 1234500000000010001000011&lt;以下部分省略&gt; 问题分析 可以循环嵌套实现 可以模拟二进制直接从低位到高位逢2进位 也可以直接使用STL的容器bitset AC代码123456789101112// 循环嵌套# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; for(int i1 = 0; i1 &lt; 2; i1 ++) for(int i2 = 0; i2 &lt; 2; i2 ++) for(int i3 = 0; i3 &lt; 2; i3 ++) for(int i4 = 0; i4 &lt; 2; i4 ++) for(int i5 = 0; i5 &lt; 2; i5 ++) cout &lt;&lt; i1&lt;&lt; i2 &lt;&lt; i3 &lt;&lt; i4 &lt;&lt; i5 &lt;&lt; endl; return 0;&#125; 12345678910111213141516// 模拟二进制# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a = \"00000\"; for(int i = 0; i &lt; 32 ; i ++)&#123; cout &lt;&lt; a &lt;&lt; endl; a[4] += 1; for(int j = 4 ; j &gt;= 0 ; j --) if(a[j] == '2')&#123; a[j - 1] += 1; a[j] = '0'; &#125; &#125; return 0;&#125; 12345678910111213# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; for (int i = 0; i &lt; 32; i ++)&#123; bitset&lt;5&gt; b(i); // 头文件 &lt;bitset&gt; cout &lt;&lt; b &lt;&lt; endl; &#125; return 0;&#125;// bitset 容器每个位置存储值只能为0和1// 用在这里正好合适 bitset文档 BASIC 3 字母图形问题描述 1234567利用字母可以组成一些美丽的图形，下面给出了一个例子：ABCDEFGBABCDEFCBABCDEDCBABCDEDCBABC这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。 输入格式 1输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。 输出格式 1输出n行，每个m个字符，为你的图形。 样例输入 15 7 样例输出 12345ABCDEFGBABCDEFCBABCDEDCBABCDEDCBABC 数据规模与约定 11 &lt;= n, m &lt;= 26 问题分析可以直接两层循环直接输出ASCII码 AC代码12345678910111213# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++)&#123; for (int j = 0; j &lt; m; j ++) putchar( abs(j - i) + 65 ); puts(\"\"); &#125; return 0;&#125; BASIC 4 数列特征问题描述 1给出n个数，找出这n个数的最大值，最小值，和。 输入格式 12第一行为整数n，表示数的个数第二行有n个数，为给定的n个数，每个数的绝对值都小于10000。 输出格式 1输出三行，每行一个整数。第一行表示这些数中的最大值，第二行表示这些数中的最小值，第三行表示这些数的和。 样例输入 1251 3 -2 4 5 样例输出 1235-211 数据规模与约定 11 &lt;= n &lt;= 10000 问题分析在读入的过程中判断是否是最小和最大值，并加进总和中 AC代码123456789101112131415# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, x, Min = 10000, Max = -10000, sum = 0; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i ++)&#123; scanf(\"%d\", &amp;x); Min = min(Min, x); Max = max(Max, x); sum += x; &#125; printf(\"%d\\n%d\\n%d\\n\", Max, Min, sum); return 0;&#125; BASIC 5 查找整数问题描述 1给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。 输入格式 123第一行包含一个整数n。第二行包含n个非负整数，为给定的数列，数列中的每个数都不大于10000。第三行包含一个整数a，为待查找的数。 输出格式 1如果a在数列中出现了，输出它第一次出现的位置(位置从1开始编号)，否则输出-1。 样例输入 12361 9 4 8 3 99 样例输出 12 数据规模与约定 11 &lt;= n &lt;= 1000 问题分析读取数组, 然后使用find函数 AC代码123456789101112131415# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, x; int a[1001]; scanf (\"%d\", &amp;n); for (int i = 0; i &lt; n; i ++) scanf(\"%d\", a + i); scanf (\"%d\", &amp;x); int ans = find(a, a + n, x) - a; if( ans != n ) cout &lt;&lt; ans + 1; else puts(\"-1\"); return 0;&#125; 给出n，输出它的前n行。 BASIC 6 杨辉三角形问题描述 1234567杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。下面给出了杨辉三角形的前4行： 1 1 1 1 2 1 1 3 3 1 输入格式 1输入包含一个数n。 输出格式 1输出杨辉三角形的前n行。每一行从这一行的第一个数开始依次输出，中间使用一个空格分隔。请不要在前面输出多余的空格。 样例输入 14 样例输出 123411 11 2 11 3 3 1 数据规模与约定 11 &lt;= n &lt;= 34 问题分析略 AC代码123456789101112131415161718192021# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int a[35]; memset(a, 0, sizeof(a)); a[0] = 1; for (int i = 1; i &lt;= n; i ++)&#123; for (int j = 0; j &lt; i; j ++) printf (\"%d \", a[j]); int temp = 1; for (int j = 1; j &lt;= i + 1; j ++)&#123; temp = a[j] + temp; swap(temp, a[j]); &#125; puts(\"\"); &#125; return 0;&#125; BASIC 7 特殊的数字问题描述 1153是一个非常特殊的数，它等于它的每位数字的立方和，即153=1*1*1+5*5*5+3*3*3。编程求所有满足这种条件的三位十进制数。 输出格式 1按从小到大的顺序输出满足条件的三位十进制数，每个数占一行。 问题分析循环跑一遍，公式都给了，范围是三位数 AC代码1234567891011121314# include &lt;bits/stdc++.h&gt; using namespace std;int main()&#123; int i,a,b,c; for(i = 100; i &lt; 1000; i ++)&#123; a = i /100; // 百位 b = ( i % 100 ) / 10; // 十位 c = i % 10; // 个位 if(i == a * a * a + b * b * b + c * c * c) cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; BASIC 8 回文数问题描述 11221是一个非常特殊的数，它从左边读和从右边读是一样的，编程求所有这样的四位十进制数。 输出格式 1按从小到大的顺序输出满足条件的四位十进制数。 问题分析直接循环找到千位和个位相等，百位和十位相等。 AC代码12345678910# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; for (int i = 1001; i &lt; 10000; i ++)&#123; if( i % 10 == i / 1000 &amp;&amp; i % 100 / 10 == i / 100 % 10) cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; BASIC 9 特殊回文数问题描述 12123321是一个非常特殊的数，它从左边读和从右边读是一样的。输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。 输入格式 1输入一行，包含一个正整数n。 输出格式 1按从小到大的顺序输出满足条件的整数，每个整数占一行。 样例输入 152 样例输出 123899998989989998899 数据规模与约定 11 &lt;= n &lt;= 54 问题分析六位数是回文数，且六个数总和是n。取高三位，总和为n / 2。因此如果为奇数则一定没有解。 AC代码1234567891011121314# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; if( n % 2 != 0 ) for (int i = 1; i &lt; 10; i ++) for (int j = 0; j &lt; 10; j ++) for (int k = 0; k &lt; 10; k ++) if( i + j + k == n / 2) cout &lt;&lt; i &lt;&lt; j &lt;&lt; k &lt;&lt; k &lt;&lt; j &lt;&lt; i &lt;&lt; endl; return 0;&#125; BASIC 10 十进制转十六进制问题描述 123十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F共16个符号，分别表示十进制数的0至15。十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的30在十六进制中是1E。给出一个非负整数，将它表示成十六进制的形式。 输入格式 1输入包含一个非负整数a，表示要转换的数。0&lt;=a&lt;=2147483647 输出格式 1输出这个整数的16进制表示 样例输入 130 样例输出 11E 问题分析这类问题模仿十进制转二进制的过程即可，使用了STL的string AC代码12345678910111213141516171819202122# include &lt;bits/stdc++.h&gt;using namespace std;string Turn(int n, int d)&#123; string ans; if( !n ) puts(\"0\"); while ( n )&#123; int x = n % d; if( x &lt; 10 ) ans += x + 48; else ans += 55 + x; n /= d; &#125; reverse(ans.begin(), ans.end()); return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; Turn(n, 16); return 0;&#125; BASIC 11 十六进制转十进制问题描述 12从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。 样例输入 1FFFF 样例输出 165535 问题分析(FFFF)H =&gt; (65535)D也就是 F * 16 0 + F * 16 1 + F * 16 2 + F * 16 3 = 65535.这里F代表的是数字15需要注意的是不能用int，FFFFFFFF会爆int。 AC代码1234567891011121314151617181920212223242526# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;unsigned int Pow(int d, int p)&#123; unsigned int mul = 1; while ( -- p ) mul *= d; return mul;&#125;unsigned int Turn(string str, int d)&#123; unsigned int sum = 0; for (int i = str.size() - 1; i &gt;= 0; i --) if( str[i] &lt; 57 ) sum += (str[i] - 48) * Pow(d, str.size() - i); else sum += (str[i] - 55) * Pow(d, str.size() - i); return sum;&#125;int main()&#123; string str; cin &gt;&gt; str; cout &lt;&lt; Turn(str, 16); return 0;&#125; BASIC 12 十六进制转八进制问题描述 1给定n个十六进制正整数，输出它们对应的八进制数。 输入格式 12输入的第一行为一个正整数n （1&lt;=n&lt;=10）。接下来n行，每行一个由0~9、大写字母A~F组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。 输出格式 1234输出n行，每行为输入对应的八进制正整数。【注意】输入的十六进制数不会有前导0，比如012A。输出的八进制数也不能有前导0。 样例输入 123239123ABC 样例输出 12714435274 提示先将十六进制数转换成某进制数，再由某进制数转换成八进制。 问题分析很多人第一眼看到这题，十六进制转十进制再转八进制即可，思路同上两题。但这题要注意到的是数据范围，每个十六进制数长度不超过100000。我的做法是转成二进制，而不是十进制。这个对上题的代码需要进行改动。但to_string函数编译不通过手写一个To_string。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# include &lt;bits/stdc++.h&gt;using namespace std;string hexTurnbin(string str)&#123; string bin; for (int i = 0; i &lt; str.size(); i ++)&#123; int hex = str[i] &lt; 65 ? str[i] - 48 : str[i] - 55; string t; while( hex )&#123; t += hex % 2 + 48; hex /= 2; &#125; reverse(t.begin(), t.end()); for (int i = t.size(); i &lt; 4; i ++) bin += '0'; // 二进制补前置0 bin += t; &#125; return bin;&#125;string To_string(int n)&#123; string str; if( n ) while( n )&#123; str += (n % 10 + 48); n /= 10; &#125; else str = \"0\"; reverse(str.begin(), str.end()); return str;&#125;string binTurnoct(string str)&#123; string oct; int M = 1, mul = 0; for (int i = str.size() - 1; i &gt;= 0; i --)&#123; mul += M * (str[i] - 48); M *= 2; if( M == 8 )&#123; M = 1; oct += To_string(mul); // to_string 用于int 转成 string mul = 0; &#125; &#125; if( mul ) oct += To_string(mul); reverse(oct.begin(), oct.end()); return oct;&#125;int main()&#123; int n; cin &gt;&gt; n; while ( n -- )&#123; string str; cin &gt;&gt; str; str = hexTurnbin(str); str = binTurnoct(str); int i = 0; for (; i &lt; str.size(); i ++) if( str[i] != 48 ) break; for (; i &lt; str.size(); i ++) putchar(str[i]); putchar('\\n'); &#125; return 0;&#125; BASIC 13 数列排序问题描述 1给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1&lt;=n&lt;=200 输入格式 12第一行为一个整数n。第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。 输出格式 1输出一行，按从小到大的顺序输出排序后的数列。 样例输入 1258 3 6 4 9 样例输出 13 4 6 8 9 问题分析直接使用algorithm里面的sort函数即可(有兴趣可以自己了解sort实现的方法) AC代码1234567891011121314# include &lt;bits/stdc++.h&gt;using namespace std;int a[201];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) scanf(\"%d\", &amp;a[i]); sort(a, a + n); for(int i = 0; i &lt; n; i ++) printf(\"%d \", a[i]); return 0;&#125; BASIC 14 时间转换问题描述 1给定一个以秒为单位的时间t，要求用“&lt;H&gt;:&lt;M&gt;:&lt;S&gt;”的格式来表示这个时间。&lt;H&gt;表示时间，&lt;M&gt;表示分钟，而&lt;S&gt;表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。 输入格式 1输入只有一行，是一个整数t（0&lt;=t&lt;=86399）。 输出格式 1输出只有一行，是以“&lt;H&gt;:&lt;M&gt;:&lt;S&gt;”的格式所表示的时间，不包括引号。 样例输入 10 样例输出 10:0:0 样例输入 15436 样例输出 11:30:36 问题分析略 AC代码123456789# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; printf(\"%d:%d:%d\", t / 3600 , (t / 60 % 60), t % 60); return 0;&#125; BASIC 15 字符串对比问题描述 123456 给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4中情况之一： 1：两个字符串长度不等。比如 Beijing 和 Hebei 2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing 3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和 BEIjing 4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing 编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。 输入格式 1包括两行，每行都是一个字符串 输出格式 1仅有一个数字，表明这两个字符串的关系编号 样例输入 12BEIjingbeiJing 样例输出 13 问题分析使用transform 函数使string 整个转大写或小写。 AC代码12345678910111213141516# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string str1, str2; cin &gt;&gt; str1 &gt;&gt; str2; if ( str1.size() != str2.size() ) cout &lt;&lt; \"1\"; else if ( str1 == str2 ) cout &lt;&lt; \"2\"; else&#123; transform(str1.begin(), str1.end(), str1.begin(), ::toupper); transform(str2.begin(), str2.end(), str2.begin(), ::toupper); if( str1 == str2 ) cout &lt;&lt; \"3\"; else cout &lt;&lt; \"4\"; &#125; return 0;&#125; BASIC 16 分解质因数 问题描述 1求出区间[a,b]中所有整数的质因数分解。 输入格式 1输入两个整数a，b。 输出格式 1每行输出一个数的分解，形如k=a1*a2*a3...(a1&lt;=a2&lt;=a3...，k也是从小到大的)(具体可看样例) 样例输入 13 10 样例输出 123456783=34=2*25=56=2*37=78=2*2*29=3*310=2*5 提示先筛出所有素数，然后再分解。 数据规模与约定 11 &lt;= n &lt;= 1,000,000 问题分析打出素数表，然后按素数表顺序用 2 3 5 7 9，依次选择。若可以整除，则除以这个素数。 例如 18 = 2， 3， 3。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041# include &lt;bits/stdc++.h&gt;using namespace std;int a, b, k = 0;int p[10001];int P[5000];void init()&#123; memset(p, 0, sizeof(p)); p[0] = p[1] = 1; for (int i = 2; i &lt;= b; i ++) if( !p[i] )&#123; P[k ++] = i; for (int j = 2; i * j &lt;= b; j ++) p[i * j] = 1; &#125; &#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b; init(); for(int i = a; i &lt;= b; i ++)&#123; int j = i, h = 0; printf(\"%d=\", i); if( !p[i] ) &#123; printf(\"%d\\n\", i); continue; &#125; while ( j &gt; 1 )&#123; while ( j % P[h] == 0 )&#123; if( j == P[h] ) cout &lt;&lt; P[h]; else cout &lt;&lt; P[h] &lt;&lt; \"*\"; j /= P[h]; &#125; h ++; &#125; putchar('\\n'); &#125; return 0;&#125; BEGIN 17:矩阵乘法 问题描述12345678给定一个N阶矩阵A，输出A的M次幂（M是非负整数）例如： A = 1 2 3 4 A的2次幂 7 10 15 22 输入格式 12第一行是一个正整数N、M（1&lt;=N&lt;=30, 0&lt;=M&lt;=5），表示矩阵A的阶数和要求的幂数接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值 输出格式 1输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开 样例输入 1232 21 23 4 样例输出 127 1015 22 问题分析直接对矩阵进行乘法运算，但要注意一点的是，数组开int类型会爆。也可以学习矩阵快速幂。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;typedef struct matnode&#123; ll a[31][31]; void reset ()&#123; for (int i = 0; i &lt; n; i ++) a[i][i] = 1; &#125; void print()&#123; for (int i = 0; i &lt; n; i ++)&#123; for (int j = 0; j &lt; n; j ++) printf(\"%lld \", a[i][j]); putchar('\\n'); &#125; &#125;&#125;mat;mat operator * ( mat a, mat b )&#123; // 重载乘法 mat ans; for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; n; j ++)&#123; ans.a[i][j] = 0; for (int k = 0; k &lt; n; k ++) ans.a[i][j] += a.a[i][k] * b.a[k][j]; &#125; return ans;&#125;mat qpow( mat a, int m )&#123; //快速幂 mat ans; ans.reset(); while ( m )&#123; if( m &amp; 1 ) ans = ans * a; a = a * a; m /= 2; &#125; return ans;&#125;int main()&#123; int m; cin &gt;&gt; n &gt;&gt; m; mat a; for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; n; j ++) scanf (\"%lld\", &amp;a.a[i][j]); a = qpow( a, m ); a.print(); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://edxuanlen.tk/tags/蓝桥杯/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"蓝桥杯试题集","slug":"蓝桥杯试题集","date":"2019-02-20T07:17:12.000Z","updated":"2020-02-06T22:40:22.806Z","comments":true,"path":"2019/02/20/蓝桥杯试题集/","link":"","permalink":"https://edxuanlen.tk/2019/02/20/蓝桥杯试题集/","excerpt":"","text":"蓝桥杯试题集_入门训练 蓝桥杯试题集_基础训练 蓝桥杯试题集_算法训练 蓝桥杯试题集_算法提高 蓝桥杯试题集_历届试题","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://edxuanlen.tk/tags/蓝桥杯/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"蓝桥杯试题集_算法训练","slug":"蓝桥杯试题集-算法训练","date":"2019-02-20T07:17:07.000Z","updated":"2020-02-06T22:40:22.805Z","comments":true,"path":"2019/02/20/蓝桥杯试题集-算法训练/","link":"","permalink":"https://edxuanlen.tk/2019/02/20/蓝桥杯试题集-算法训练/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"蓝桥杯试题集_算法提高","slug":"蓝桥杯试题集-算法提高","date":"2019-02-20T07:16:59.000Z","updated":"2020-02-06T22:40:22.805Z","comments":true,"path":"2019/02/20/蓝桥杯试题集-算法提高/","link":"","permalink":"https://edxuanlen.tk/2019/02/20/蓝桥杯试题集-算法提高/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"蓝桥杯试题集_历届试题","slug":"蓝桥杯试题集-历届试题","date":"2019-02-20T07:03:04.000Z","updated":"2020-02-06T22:40:22.804Z","comments":true,"path":"2019/02/20/蓝桥杯试题集-历届试题/","link":"","permalink":"https://edxuanlen.tk/2019/02/20/蓝桥杯试题集-历届试题/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"蓝桥杯试题集_入门训练","slug":"蓝桥杯试题集-入门训练","date":"2019-02-19T18:02:11.000Z","updated":"2020-02-06T22:40:22.803Z","comments":true,"path":"2019/02/20/蓝桥杯试题集-入门训练/","link":"","permalink":"https://edxuanlen.tk/2019/02/20/蓝桥杯试题集-入门训练/","excerpt":"","text":"蓝桥杯入门训练 BEGIN 1:A+B问题 问题描述12输入A、B，输出A+B。说明：在“问题描述”这部分，会给出试题的意思，以及所要求的目标。 输入格式 1234567输入的第一行包括两个整数，由空格分隔，分别表示A、B。说明：“输入格式”是描述在测试你的程序时，所给的输入一定满足的格式。做题时你应该假设所给的输入是一定满足输入格式的要求的，所以你不需要对输入的格式进行检查。多余的格式检查可能会适得其反，使用你的程序错误。在测试的时候，系统会自动将输入数据输入到你的程序中，你不能给任何提示。比如，你在输入的时候提示“请输入A、B”之类的话是不需要的，这些多余的输出会使得你的程序被判定为错误。 输出格式 1234输出一行，包括一个整数，表示A+B的值。说明：“输出格式”是要求你的程序在输出结果的时候必须满足的格式。在输出时，你的程序必须满足这个格式的要求，不能少任何内容，也不能多任何内容。如果你的内容和输出格式要求的不一样，你的程序会被判断为错误，包括你输出了提示信息、中间调试信息、计时或者统计的信息等。 样例输入 123412 45说明：“样例输入”给出了一组满足“输入格式”要求的输入的例子。这里给出的输入只是可能用来测试你的程序的一个输入，在测试的时候，还会有更多的输入用来测试你的程序。 样例输出 12345678910111213141516 57说明：“样例输出”给出了一组满足“输出格式”要求的输出的例子。样例输出中的结果是和样例输入中的是对应的，因此，你可以使用样例的输入输出简单的检查你的程序。要特别指出的是，能够通过样例输入输出的程序并不一定是正确的程序，在测试的时候，会用很多组数据进行测试，而不局限于样例数据。有可能一个程序通过了样例数据，但测试的时候仍只能得0分，可能因为这个程序只在一些类似样例的特例中正确，而不具有通用性，再测试更多数据时会出现错误。比如，对于本题，如果你写一个程序不管输入是什么都输入57，则样例数据是对的，但是测试其他数据，哪怕输入是1和2，这个程序也输出57，则对于其他数据这个程序都不正确。数据规模与约定-10000 &lt;= A, B &lt;= 10000。说明：“数据规模与约定”中给出了试题中主要参数的范围。这个范围对于解题非常重要，不同的数据范围会导致试题需要使用不同的解法来解决。比如本题中给的A、B范围不大，可以使用整型(int)来保存，如果范围更大，超过int的范围，则要考虑其他方法来保存大数。有一些范围在方便的时候是在“问题描述”中直接给的，所以在做题时不仅要看这个范围，还要注意问题描述。 问题分析略 AC代码本题的C++源代码如下： 1234567891011#include &lt;iostream&gt; using namespace std; int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b; return 0;&#125; 本题的C源代码如下： 123456789#include &lt;stdio.h&gt; int main()&#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); printf(\"%d\", a+b); return 0;&#125; 本题的Java源代码如下： 123456789101112import java.util.*; public class Main&#123; public static void main(String args[]) &#123; Scanner sc = new Scanner(System.in); Integer a = sc.nextInt(); Integer b = sc.nextInt(); System.out.println(a + b); &#125;&#125; BEGIN 2: 序列求和 问题描述12求1+2+3+...+n的值。输入包括一个整数n。 1样例输入 1样例输出 问题分析略 AC代码1234567891011#include &lt;iostream&gt; using namespace std; int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b; return 0;&#125; BEGIN 2:序列求和 问题描述1求1+2+3+...+n的值。 输入格式 1输入包括一个整数n。 输出格式 1输出一行，包括一个整数，表示1+2+3+...+n的值。 样例输入 14 样例输出 110 样例输入 1100 样例输出 15050 数据规模与约定 11 &lt;= n &lt;= 1,000,000,000 问题分析数据范围比较大如果累加会超时如下代码: 1while (n) ans += n --; 所以应该使用求和公式 AC代码12345678# include &lt;stdio.h&gt;type long long ll;int main() &#123; ll n; scanf(\"%d\", &amp;n); printf(\"%I64d\", (1 + n) * n / 2); return 0;&#125; BEGIN 3:圆的面积 问题描述1给定圆的半径r，求圆的面积。 输入格式 1输入包含一个整数r，表示圆的半径。 输出格式 12345输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。说明：在本题中，输入是一个整数，但是输出是一个实数。对于实数输出的问题，请一定看清楚实数输出的要求，比如本题中要求保留小数点后7位，则你的程序必须严格的输出7位小数，输出过多或者过少的小数位数都是不行的，都会被认为错误。实数输出的问题如果没有特别说明，舍入都是按四舍五入进行。 样例输入 14 样例输出 150.2654825 数据规模与约定 121 &lt;= r &lt;= 100000本题对精度要求较高，请注意π的值应该取较精确的值。你可以使用常量来表示π，比如PI=3.14159265358979323，也可以使用数学公式来求π，比如PI=atan(1.0)*4。 问题分析使用浮点数计算 AC代码12345678910# include &lt;bits/stdc++.h&gt;using namespace std;double PI=3.14159265358979323;int main()&#123; int r; scanf (\"%d\", &amp;r); printf (\"%.7lf\", PI * r * r); return 0;&#125; BEGIN 4:Fibonacci数列 问题描述12Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式 1输入包含一个整数n。 输出格式 12输出一行，包含一个整数，表示Fn除以10007的余数。说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 样例输入 110 样例输出 155 样例输入 122 样例输出 17704 数据规模与约定 11 &lt;= n &lt;= 1,000,000 问题分析略 AC代码1234567891011121314151617181920# include &lt;bits/stdc++.h&gt;using namespace std;int MOD = 10007;int main()&#123; int n; while (cin &gt;&gt; n)&#123; int a = 1, b = 1; if (n &lt;= 2)&#123; // n &lt;= 2时都是1 cout &lt;&lt; \"1\" &lt;&lt; endl; continue; &#125; while (-- n)&#123; swap(a, b); b = (a + b) % MOD; &#125; cout &lt;&lt; a &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://edxuanlen.tk/tags/蓝桥杯/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"配置apache-tomcat","slug":"配置apache-tomcat","date":"2018-09-22T01:28:13.000Z","updated":"2020-02-06T22:40:22.808Z","comments":true,"path":"2018/09/22/配置apache-tomcat/","link":"","permalink":"https://edxuanlen.tk/2018/09/22/配置apache-tomcat/","excerpt":"","text":"官网下载然后解压 问题1Cannot find /usr/local/apache-tomcat-6.0.30//bin/setclasspath.shThis file is needed to run this program 问题2运行setclasspath.sh报错 找不到jdk方法：编辑setclasspath.sh 在文件开始添加jdk的位置 CATALINA_HOME=/usr/local/apache-tomcat/JAVA_HOME= JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64这两个加在文件前面 目录一定要正确 java -verbose 可以查看jdk位置/usr/lib/jvm/java-11-openjdk-amd64/lib/modules","categories":[],"tags":[],"keywords":[]},{"title":"python Django初识","slug":"python-Django初识","date":"2018-09-18T09:53:35.000Z","updated":"2020-02-06T22:40:22.777Z","comments":true,"path":"2018/09/18/python-Django初识/","link":"","permalink":"https://edxuanlen.tk/2018/09/18/python-Django初识/","excerpt":"","text":"基本环境Ubuntu18 12345678sudo apt-get updatesudo apt-get -y upgrade更新安装好的系统信息sudo pip install virtualenv 安装虚拟环境ip a查看当前虚拟机的ip","categories":[{"name":"Python3","slug":"Python3","permalink":"https://edxuanlen.tk/categories/Python3/"}],"tags":[{"name":"python3项目","slug":"python3项目","permalink":"https://edxuanlen.tk/tags/python3项目/"}],"keywords":[{"name":"Python3","slug":"Python3","permalink":"https://edxuanlen.tk/categories/Python3/"}]},{"title":"Python文件处理","slug":"Python文件处理","date":"2018-09-10T00:23:03.000Z","updated":"2020-02-06T22:40:22.755Z","comments":true,"path":"2018/09/10/Python文件处理/","link":"","permalink":"https://edxuanlen.tk/2018/09/10/Python文件处理/","excerpt":"","text":"题目 任一个英文的纯文本文件，统计其中的单词出现的个数。 1234567891011121314151617181920212223import ref = open(&apos;words.txt&apos;)words_dict = &#123;&#125;List = []for line in f : # for i in line: E = re.findall(r&apos;[^a-zA-Z]+&apos;, line) for j in E: line = line.replace( j , &apos; &apos;) List = line.split() for j in List: if j not in words_dict: words_dict[j] = 1 else: words_dict[j] = words_dict[j] + 1print(words_dict)words_dict = sorted ( words_dict.items() ,key=lambda item: item[1] )print(words_dict)# for i in words_dict:# print (i , words_dict[i] )","categories":[{"name":"Python3","slug":"Python3","permalink":"https://edxuanlen.tk/categories/Python3/"}],"tags":[{"name":"python3小练手","slug":"python3小练手","permalink":"https://edxuanlen.tk/tags/python3小练手/"}],"keywords":[{"name":"Python3","slug":"Python3","permalink":"https://edxuanlen.tk/categories/Python3/"}]},{"title":"redis配置与使用","slug":"redis配置与使用","date":"2018-09-05T02:36:23.000Z","updated":"2020-02-06T22:40:22.779Z","comments":true,"path":"2018/09/05/redis配置与使用/","link":"","permalink":"https://edxuanlen.tk/2018/09/05/redis配置与使用/","excerpt":"","text":"下载安装配置担心MYSQL开着会影响到redis 所以先检查和关闭mysql 12service mysql statusservice mysql stop 然后下载redis 到官网下载也行 ， 用wget也行。 12345678910111213wget http://download.redis.io/releases/redis-4.0.10.tar.gztar -zxvf redis-4.0.10.tar.gzcd redis-4.0.10make testcd srcmake installcd ..mkdir etcmkdir binmv redis.conf etc/cd srcmv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-sentinel redis-server redis-trib.rb ../bin./redis-server 这时候会看到一些aboutctrl + c 出来， 12cd./redis-c 这时候会报错Could not connect to Redis at 127.0.0.1:6379: Connection refusedCould not connect to Redis at 127.0.0.1:6379: Connection refused修改一下配置文件具体目录find找一下把daemonize配置项改为yes 12redis-server /home/edxuanlen/redis-4.0.10/etc/redis.confredis-cli 然后就可以连接了 附录：配置信息daemonize 如果需要在后台运行，把该项改为yespidfile 配置多个pid的地址 默认在/var/run/redis. pidbind 绑定ip，设置后只接受来自该ip的请求port 监听端口，默认是6379loglevel 分为4个等级：debug verbose notice warninglogfile 用于配置log文件地址databases 设置数据库个数，默认使用的数据库为0save 设置redis进行数据库镜像的频率。rdbcompression 在进行镜像备份时，是否进行压缩dbfilename 镜像备份文件的文件名Dir 数据库镜像备份的文件放置路径Slaveof 设置数据库为其他数据库的从数据库Masterauth 主数据库连接需要的密码验证Requriepass 设置 登陆时需要使用密码Maxclients 限制同时使用的客户数量Maxmemory 设置redis能够使用的最大内存Appendonly 开启append only模式Appendfsync 设置对appendonly. aof文件同步的频率（对数据进行备份的第二种方式）vm-enabled 是否开启虚拟内存支持 （vm开头的参数都是配置虚拟内存的）vm-swap-file 设置虚拟内存的交换文件路径vm-max-memory 设置redis使用的最大物理内存大小vm-page-size 设置虚拟内存的页大小vm-pages 设置交换文件的总的page数量vm-max-threads 设置VM IO同时使用的线程数量Glueoutputbuf 把小的输出缓存存放在一起hash-max-zipmap-entries 设置hash的临界值Activerehashing 重新hash redis中的list#题目： 做为 Apple Store App 独立开发者，你要搞限时促销，为你的应用生成激活码（或者优惠券），使用 Python 如何生成 200 个激活码（或者优惠券）？ 将 0001 题生成的 200 个激活码（或者优惠券）保存到 Redis 非关系型数据库中。 http://www.runoob.com/redis/redis-lists.html使用LPUSH将数据插入到名为 Code的列表当中 123456789101112131415161718192021# coding : utf-8import redisimport randomr = redis.Redis(host=&apos;127.0.0.1&apos;,port=6379,db=0)list = []for i in range (65,91): list.append(str(chr(i)))for i in range (97,123): list.append(str(chr(i)))for i in range (10): list.append(str(i))# file = open(&apos;code.txt&apos;,&apos;w&apos;)for i in range (200): Code = &apos;&apos; for j in range (16): Code += random.choice(list) if (j + 1) % 4 == 0 and j != 15: Code = Code + &apos;-&apos; r.lpush(&apos;Code&apos;, Code )","categories":[{"name":"Python3","slug":"Python3","permalink":"https://edxuanlen.tk/categories/Python3/"}],"tags":[{"name":"python3小练手","slug":"python3小练手","permalink":"https://edxuanlen.tk/tags/python3小练手/"}],"keywords":[{"name":"Python3","slug":"Python3","permalink":"https://edxuanlen.tk/categories/Python3/"}]},{"title":"PyMySQL初识","slug":"PyMySQL初识","date":"2018-09-03T14:53:15.000Z","updated":"2020-02-06T22:40:22.754Z","comments":true,"path":"2018/09/03/PyMySQL初识/","link":"","permalink":"https://edxuanlen.tk/2018/09/03/PyMySQL初识/","excerpt":"","text":"先用pip 下载PyMySQL的库然后就是mysql 的配置然后是sql语句的使用了解MySQL的游标含义使用pymysql对MySQL进行操作 坑： ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2)不能直接输入mysql连接官网有很全的安装指南https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/#apt-repo-fresh-install 安装后登录的时候输入mysql -h -uroot -p&lt;密码&gt;记得 -h和-p后面都不能加空格如 mysql -h127.0.0.1 -uroot -p88888888导出问题（https://stackoverflow.com/questions/34102562/mysql-error-1290-hy000-secure-file-priv-option） show variables like ‘%secure%’;找出secure_file_priv的目录，输出到该目录下即可 题目：做为 Apple Store App 独立开发者，你要搞限时促销，为你的应用生成激活码（或者优惠券），使用 Python 如何生成 200 个激活码（或者优惠券）？并将其保存到MySQL关系型数据库中。代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import randomimport pymysql## 创建新的数据库con = pymysql.connect(host=&apos;127.0.0.1&apos;, user=&apos;root&apos;, passwd=&apos;88609723&apos;)cursor = con.cursor() # 获取游标sql = &apos;DROP DATABASE Code&apos;cursor.execute(sql)sql = &apos;CREATE DATABASE Code&apos;cursor.execute(sql)sql = &apos;USE Code&apos;cursor.execute(sql)sql = &apos;CREATE TABLE Code(Code_id int NOT NULL,Code VARCHAR(100) NOT NULL)&apos;cursor.execute(sql)# 输入文件# file = open(&apos;code.txt&apos;,&apos;w&apos;)# for j in range(200):# Code = &apos;&apos;# Code = Code + str(j + 1) + &apos;: &apos;# for i in range(16):# f = random.randint(0,2) # randint 跟range范围不同# if f == 0:# Code = Code + chr(random.randint(48,57))# if f == 1:# Code = Code + chr(random.randint(65,90))# if f == 2:# Code = Code + chr(random.randint(97,122))# if (i + 1) % 4 == 0 and i != 15:# Code = Code + &apos;-&apos;# Code = Code + &apos;\\n&apos;# file.write(Code)for j in range(200): Code = &apos;&apos; for i in range(16): f = random.randint(0,2) if f == 0: Code = Code + chr(random.randint(48,57)) if f == 1: Code = Code + chr(random.randint(65,90)) if f == 2: Code = Code + chr(random.randint(97,122)) if (i + 1) % 4 == 0 and i != 15: Code = Code + &apos;-&apos; sql = &apos;INSERT INTO Code(Code_id,Code) VALUES ( &quot;%d&quot;,&quot;%s&quot;)&apos; %((j+1),Code) cursor.execute(sql)sql = &apos; SELECT * FROM Code INTO OUTFILE &quot;/var/lib/mysql-files/Code.txt&quot; &apos;cursor.execute(sql)# 关闭连接，释放资源cursor.close()con.commit()con.close()","categories":[{"name":"Python3","slug":"Python3","permalink":"https://edxuanlen.tk/categories/Python3/"}],"tags":[{"name":"python3小练手","slug":"python3小练手","permalink":"https://edxuanlen.tk/tags/python3小练手/"}],"keywords":[{"name":"Python3","slug":"Python3","permalink":"https://edxuanlen.tk/categories/Python3/"}]},{"title":"Python3 图像的基本处理","slug":"Python3-PIL图像处理","date":"2018-09-03T02:44:02.000Z","updated":"2020-02-06T22:40:22.754Z","comments":true,"path":"2018/09/03/Python3-PIL图像处理/","link":"","permalink":"https://edxuanlen.tk/2018/09/03/Python3-PIL图像处理/","excerpt":"","text":"python3 图像的基本处理图像的大小12jpg = Image.open(&quot;**.jpg&quot;)x , y = jpg.size 此时， xy分别为图像的高和宽 官方文档如下：https://pillow.readthedocs.io/en/4.0.x/reference/ImageDraw.html 12345678910from PIL import Image, ImageDraw , ImageFontjpg = Image.open(&quot;old.jpg&quot;)draw = ImageDraw.Draw(jpg)x , y = jpg.sizeprint (x,y)font = ImageFont.truetype(&apos;Ubuntu-RI.ttf&apos;, 40)draw.text((250 , 20), &quot;中文？&quot;, &quot;red&quot; , font = font )# jpg.save(&quot;old.jpg&quot;)jpg.show() 题目：将你的 QQ 头像（或者微博头像）右上角加上红色的数字，类似于微信未读信息数量那种提示效果。 类似于图中效果 代码：12345678910111213from PIL import Image, ImageDraw , ImageFontjpg = Image.open(\"new.jpg\")#draw = ImageDraw.Draw(jpg)x , y = jpg.sizeprint (x,y)# draw.test( (10, y - 40) , \"4\" , \"red\" , font = 'LiberationSans-Regular.ttf')font = ImageFont.truetype('Ubuntu-RI.ttf', 40)draw.text((250 , 20), \"中文？\", \"red\" , font = font )jpg.save(\"new.jpg\")jpg.show() 效果","categories":[{"name":"Python3","slug":"Python3","permalink":"https://edxuanlen.tk/categories/Python3/"}],"tags":[{"name":"python3小练手","slug":"python3小练手","permalink":"https://edxuanlen.tk/tags/python3小练手/"}],"keywords":[{"name":"Python3","slug":"Python3","permalink":"https://edxuanlen.tk/categories/Python3/"}]},{"title":"补蓝桥杯国赛","slug":"补蓝桥杯国赛","date":"2018-09-03T00:00:57.000Z","updated":"2020-02-06T22:40:22.806Z","comments":true,"path":"2018/09/03/补蓝桥杯国赛/","link":"","permalink":"https://edxuanlen.tk/2018/09/03/补蓝桥杯国赛/","excerpt":"","text":"时间:2018年5月地点：首都经济贸易大学事件：第九届蓝桥杯国赛 换零钞x星球的钞票的面额只有：100元，5元，2元，1元，共4种。小明去x星旅游，他手里只有2张100元的x星币，太不方便，恰好路过x星银行就去换零钱。小明有点强迫症，他坚持要求200元换出的零钞中2元的张数刚好是1元的张数的10倍，剩下的当然都是5元面额的。银行的工作人员有点为难，你能帮助算出：在满足小明要求的前提下，最少要换给他多少张钞票吗？（5元，2元，1元面额的必须都有，不能是0） 分析这个题目手算都可以算出来，编程的话 也行， 像我懒得算直接写个循环给他跑一下就行了。 题解123456789101112131415# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int $1 , $2 , $5; for ($1 = 5; $1 &lt; 200; $1 = $1 + 5)&#123; $2 = 10 * $1; if((200 - $1 - $2 * 2) % 5 == 0)&#123; $5 = (200 - $1 - $2 * 2) / 5; break; &#125; &#125; cout &lt;&lt; $1 + $2 + $5 &lt;&lt; endl; return 0;&#125; 答案 ： 74 激光样式x星球的盛大节日为增加气氛，用30台机光器一字排开，向太空中打出光柱。安装调试的时候才发现，不知什么原因，相邻的两台激光器不能同时打开！国王很想知道，在目前这种bug存在的情况下，一共能打出多少种激光效果？显然，如果只有3台机器，一共可以成5种样式，即：全都关上（sorry, 此时无声胜有声，这也算一种）开一台，共3种开两台，只1种30台就不好算了，国王只好请你帮忙了。要求提交一个整数，表示30台激光器能形成的样式种数。 分析这道题一开始拿上手，好的写个dfs完了，怎么写来着 写了两次， 不熟啊， bfs比较熟，但怎么写。。。卡了好久， 要不先写后面的吧瞅了眼格雷码 。。 题目难度是有个梯度的吧 哇，我不会卡在这么简单的第二题吧然后就开始列出数据找规律了(我也不知道我怎么就觉得会有规律)估计也是到了绝境 好的，出来了 激动的一匹！｀｀｀台数 开的样式 1 2 2 3 3 5 4 8 5 13 ｀｀｀这是个什么？ 看着它总觉得特别亲切！ 哈哈哈 对的 就是个斐波那契数列。 那就是求fib的第 (30 + 2) 项的值就行了 （因为一台是从第三项开始） 题解123456789# include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a = 1, b = 1; for (int i= 0; i &lt; 30 ; i ++) swap(a , b) , a = a + b; cout &lt;&lt; a &lt;&lt; endl; return 0;&#125; 答案 ：2178309 当然 dfs 也是可以的: 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int cnt = 0;void dfs(int t,bool status)&#123; if( t == 30)&#123; cnt++; return; &#125; if(status==0)&#123; dfs( t + 1 , 1); dfs( t + 1 , 0); &#125; else dfs( t + 1 , 0);&#125;int main()&#123; dfs(0 , 0); cout &lt;&lt; cnt; return 0;&#125; 格雷码格雷码是以n位的二进制来表示数。与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。首尾两个数字也要求只有1位之差。有很多算法来生成格雷码。以下是较常见的一种：从编码全0开始生成。当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0）当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。用这个规则产生的4位格雷码序列如下：0000000100110010011001110101010011001101111111101010101110011000以下是实现代码，仔细分析其中逻辑，并填写划线部分缺少的代码。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt; void show(int a,int n) &#123; int i; int msk = 1; for(i=0; i&lt;n-1; i++) msk = msk &lt;&lt; 1; for(i=0; i&lt;n; i++)&#123; printf((a &amp; msk)? \"1\" : \"0\"); msk = msk &gt;&gt; 1; &#125; printf(\"\\n\"); &#125; void f(int n) &#123; int i; int num = 1; for(i=0; i&lt;n; i++) num = num&lt;&lt;1; int a = 0; for(i=0; i&lt;num; i++)&#123; show(a,n); if(i%2==0)&#123; a = a ^ 1; &#125; else&#123; a = _________________________ ; //填空 &#125; &#125; &#125; int main() &#123; f(4); return 0; &#125; 分析分析不来啊， 没见过 ， 直接上 ， 一个空 ， 我感觉得几行啊想想几行应该怎么合成一行呢 ， 三目运算！可是一个也不够用啊 ， 那就用几个呗23333 丧心病狂的我 就这样交了上去（还以为是对的，就是想让我们用三目运算符）见识短浅啊 后来问郭佬才知道是 lowbit（树状数组）的解法去解具体lowbit 是什么 ， 详见百度吧https://zh.wikipedia.org/wiki/树状数组 1234int lowbit(int x)&#123; return x&amp;(-x);&#125; 答案：a^((a&amp;(-a))&lt;&lt;1)","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"C/C++题目","slug":"C-C-题目","permalink":"https://edxuanlen.tk/tags/C-C-题目/"},{"name":"经历","slug":"经历","permalink":"https://edxuanlen.tk/tags/经历/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"python爬取hdu题库","slug":"python爬取hdu题库","date":"2018-09-02T23:48:27.000Z","updated":"2020-02-06T22:40:22.777Z","comments":true,"path":"2018/09/03/python爬取hdu题库/","link":"","permalink":"https://edxuanlen.tk/2018/09/03/python爬取hdu题库/","excerpt":"","text":"这里涉及到很多的点，比如python利用正则表达式爬下来之后怎么把html标签去除，还有伪装浏览器访问，错误处理。 1234567891011121314151617181920212223242526272829303132import webbrowserimport urllibimport requestsimport redef getHtml(url): page = urllib.request.urlopen(url) html = page.read() unicodehtml = html.decode(\"gbk\") ## 转化为gbk格式 return unicodehtmldef zhenghe(str1,id,imgre): html=getHtml( str1+id ) return re.findall(imgre,html)headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/51.0.2704.63 Safari/537.36'&#125; ## 改request的头 模拟浏览器num =1000;Url = \"http://acm.hdu.edu.cn/showproblem.php?pid=\"reg = r'&lt;div class=panel_content&gt;.*?[\\s\\S]*?&lt;/div&gt;' ## 正则表达式imgre=re.compile(reg)while num&lt;=6275: list = zhenghe(Url,str(num),imgre) t = open(\"hdu题库\\hdu%s.txt\"%num,\"w\") for i in list: dr = re.compile(r'&lt;[^&gt;]+&gt;',re.S) dd = dr.sub('',i) ## 上面两行时用来去除html标签 t.write(dd) ## 写入 t.write(\"\\n\") t.close() num=num+1 然而有一些问题 。就是转化gbk格式失败会终止程序，因此要写个错误处理 123456789101112131415def getHtml(url): page = urllib.request.urlopen(url) html = page.read() try: unicodehtml = html.decode(\"gbk\") except: print(\"%s had not been install\\n\"%url) return \"a\" ## 错误时return一个a return unicodehtmlwhile num&lt;=6275: list = zhenghe(Url,str(num),imgre) if(list==\"a\"): ## 当发生错误时不写入 continue t = open(\"hdu题库\\hdu%s.txt\"%num,\"w\") 到了这一步其实基本都已经实现了，但是还是不太完美，输入输出没有分开，而且也没有标题： 这时候详化一下正则表达式就可以了，最终版本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import webbrowserimport urllibimport requestsimport reimport codecsdef getHtml(url): page = urllib.request.urlopen(url) html = page.read() try: unicodehtml = html.decode(\"gbk\") except: print(\"%s had not been install\\n\"%url) return \"a\" return unicodehtmldef zhenghe(str1,id,imgre): html=getHtml( str1+id ) return re.findall(imgre,html)headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) ' 'Chrome/51.0.2704.63 Safari/537.36'&#125;num =1013;Url = \"http://acm.hdu.edu.cn/showproblem.php?pid=\"reg = &#123;&#125;reg[0] = r\"&lt;td align=center&gt;&lt;h1 style='color:#1A5CC8'&gt;.*?[\\s\\S]&lt;/h1&gt;\"reg[1] = r\"&lt;br&gt;&lt;br&gt;&lt;div class=panel_title align=left&gt;.*?[\\s\\S]*?&lt;/div&gt; &lt;div class=panel_content&gt;\"reg[2] = r\"&lt;/div&gt; &lt;div class=panel_content&gt;.*?[\\s\\S]*?&lt;br&gt;&lt;/div&gt;&lt;div class=panel_bottom&gt;\"reg[3] = r'Sample Input&lt;/div&gt;&lt;div class=panel_content&gt;&lt;pre&gt;&lt;div style=\"font-family:Courier New,Courier,monospace;\"&gt;.*?[\\s\\S]*?&lt;/div&gt;'reg[4] = r'Sample Output&lt;/div&gt;&lt;div class=panel_content&gt;&lt;pre&gt;&lt;div style=\"font-family:Courier New,Courier,monospace;\"&gt;.*?[\\s\\S]*?&lt;/div&gt;'while num&lt;=1013: t = open(\"hdu题库\\hdu%s.txt\"%num,\"a\") for j in range (0,5): imgre=re.compile(reg[j]) list = zhenghe(Url,str(num),imgre) if(list==\"a\"): continue for i in list: dr = re.compile(r'&lt;[^&gt;]+&gt;',re.S) dd = dr.sub('',i) dr = re.compile(r'Input',re.S) dd = dr.sub('Input\\n',dd) dr = re.compile(r'Output',re.S) dd = dr.sub('Output\\n',dd) t.write(dd) t.write(\"\\n\\n\") t.close() num=num+1","categories":[{"name":"Python","slug":"Python","permalink":"https://edxuanlen.tk/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://edxuanlen.tk/tags/Python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"https://edxuanlen.tk/categories/Python/"}]},{"title":"Ubuntu-18 之旅","slug":"Ubuntu-18-之旅","date":"2018-09-02T11:35:40.000Z","updated":"2020-02-06T22:40:22.772Z","comments":true,"path":"2018/09/02/Ubuntu-18-之旅/","link":"","permalink":"https://edxuanlen.tk/2018/09/02/Ubuntu-18-之旅/","excerpt":"","text":"Ubuntu的安装如果在安装过程中最后提醒grub安装失败，是因为开机启动项安装失败，会导致无法进入系统我一开始比较丧心病狂，直接把整块硬盘格式化后装Ubuntu就可以了比较好的的处理方法如下==https://blog.csdn.net/qq_40883132/article/details/80538539 HEXO 配置网上有很多教程想看的可以百度一下这里我是想说，把整个文件夹保存下来才是王道，直接可以使用git config –global user.email “you@example.com“git config –global user.name “Your Name”配置下信息若出现报错 ：修改： themes/BlueLake (修改的内容, 未跟踪的内容) 修改尚未加入提交git statusgit rm -f –cached themes/BlueLake/git add themes/BlueLake/git add .git commit -m “”如果是要建立分支 12345git checkout -b hexo //创建并切换git remote rm origin //清除当前设备git remote add origin git@github.com:edxuanlen/github.io.git//添加远程设备git remote -v //查看当前设备git push origin hexo 网易云抛弃了kali再回到Ubuntu的怀抱，就是因为kali蓝牙配置搞砸了，听歌都不爽（因为想连蓝牙音箱）所以emmm 网易云可以直接到官网下载ubuntu版的，http://d1.music.126.net/dmusic/netease-cloud-music_1.1.0_amd64_ubuntu.deb下载完双击可以直接安装无法打开的问题自行百度sudo netease-cloud-music能正常使用 方法一用root权限修改文件/usr/share/applications/netease-cloud-music.desktop比如：sudo gedit /usr/share/applications/netease-cloud-music.desktop –no-sandbox2. 方法二sudo gedit /etc/sudoers修改/etc/sudoers文件，加一行：YOURNAME ALL = NOPASSWD: /usr/bin/netease-cloud-musicYOURNAME为你登录的用户名。sudo gedit /usr/share/applications/netease-cloud-music.desktop 修改Exec=netease-cloud-music %U 为 Exec=sudo netease-cloud-music %U,这样点击网易云音乐图标就是以管理员权限启动的了，且不用输入密码。 网易云无法调整界面大小搜索.netease-cloud-music（注意前面有个”.”）然后把搜索到的文件夹全都删掉或者删除了~/.cache/netease-cloud-music 目录 CLion,IdeaJ和Pycharm 三件套==官网都有直接，学生可以通过学校邮箱申请免费使用，获得一个Activate code。 打开这三个软件，运行.sh文件，选择 Activate code，输入code 给Pycharm添加桌面快捷键sudo gedit /usr/share/applications/Pycharm.desktop编辑 123456789[Desktop Entry]Type=ApplicationName=PycharmGenericName=Pycharm3Comment=Pycharm3:The Python IDEExec=sh **/**.sh （sh的完整路径）Icon= （图标所在的完整路径）Terminal=pycharmCategories=Pycharm; Mysql坑： ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2)不能直接输入mysql连接官网有很全的安装指南https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/#apt-repo-fresh-install 安装后登录的时候输入mysql -h -uroot -p&lt;密码&gt;记得 -h和-p后面都不能加空格如 mysql -h127.0.0.1 -uroot -p88888888导出问题（https://stackoverflow.com/questions/34102562/mysql-error-1290-hy000-secure-file-priv-option） show variables like ‘%secure%’;找出secure_file_priv的目录，输出到该目录下即可 还原某些桌面设置dconf reset -f / 解压zip乱码unzip -O cp936 xxxx.zip","categories":[{"name":"系统","slug":"系统","permalink":"https://edxuanlen.tk/categories/系统/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://edxuanlen.tk/tags/Ubuntu/"}],"keywords":[{"name":"系统","slug":"系统","permalink":"https://edxuanlen.tk/categories/系统/"}]},{"title":"JS","slug":"JS","date":"2018-04-27T06:29:52.000Z","updated":"2020-02-06T22:40:22.752Z","comments":true,"path":"2018/04/27/JS/","link":"","permalink":"https://edxuanlen.tk/2018/04/27/JS/","excerpt":"","text":"内部的script1&lt;script type=\"text/javascript\"&gt;&lt;/script&gt; 外部的scriptscript标签内用arc 作用","categories":[{"name":"JS","slug":"JS","permalink":"https://edxuanlen.tk/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://edxuanlen.tk/tags/JS/"}],"keywords":[{"name":"JS","slug":"JS","permalink":"https://edxuanlen.tk/categories/JS/"}]},{"title":"string 的使用","slug":"string-的使用","date":"2018-04-14T05:37:39.000Z","updated":"2020-02-06T22:40:22.780Z","comments":true,"path":"2018/04/14/string-的使用/","link":"","permalink":"https://edxuanlen.tk/2018/04/14/string-的使用/","excerpt":"","text":"12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; char a[101]; while(gets(a))&#123; string b=a; int i=0; transform(b.begin(),b.end(),b.begin(),::tolower); if(!b.find(\"lovelive\")) printf(\"yes\\n\"); else printf(\"no\\n\"); &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://edxuanlen.tk/tags/STL/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"解决写wyh的矩阵出现内存占用超过限制的问题","slug":"解决写wyh的矩阵出现内存占用超过限制的问题","date":"2018-04-06T08:58:13.000Z","updated":"2020-02-06T22:40:22.807Z","comments":true,"path":"2018/04/06/解决写wyh的矩阵出现内存占用超过限制的问题/","link":"","permalink":"https://edxuanlen.tk/2018/04/06/解决写wyh的矩阵出现内存占用超过限制的问题/","excerpt":"","text":"原题链接题目如下：给你一个nn矩阵，按照顺序填入1到nn的数，例如n=5，该矩阵如下1 2 3 4 56 7 8 9 1011 12 13 14 1516 17 18 19 2021 22 23 24 25现在让你连接相邻两条边的中点，然后只保留他们围成封闭图形区域的数字，那么这个矩阵变为 3 7 8 911 12 13 14 15 17 18 19 23 现在你们涵哥让你求变化后的矩阵的所有元素的和为多少 内存超过限制的代码: 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;//数字using namespace std;typedef long long ll;int a[9000][9000];int main()&#123; int n; scanf(\"%d\",&amp;n); while(n--)&#123; int num=0,m; scanf(\"%d\",&amp;m); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++) a[i][j]=++num; int l=(m+1)/2-1; ll sum=0; for(int i=0;i&lt;m;i++) for(int j=abs(l-i);j&lt;m-abs(i-l);j++) sum+=a[i][j]; printf(\"%lld\\n\",sum); &#125; return 0;&#125; 占用内存262145K题目对空间的限制是262144K，所以是没跑完的。几次修改无果。。放弃了二维数组的做法AC代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;//数字 using namespace std;typedef long long ll;int main()&#123; int n; scanf(\"%d\",&amp;n); while(n--)&#123; int num=0,m; scanf(\"%d\",&amp;m); int l=(m+1)/2-1; int h=l+1; ll sum=0; for(int i=0;i&lt;m;i++)&#123; if(i&lt;=l)&#123; if(i) h=h+(m-1); for(int j=h;j&lt;h+2*(l-abs(i-l))+1;j++) sum+=j; &#125; else &#123; if(i) h=h+(m+1); for(int j=h;j&lt;h+2*(l-abs(i-l))+1;j++) sum+=j; &#125; &#125; printf(\"%lld\\n\",sum);// // int availmb;// int totalmb;// // MEMORYSTATUS memstatus; // // GlobalMemoryStatus(&amp;memstatus); // // availmb = memstatus.dwAvailPhys/1024/1024; //可用物理内存总量// totalmb = memstatus.dwTotalPhys/1024/1024; //物理内存总量// printf(\"可用内存为:%d MB，物理内存总量:%d MB\\n\",availmb,totalmb); &#125; return 0;&#125; 占用内存352K注释中的代码可以查看当前运行使用的内存大小！！！","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"C/C++题目","slug":"C-C-题目","permalink":"https://edxuanlen.tk/tags/C-C-题目/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"乘积尾零数目","slug":"乘积尾零数目","date":"2018-04-05T17:20:00.000Z","updated":"2020-02-06T22:40:22.787Z","comments":true,"path":"2018/04/06/乘积尾零数目/","link":"","permalink":"https://edxuanlen.tk/2018/04/06/乘积尾零数目/","excerpt":"","text":"原题链接题目描述wyh学长十分钟爱数字‘7’，他想知道每一个数字中有多少个数字‘7’ 输入描述:输入第一行一个整数T(1&lt;=T&lt;=10)接下来有T组测试数据，对于每组测试数据，输入一个整数n(1&lt;=n&lt;=10000000000)输出描述:对于每组测试数据，输出对应答案示例1输入21234567123456输出10 思路这道题第一感觉就是求5和2最多组合个数，因为是从小到大递增，因子中2的个数一定永远比5的个数多所以就是求5的个数即可；一开始我是先求了5的个数，没多想，只除了5就输出，结果一直是WA的，后来才发现错在哪，5的n次方中因子会有n个5，比如25有两个5，125有三个5。。。所以就有了下面代码的思路，i&lt;13是来自于我对数据范围100亿以内最大的5的n次方求解得到n最高为12；即512(=244140625)&lt;100亿&lt;513。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; int n; int flag=0; scanf(\"%d\",&amp;n); while(n--)&#123; ll num; int sum=0; scanf(\"%lld\",&amp;num); for(int i=1;i&lt;13;i++) sum+=num/pow(5,i); printf(\"%d\\n\",sum); &#125; return 0;&#125; AC by....njfu-edxuanlen","categories":[],"tags":[],"keywords":[]},{"title":"第九届蓝桥杯试题、答案以及比赛经历","slug":"第九届蓝桥杯试题、答案以及比赛经历","date":"2018-04-05T07:04:32.000Z","updated":"2020-02-06T22:40:22.800Z","comments":true,"path":"2018/04/05/第九届蓝桥杯试题、答案以及比赛经历/","link":"","permalink":"https://edxuanlen.tk/2018/04/05/第九届蓝桥杯试题、答案以及比赛经历/","excerpt":"","text":"时间:2018年愚人节地点：南京航空航天大学(江宁校区)事件：第九届蓝桥杯省赛 废话不多说，直接上题目： 第一题： 第几天(满分5分)题目描述： 2000年的1月1日，是那一年的第1天。那么，2000年的5月4日，是那一年的第几天？注意：需要提交的是一个整数，不要填写任何多余内容。 个人感受： 很简单的一道题，学习了各位大佬的比赛经验，这种题目也不去考虑编程了，不仅要判断几月是几天还要去思考是否闰年 题目答案：答案：125方法: 日历/excel例如：用excel快速求解，第一个单元格输入2000/1/1，第二个单元格输入2000/5/4，然后在第三个单元格生成，第二个单元格减去第一个单元格的值哦，对了 ，算完是124，还要加上1！5s出答案。 第二题： 明码(满分7分)题目描述： 汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。16点阵的字库把每个汉字看成是16x16个像素信息。并把这些信息记录在字节中。一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。把每个字节转为2进制表示，1表示墨迹，0表示底色。每行2个字节，一共16行，布局是： 第1字节，第2字节 第3字节，第4字节 …. 第31字节, 第32字节这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。这段信息是（一共10个汉字）：4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 016 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 164 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 00 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 44 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 6416 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -1280 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 02 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 01 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 00 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0注意：需要提交的是一个整数，不要填写任何多余内容。 个人感受： 很有趣的一道题目，一开始有点懵圈，这么多的数据，想到的就是转化为八位二进制，然后两个一组输出 然后换行，最后从一堆二进制中看出 题目：九的九次方等于多少？(一开始我还以为时输入转化得到的话，结果看到了最后一个翻译出来是问号==emmm，又看了下题目最后一行，整数！emmmm)PS:负数直接用128相加一下就差不多能看了. 题目答案：387420489代码一 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;void print(int x)&#123; int a[8]=&#123;0&#125;; if(x&lt;0) x+=128; for(int i=7;i&gt;=0;i--)&#123; a[i]=x%2; x/=2; &#125; for(int i=0;i&lt;8;i++) if(a[i]) cout&lt;&lt;\"*\"; else cout&lt;&lt;\" \";&#125;int main()&#123; for(int i=0;i&lt;10;i++)&#123; for(int i=0;i&lt;16;i++)&#123; //由题目很容易可以看出 两个八位二进制一行 int x,y; scanf(\"%d%d\",&amp;x,&amp;y); print(x); print(y); cout&lt;&lt;endl; &#125; cout&lt;&lt;endl&lt;&lt;endl; &#125; return 0; &#125; 代码二有大佬用位运算写:位运算不不用考虑负数的问题..直接按位进行运算 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;void print(int x)&#123; for(int i=7;i&gt;=0;i--)&#123; // x=4 100 &amp; 10000000 = 0 // 100 &amp; 1000000 = 0 // 100 &amp; 100000 = 0 // 100 &amp; 10000 = 0 // 100 &amp; 1000 = 0 // 100 &amp; 100 = 100 // 100 &amp; 10 = 0 // 100 &amp; 1 = 0 if(x&amp;(1&lt;&lt;i)) cout&lt;&lt;(x&amp;(1&lt;&lt;i))&lt;&lt;'*'; else cout&lt;&lt;' '; &#125;int main()&#123; for(int i=0;i&lt;10;i++)&#123; for(int i=0;i&lt;16;i++)&#123; //由题目很容易可以看出 两个八位二进制一行 int x,y; scanf(\"%d%d\",&amp;x,&amp;y); print(x); print(y); cout&lt;&lt;endl; &#125; cout&lt;&lt;endl&lt;&lt;endl; &#125; return 0; &#125; 第三题： 乘积尾零(满分13分)题目描述： 如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？5650 4542 3554 473 946 4114 3871 9073 90 43292758 7949 6113 5659 5245 7432 3051 4434 6704 35949937 1173 6866 3397 4759 7557 3070 2287 1453 98991486 5722 3135 1170 4014 5510 5120 729 2880 90192049 698 4582 4346 4427 646 9742 7340 1230 76835693 7015 6887 7381 4172 4341 2909 2027 7355 56496701 6645 1671 5978 2704 9926 295 3125 3878 67852066 4247 4800 1578 6652 4616 1113 6205 3264 29153966 5291 2904 1285 2193 1428 2265 8730 9436 7074689 5510 8243 6114 337 4096 8199 7313 3685 211注意：需要提交的是一个整数，表示末尾零的个数。不要填写任何多余内容。 个人感受： 大数这道题。。写的时候还是贼开心的== 因为。。我以为写出来了==对于这种数学弱鸡，简直不懂分解为2和5。。只会一行一行的去十个十个相乘再去模一亿取余然而==死在了 我只保留了最后两位 非零数。。。。导致杀千刀的少了三个0(大佬说要保留四位（后我实测为3位）)这道题 错的 特别 不该 代码也就三分钟的事== 思路：两种方法①直接将所有数相乘，然后每乘一个数就把后面0全部去掉记一下，不过中间会爆long long，这个好办，每次乘完只保留后4位非0数字，例如216037就只保留6037②正解：所有的0都一定是2*5产生的，所以将每个数拆成一堆2乘上一堆5再乘上一个数，之后统计下有多少个2和多少个5取少的那个就是答案 题目答案：答案：31思路一的代码 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a[101],cnt=0; for(int i=0;i&lt;100;i++) scanf(\"%d\",a+i); for(int i=0;i&lt;99;i++)&#123; a[i+1]*=a[i]; while(a[i+1]%10==0)&#123; a[i+1]/=10; cnt++; &#125; a[i+1]%=1000; &#125; cout&lt;&lt;cnt; return 0;&#125; 思路二的代码 12345678910111213#include&lt;bits/stdc++.h&gt; using namespace std; int main()&#123; int res2=0,res5=0; for(int i=0;i&lt;100;i++)&#123; int x; scanf(\"%d\",&amp;x); int y=x; while(x%2==0)res2++,x/=2; while(x%5==0)res5++,x/=5; &#125; cout&lt;&lt;min(res2,res5)&lt;&lt;endl; &#125; 第四题： 测试次数(满分17分)题目描述： x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n为了减少测试次数，从每个厂家抽样3部手机参加测试。某次测试的塔高为1000层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？请填写这个最多测试次数。注意：需要填写的是一个整数，不要填写任何多余内容。 个人感受： 这道题凉凉，很凉，透心凉教训，下次一定要先看分值==看到题目，最优策略？OK二分！然后就算出了 九次吧==然后自信直接过回来车上在复盘，忽然想到，等下。。那个。。摔手机？手机。。手机。。会摔坏了吧。。mm了个大p，一问舍友(zl) ，他不是还给了三个手机吗？我…..好的。。。题目都没看清。。都不知道我在干嘛。。 不过就算知道了，我也没算对。。。心理平衡了一点 后来我只能算出28。。。emmmm大佬: 直接三维 dp dp[0][1000][3] 第一个0一定不爆，第二个1000一定爆，第三个 3个手机。。emmmmm……还是不会 题目答案：答案：19 第五题： 快速排序(满分9分)题目描述： 以下代码可以从数组a[]中找出第k小的元素。它使用了类似快速排序中的分治算法，期望时间复杂度是O(N)的。请仔细阅读分析源码，填写划线部分缺失的内容。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int quick_select(int a[], int l, int r, int k) &#123; int p = rand() % (r - l + 1) + l; int x = a[p]; &#123;int t = a[p]; a[p] = a[r]; a[r] = t;&#125; int i = l, j = r; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; a[i] &lt; x) i++; if(i &lt; j) &#123; a[j] = a[i]; j--; &#125; while(i &lt; j &amp;&amp; a[j] &gt; x) j--; if(i &lt; j) &#123; a[i] = a[j]; i++; &#125; &#125; a[i] = x; p = i; if(i - l + 1 == k) return a[i]; if(i - l + 1 &lt; k) return quick_select( _____________________________ ); //填空 else return quick_select(a, l, i - 1, k);&#125; int main()&#123; int a[] = &#123;1, 4, 2, 8, 5, 7, 23, 58, 16, 27, 55, 13, 26, 24, 12&#125;; printf(\"%d\\n\", quick_select(a, 0, 14, 5)); return 0;&#125;注意：只填写划线部分缺少的代码，不要抄写已经存在的代码或符号。 个人感受： 这道题。。算了。。填空这种题目每次我都是瞎jb猜，然后看答案对不对。。我写了个(a,l,r,k)大概对了，就交了。。宛如智障以为。。对了的好的 题目答案：答案：a,i+1,r,k-(i-l+1) 第六题： 递增三元组(满分11分)题目描述： 给定三个整数数组A = [A1, A2, … AN],B = [B1, B2, … BN],C = [C1, C2, … CN]，请你统计有多少个三元组(i, j, k) 满足： 1 &lt;= i, j, k &lt;= N Ai &lt; Bj &lt; Ck 【输入格式】第一行包含一个整数N。第二行包含N个整数A1, A2, … AN。第三行包含N个整数B1, B2, … BN。第四行包含N个整数C1, C2, … CN。对于30%的数据，1 &lt;= N &lt;= 100对于60%的数据，1 &lt;= N &lt;= 1000对于100%的数据，1 &lt;= N &lt;= 100000 0 &lt;= Ai, Bi, Ci &lt;= 100000 【输出格式】一个整数表示答案 【样例输入】31 1 12 2 23 3 3 【样例输出】27 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 个人感受： 最简单的一道题了== 暴力for。。虽然不知道最后会不会爆。。但至少有60吧一开始看到..emmm 不就深搜嘛，最近写了不少，好的。。三分钟码完。。挖草 怎么样例输入答案一直是3心态崩了，换了三个for….老子就不信了。。咦。。怎么还是3我特么。。dev坏了吧？？？偷偷换个VC还是3 VS2010 还是3心态崩了。。 输出中间值明明有27次啊。。忽然。。发现。。 调用函数没return最后的cnt 。。好小子，你过来，不打死你以至最后也懒得换回dfs了。。最后，如果有人看了我的代码，可能会觉得被欺骗了。。函数名=dfs，一看。。里面只有三个for。。。哈哈哈哈哈哈 题目答案：dfs 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int cnt=0,n;int a[100001],b[100001],c[100001]; int dfs(int i,int j,int k)&#123; if(a[i]&lt;b[j]&amp;&amp;b[j]&lt;c[k]) cnt++; if(i==n-1&amp;&amp;j==n-1&amp;&amp;k==n-1) return cnt; if(k&lt;n) dfs(i,j,k+1); else if(j&lt;n) dfs(i,j+1,0); else if(i&lt;n) dfs(i+1,0,0);&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;b[i]); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;c[i]); printf(\"%d\",dfs(0,0,0)); return 0;&#125; 三个for 暴力求解 123456for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) if(a[i]&lt;b[j]&amp;&amp;b[j]&lt;c[k]) cnt++; return cnt; 最优解思路：分别排序先看b和c两个数组，设两个下标i，j分别指向bc数组，对于每一个b[i],可以找到对应的c[j]恰好大于b[i]，那么对于b[i]有n-j个c[j]满足b[i]&lt;c[j]。令sumb[i]=n-j，表示每个b[i]对应的c[j]个数。将sumb处理成后缀和。然后再看a和b数组，用同样的方法打出数组suma，不过suma[i]=sumb[j]；然后将suma处理成后缀和，suma[0]即为答案。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int N=1e6+10; ll suma[N],sumb[N]; int a[N],b[N],c[N]; int n; int main()&#123; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;b[i]); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;c[i]); sort(a,a+n); sort(b,b+n); sort(c,c+n); memset(sumb,0,sizeof(sumb)); for(int i=0,j=0;i&lt;n;i++)&#123; while(j&lt;n&amp;&amp;b[i]&gt;=c[j])j++; if(j&gt;=n)break; sumb[i]=n-j; &#125; for(int i=n-2;i&gt;=0;i--) //b hou zhui he sumb[i]+=sumb[i+1]; for(int i=0,j=0;i&lt;n;i++)&#123; while(j&lt;n&amp;&amp;a[i]&gt;=b[j])j++; if(j&gt;=n)break; suma[i]=sumb[j]; &#125; for(int i=n-2;i&gt;=0;i--) //a hou zhui he suma[i]+=suma[i+1]; printf(\"%lld\\n\",suma[0]); &#125; 第七题： 螺旋折线(满分19分)题目描述： 如图p1.png所示的螺旋折线经过平面上所有整点恰好一次。对于整点(X, Y)，我们定义它到原点的距离dis(X, Y)是从原点到(X, Y)的螺旋折线段的长度。例如dis(0, 1)=3, dis(-2, -1)=9给出整点坐标(X, Y)，你能计算出dis(X, Y)吗？ 【输入格式】X和Y对于40%的数据，-1000 &lt;= X, Y &lt;= 1000对于70%的数据，-100000 &lt;= X， Y &lt;= 100000对于100%的数据, -1000000000 &lt;= X, Y &lt;= 1000000000 【输出格式】输出dis(X, Y) 【样例输入】0 1 【样例输出】3 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 个人感受： 并列最简单的一题，emmmm 没啥操作。。就是循环到那个点应该时间上会爆了，反正至少50吧。。 题目答案：代码：#include&lt;bits/stdc++.h&gt;using namespace std;int ex,ey,nx=0,ny=0;int check(){ if(nx==ex&amp;&amp;ny==ey) return 1; else return 0;}int main(){ scanf(“%d%d”,&amp;ex,&amp;ey); int h=0,cnt=0; while(1){ for(int i=0;i&lt;4;i++){ h++; if(i==0) for(int j=0;j&lt;(h+1)/2;j++){ nx–; cnt++; if(check()){ printf(“%d”,cnt); return 0; } } else if(i==1) for(int j=0;j&lt;h/2;j++){ ny++; cnt++; if(check()){ printf(“%d”,cnt); return 0; } } else if(i==2) for(int j=0;j&lt;(h+1)/2;j++){ nx++; cnt++; if(check()){ printf(“%d”,cnt); return 0; } } else for(int j=0;j&lt;h/2;j++){ ny–; cnt++; if(check()){ printf(“%d”,cnt); return 0; } } } } return 0;} 第八题： 日志统计(满分21分)题目描述： 小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有N行。其中每一行的格式是：ts id表示在ts时刻编号id的帖子收到一个”赞”。现在小明想统计有哪些帖子曾经是”热帖”。如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是”热帖”。具体来说，如果存在某个时刻T满足该帖在[T, T+D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是”热帖”。给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。 【输入格式】第一行包含三个整数N、D和K。以下N行每行一条日志，包含两个整数ts和id。对于50%的数据，1 &lt;= K &lt;= N &lt;= 1000对于100%的数据，1 &lt;= K &lt;= N &lt;= 100000 0 &lt;= ts &lt;= 100000 0 &lt;= id &lt;= 100000 【输出格式】按从小到大的顺序输出热帖id。每个id一行。 【输入样例】7 10 20 10 1010 1010 19 1100 3100 3 【输出样例】13 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 个人感受： 很烦的一道题。。 思路就是先筛选 ts大于k的 然后再按照 ts在 某段时间内多少排序。。道理都懂。。就是弱鸡。。。。没写完就交了== 没写完的我 输入正常，输出 print(“1\\n3”);哈哈哈哈 看看能不能 骗上10分 题目答案：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=1e6+10;struct node&#123; int t,id;&#125;e[N];bool cmp(node a,node b)&#123; // 对结构体按某个条件排序 return a.t&lt;b.t;&#125;int sta[N],top;int c[N];int n,d,k;bool insta[N];int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;d,&amp;k); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d%d\",&amp;e[i].t,&amp;e[i].id); &#125; sort(e+1,e+1+n,cmp); memset(c,0,sizeof(c)); memset(insta,0,sizeof(insta)); top=0; for(int i=1,j=1;i&lt;=n;i++) &#123; while(j&lt;=n&amp;&amp;e[i].t-e[j].t&gt;=d) c[e[j++].id]--; c[e[i].id]++; if(c[e[i].id]&gt;=k&amp;&amp;!insta[e[i].id])&#123; sta[top++]=e[i].id; insta[e[i].id]=1; &#125; &#125; sort(sta,sta+top); top=unique(sta,sta+top)-sta; for(int i=0;i&lt;top;i++) printf(\"%d\\n\",sta[i]);&#125; 第九题：全球变暖(满分23分)题目描述： 你有一张某海域NxN像素的照片，”.”表示海洋、”#”表示陆地，如下所示：........##.....##........##...####....###........其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。例如上图中的海域未来会变成如下样子：................................#................请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 【输入格式】第一行包含一个整数N。 (1 &lt;= N &lt;= 1000)以下N行N列代表一张海域照片。照片保证第1行、第1列、第N行、第N列的像素都是海洋。 【输出格式】一个整数表示答案。 【输入样例】7........##.....##........##...####.…###........ 【输出样例】1 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 个人感受： 为啥样例 淹没是1.。没被淹没是1我傻傻的看错了== 输出了相反的。。 阿西吧 心痛反正我的就是两个bfs还有一个很有趣的有人给了一组这样的数据：### ############# ###只有一个岛屿但是淹没后你会发现“岛屿”还会多出来一个！如下 # # 这个。。输出0还是-1.。我也不知道。。等答案了。。。 题目答案：这个 有一个正解代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e3+10;int dir[4][2]=&#123;-1,0,0,1,1,0,0,-1&#125;;bool vis[N][N];char mmp[N][N];int n,flag;bool check(int x,int y)&#123;//check if sea; for(int i=0;i&lt;4;i++)&#123; int fx=x+dir[i][0]; int fy=y+dir[i][1]; if(fx&amp;&amp;fy&amp;&amp;fx&lt;=n&amp;&amp;fy&lt;=n&amp;&amp;mmp[fx][fy]=='.') return 1; //sea; &#125; return 0; //no sea;&#125;void dfs(int x,int y)&#123; vis[x][y]=1; if(!check(x,y))flag=1; //remain lu di for(int i=0;i&lt;4;i++)&#123; int fx=x+dir[i][0]; int fy=y+dir[i][1]; if(fx&amp;&amp;fy&amp;&amp;fx&lt;=n&amp;&amp;fy&lt;=n&amp;&amp;!vis[fx][fy]&amp;&amp;mmp[fx][fy]=='#') dfs(fx,fy); &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",mmp[i]+1); &#125; memset(vis,0,sizeof(vis)); int ans=0,ludi=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++) if(!vis[i][j]&amp;&amp;mmp[i][j]=='#')&#123; ludi++; flag=0; //yan mo dfs(i,j); if(flag) ans++; //remained &#125; &#125; printf(\"%d\",ludi-ans);&#125; 第一题： 乘积最大(满分25分)题目描述： 给定N个整数A1, A2, … AN。请你从中选出K个数，使其乘积最大。请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以1000000009的余数。注意，如果X&lt;0， 我们定义X除以1000000009的余数是负(-X)除以1000000009的余数。即：0-((0-x) % 1000000009) 【输入格式】第一行包含两个整数N和K。以下N行每行一个整数Ai。对于40%的数据，1 &lt;= K &lt;= N &lt;= 100对于60%的数据，1 &lt;= K &lt;= 1000对于100%的数据，1 &lt;= K &lt;= N &lt;= 100000 -100000 &lt;= Ai &lt;= 100000 【输出格式】一个整数，表示答案。 【输入样例】5 3-100000-10000210000010000 【输出样例】999100009 再例如：【输入样例】5 3-100000-100000-2-100000-100000 【输出样例】-999999829 资源约定：峰值内存消耗（含虚拟机） &lt; 256MCPU消耗 &lt; 1000ms 个人感受： 别说了。。我 也不知道为啥。。第二个案例一直是-1.。。。脑阔疼 还是交了，毕竟如果都跟第一个案例一样。。我还是能对的==瑟瑟发抖的提交了。。看了大佬的分析 我终于知道弱鸡的自己错哪了== 题目答案：【分析】像贪模拟贪心。 分了三种情况，1.不含负数，2.不含正数，3.正负都有。 0的情况可以同时放在这三种情况中。 情况1：从最大数开始选即可情况2：先考虑能否为0，再考虑选偶数个最小负数，若都做不到，就选奇数个最大负数情况3：最难。先考虑用尽量少的负数，尽可能用正数，再从最小负数开始考虑，每次拿两个，乘积去和最小整数的进行比较，若大于，则可用这两个负数替换那两个正数 【代码】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int mod=1e9+9; const int N=1e5+10; bool cmp(int i,int j)&#123; return i&gt;j; &#125; ll a[N],b[N]; int ta,tb,n,k; int main() &#123; scanf(\"%d%d\",&amp;n,&amp;k); ta=tb=0; int x; int c0=0; for(int i=0;i&lt;n;i++) &#123; scanf(\"%d\",&amp;x); if(x&gt;0)a[ta++]=x; else if(x&lt;0)b[tb++]=x; else c0++; &#125; sort(a,a+ta,cmp); sort(b,b+tb); ll ans=1; if(tb==0) //positive and 0 &#123; if(ta&lt;k)ans=0; //0 else &#123; for(int i=0;i&lt;k;i++) ans=ans*a[i]%mod; &#125; &#125; else if(ta==0) //negetive and 0 &#123; if(k%2&amp;&amp;c0 || tb&lt;k)ans=0; else &#123; if(k%2) //k is odd, but no 0 &#123; for(int i=0,j=tb-1;i&lt;k;i++,j--) ans=ans*b[j]%mod; &#125; else&#123; for(int i=0;i&lt;k;i++) ans=ans*b[i]%mod; &#125; &#125; &#125; else //-,+, 0 &#123; if(c0&amp;&amp;ta+tb&lt;k)&#123; ans=0; &#125; else if(ta+tb==k&amp;&amp;c0==0)&#123; for(int i=0;i&lt;tb;i++)ans=ans*b[i]%mod; for(int i=0;i&lt;ta;i++)ans=ans*a[i]%mod; &#125; else&#123; int fu; if(k&lt;=ta)fu=0; else fu=(k-ta+1)&amp;(-2); cout&lt;&lt;\"fu\"&lt;&lt;fu&lt;&lt;endl; int t=fu; for(int i=fu;i&lt;=tb&amp;&amp;i&lt;=k;i+=2) if(i&gt;=2&amp;&amp;k-i&gt;=0) &#123; cout&lt;&lt;\"i \"&lt;&lt;i&lt;&lt;endl; if(b[i-1]*b[i-2]&gt;a[k-i]*a[k-i+1]) t=i; else break; &#125; for(int i=0;i&lt;t;i++) ans=ans*b[i]%mod; for(int i=0;i&lt;k-t;i++)ans=ans*a[i]%mod; &#125; &#125; printf(\"%lld\\n\",ans); &#125; 个人总结：垃圾的我! 一开始以为 对了8题(不难吧~) 好的，发现两道题看错了 对六道有省二嘛？ 等到答案出来。。填空再去两道== 傻逼答案 所以 愚人节快乐 其实真的不难。。看到答案心态易爆炸笑死人的讨论区，值得一看。。。https://www.zhihu.com/question/270622751 想想是真的菜好好努力 尽力试试能不能进入ACM训练队吧！PS:其实省赛的难度真的不大，好好准备一下明年再来！ PS:居然水进了国赛。。。。美滋滋哈哈哈哈 开心了好久。。公费游北京 我来了！！！最近多刷刷题 争取能有机会冲击国奖吧(虽然没啥可能)2018/4/9","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"C/C++题目","slug":"C-C-题目","permalink":"https://edxuanlen.tk/tags/C-C-题目/"},{"name":"经历","slug":"经历","permalink":"https://edxuanlen.tk/tags/经历/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"不要62","slug":"不要62","date":"2018-03-31T14:45:22.000Z","updated":"2020-02-06T22:40:22.782Z","comments":true,"path":"2018/03/31/不要62/","link":"","permalink":"https://edxuanlen.tk/2018/03/31/不要62/","excerpt":"","text":"题目链接 题意 Problem Description杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 Output对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input1 1000 0 Sample Output80 数位DP解法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;long long f[10][10];void getdp()&#123; f[0][0]=1; for(int i=1;i&lt;10;i++)&#123; for(int j=0;j&lt;10;j++)&#123; if(j==4) f[i][j]=0; else if(j==6) &#123; for(int k=0;k&lt;10;k++) f[i][j]+=f[i-1][k]; f[i][j]-=f[i-1][2]; &#125; else&#123; for(int k=0;k&lt;10;k++) f[i][j]+=f[i-1][k]; &#125; &#125; &#125; for(int i=0;i&lt;10;i++)&#123; for(int j=0;j&lt;10;j++) printf(\"%8d \",f[i][j]); cout&lt;&lt;endl&lt;&lt;endl; &#125;&#125; int a[10]; long long solve(int n)&#123; a[0]=0; while(n)&#123; a[++a[0]]=n%10; n/=10; &#125; a[a[0]+1]=0; long long ans=0; for(int i=a[0];i&gt;=1;i--)&#123; for(int j=0;j&lt;a[i];j++) //if(!(a[i+1]==6&amp;&amp;j==2)) ans+=f[i][j]; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;a[i]&lt;&lt;\":\"&lt;&lt;ans&lt;&lt;endl; if(a[i]==4)break; if(a[i+1]==6&amp;&amp;a[i]==2) break; &#125; return ans; &#125; int main()&#123; int n,m; getdp(); while(scanf(\"%d %d\",&amp;n,&amp;m)==2&amp;&amp;(n||m))&#123; long long k1=solve(m+1); cout&lt;&lt;endl; long long k2=solve(n); printf(\"%I64d\\n\",k1-k2); &#125; &#125; 运行结果如下 打表1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000000]=&#123;0&#125;; int main() &#123; int i,n,m,d=0; for(i=1;i&lt;1000000;++i) &#123; if(i%10==4||i/10%10==4||i/100%10==4||i/1000%10==4||i/10000%10==4||i/100000%10==4)a[i]=a[i-1]; else if(i%100==62||i/10%100==62||i/100%100==62||i/1000%100==62||i/10000%100==62)a[i]=a[i-1]; else a[i]=a[i-1]+1; &#125; for(int i=0;i&lt;600;i++)&#123; if(i%30==0)cout&lt;&lt;endl; printf(\"%3d \",a[i]); &#125; cout&lt;&lt;endl&lt;&lt;endl; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF&amp;&amp;n!=0||m!=0) printf(\"%d\\n\",a[m]-a[n-1]); &#125; 运行结果如下 通过输出两个不同解法的表 其实很容易看懂代码的意思。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://edxuanlen.tk/tags/动态规划/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"Dungeon Master","slug":"Dungeon-Master","date":"2018-03-31T12:18:01.000Z","updated":"2020-02-06T22:40:22.751Z","comments":true,"path":"2018/03/31/Dungeon-Master/","link":"","permalink":"https://edxuanlen.tk/2018/03/31/Dungeon-Master/","excerpt":"","text":"原题链接 题目内容 DescriptionFarmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute Teleporting: FJ can move from any point X to the point 2 × X in a single minute.If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it? Input*Line 1: Two space-separated integers: N and K Output*Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow. Sample Input5 17 Sample Output4 HintThe fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes. 题解: 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;queue&gt;using namespace std;queue&lt;int&gt; q;bool vis[100001];int step[100001];int n,k;int bfs()&#123; q.push(n); vis[n]=true; while(!q.empty())&#123; n=q.front(); q.pop(); int nn=n; for(int i=0;i&lt;3;i++)&#123; if(i==0) n=nn+1; else if(i==1) n=nn-1; else n=nn*2; if(n&gt;=0&amp;&amp;n&lt;=100000&amp;&amp;!vis[n])&#123; q.push(n); step[n]=step[nn]+1; vis[n]=true; &#125; if(n==k)return step[n]; &#125; &#125;&#125;int main()&#123; while(scanf(\"%d%d\",&amp;n,&amp;k)!=EOF)&#123; memset(vis,false,sizeof(vis)); while(!q.empty())q.pop(); printf(\"%d\\n\",bfs()); &#125; return 0;&#125; 已AC….by edxuanlen","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://edxuanlen.tk/tags/BFS/"},{"name":"STL","slug":"STL","permalink":"https://edxuanlen.tk/tags/STL/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"Template","slug":"ACM_Template","date":"2018-03-31T12:17:43.000Z","updated":"2020-02-06T22:40:22.750Z","comments":true,"path":"2018/03/31/ACM_Template/","link":"","permalink":"https://edxuanlen.tk/2018/03/31/ACM_Template/","excerpt":"","text":"number theory(数论)扩展欧几里得相关12345678910111213141516171819202122232425262728293031323334353637383940// ax + by = gcd(a, b)LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; else&#123; LL d = exgcd(b, a % b, y, x); y -= x * (a / b); return d; &#125;&#125;// ax + by = cbool linear_equation(LL a, LL b, LL c, LL &amp;x, LL &amp;y)&#123; LL d = exgcd (a, b, x, y); if( c % d ) return false; LL k = c / d; x *= k; y *= k; return true; // 其他解为 x + b / d * t; y - a / d * t; t为任意整数&#125;// ax ≡ b (mod n)bool modular_linear_equation(LL a, LL b, LL n, LL &amp;x, LL &amp;y)&#123; LL x0, i; LL d = exgcd(a, n, x, y); if( b % d ) return false; x0 = x * ( b / d ) % n; for(i = 1; i &lt;= d; i ++) printf(\"%d\\n\", ( x0 + i * ( n / d ) ) % n ); return true;&#125;// inverseint inverse(LL a, LL m, LL x, LL y)&#123; LL d = exgcd(a, m, x, y); return (x + m) % m;&#125; 勾股数组取n $\\lt$ m且满足(n &amp; 1) ^ (m &amp; 1)为1（这里的^为异或，此表达式说明二者奇偶不同），同时gcd(n, m) = 1（即二者互素），则可得到满足 $a^2 + b^2 = c^2$ 的勾股数组： $ a = m^2 - n^2 $$ b = 2 * n * m $$ c = m^2 + n^2 $ 按照顺序枚举满足上述条件（奇偶不同的互素n $\\lt$ m二元组（n, m）），就可以得到所有的本源勾股数组，同时它们的整数倍也是勾股数组。这个方法可以取得所有的勾股数组。 欧拉线性筛欧拉线性筛求判断素数和求最小质因子 1234567891011121314// MinFactor[i] = x 表示为i最小质因子为 x// p[i] = x 表示为第 i+1 个素数为x// MinFactor 只求素数可换为 bool 类型判断 not_primevoid euler()&#123; int t = 0; pos = 0; for(int i = 2; i &lt; LIM; i ++)&#123; if ( !MinFactor[i] ) p[pos ++] = MinFactor[i] = i; for(int j = 0; (t = i * p[j]) &lt; LIM; j ++)&#123; MinFactor[t] = p[j]; if( !(i % p[j]) ) break; &#125; &#125;&#125; 欧拉函数phi(i) 意义： 小于 i 且与 i 互质的正整数的个数 打表时间复杂度 O(n) 1234567891011121314151617void init_phi()&#123; int t; phi[1] = 1; for(int i = 2; i &lt; LIM; i ++)&#123; if( !phi[i] )&#123; phi[i] = i - 1; p[cnt ++] = i; &#125; for(int j = 0; (t = i * p[j]) &lt; LIM; j ++)&#123; if( i % p[j] ) phi[t] = phi[i] * (p[j] - 1); else &#123; phi[t] = phi[i] * p[j]; break; &#125; &#125; &#125;&#125; 单个时间复杂度为 O($\\sqrt{n}$) 12345678910111213LL phi(LL n) &#123; LL ret = 1; for (LL i = 2; i * i &lt;= n; i++) &#123; if (!(n % i)) &#123; ret *= i - 1; n /= i; while (!(n % i)) ret *= i, n /= i; &#125; &#125; if (n ^ 1) ret *= (n - 1); return ret;&#125; Numberical Methods(数值方法)高精度平方根牛顿逼近法 123456789101112131415161718192021222324252627282930313233343536373839public static BigDecimal sqrt(BigDecimal b, BigDecimal eps) &#123; BigDecimal crt = new BigDecimal(b.toString()); BigDecimal two = BigDecimal.valueOf(2); int scale = eps.scale() + 2; Boolean isNegtive = false; if (crt.compareTo(BigDecimal.valueOf(0)) &lt; 0) &#123; b = b.negate(); crt = crt.negate(); isNegtive = true; &#125; while (true) &#123; BigDecimal nxt = crt.subtract(crt.multiply(crt).subtract(b).divide(two.multiply(crt), scale, BigDecimal.ROUND_DOWN)); // test // System.out.println(nxt); if (nxt.subtract(crt).abs().compareTo(eps) &lt;= 0) &#123; crt = nxt; break; &#125; crt = nxt; &#125; if (isNegtive) &#123; b = b.negate(); crt = crt.negate(); &#125; return crt;&#125;public static BigDecimal sqrt(BigDecimal b) &#123; BigDecimal eps = new BigDecimal(\"0.00000000000000000000000001\"); return sqrt(b, eps);&#125;public static BigDecimal sqrt(BigInteger b, BigDecimal eps) &#123; BigDecimal tmp = new BigDecimal(b.toString()); return sqrt(tmp, eps);&#125;public static BigDecimal sqrt(BigInteger b) &#123; BigDecimal tmp = new BigDecimal(b.toString()); return sqrt(tmp);&#125; 快速求幂取模法123456789101112131415161718192021222324252627282930313233343536//计算(a*b)%clong long mul(long long a,long long b,long long mod) &#123; long long res = 0; while(b &gt; 0)&#123; if( (b&amp;1) != 0) // 二进制最低位是1 --&gt; 加上 a的 2^i 倍, 快速幂是乘上a的2^i ） res = ( res + a) % mod; a = (a &lt;&lt; 1) % mod; // a = a * 2 a随着b中二进制位数而扩大 每次 扩大两倍。 b &gt;&gt;= 1; // b -&gt; b/2 右移 去掉最后一位 因为当前最后一位我们用完了， &#125; return res;&#125;//幂取模函数long long pow1(long long a,long long n,long long mod)&#123; long long res = 1; while(n &gt; 0)&#123; if(n&amp;1) res = (res * a)%mod; a = (a * a)%mod; n &gt;&gt;= 1; &#125; return res;&#125;// 计算 ret = (a^n)%modlong long pow2(long long a,long long n,long long mod) &#123; long long res = 1; while(n &gt; 0) &#123; if(n &amp; 1) res = mul(res,a,mod); a = mul(a,a,mod); n &gt;&gt;= 1; &#125; return res;&#125; 矩阵乘法和快速幂123456789101112131415161718192021222324struct matrix&#123; LL m[10][10]; matrix()&#123; memset(m,0,sizeof(m)); &#125;&#125;;matrix operator * (const matrix &amp; a,const matrix &amp; b)&#123; matrix c; for (int i=1; i&lt;=9; i++) for (int j=1; j&lt;=9; j++)&#123; c.m[i][j]=0; for (int k=1; k&lt;=9; k++) c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mod;//一般题目都要求要modulo一个数 &#125; return c;&#125;matrix quick(matrix base,int pow)&#123; matrix a; for (int i=1; i&lt;=9; i++) a.m[i][i]=1; while (pow) &#123; if (pow&amp;1) a=a*base; base=base*base; pow&gt;&gt;=1; &#125; return a;&#125; 组合数学Contar康托展开由一个排列计算它是全排列中的第几个排列的方法。 123456789101112131415161718192021222324252627282930313233int fac[15];void factor()&#123; fac[0] = fac[1] = 1; for(int i = 2; i &lt; 13; ++ i) fac[i] = fac[i - 1] * i;&#125;//逆康托string uncantor(int x, int k) &#123; string res; int i, j, l, t; bool h[100]; for (i = 1; i &lt;= k; i++) &#123; t = x / fac[k - i]; x -= t * fac[k - i]; for (j = 1, l = 0; l &lt;= t; j++) if ( !h[j] ) l++; j --; h[j] = true; res += j + '0'; &#125; return res;&#125;//康托int cantor(int* a, int len)&#123; int ans = 0; for(int i = 0; i &lt; len; ++ i)&#123; int t = 0; for(int j = i + 1; j &lt; len; ++j) if(a[j] &lt; a[i]) t ++; ans += fac[len - i - 1] * t; &#125; return ans + 1;&#125; Catalan Number 卡特兰数$C_n = \\frac{4n - 2}{n + 1} C_{n-1}$ 相关问题 Cn可以表示长度为2n的Dyck Words的种类数，Dyck Words由n个A字符与n个B字符组成，且满足在任意位置上，前缀中A的数量不小于B的数量，如果A用(代替，把B用)代替，就是一个典型的括号表达式，因此也可以用来表示合法的表达式个数。 Cn可以表示有n个结点的不同构的二叉树的种类数。 Cn可以表示有2n + 1个结点的不同构的满二叉树的种类数。 Cn可以表示在n*n的格点中从左下角延格线走到右上角且始终不超过对角线的方案数。 Cn可以表示通过连接顶点将n + 2个顶点的凸多边形划分成三角形的方案数。 Cn表示有n个元素的出栈顺序的种类数。 Cn可以用在买票找零钱问题上，对于2n的观众，收银台初始没有钱，无法找零，接下来有n个人拿a元买票，n个人拿2a元买票（需要找零钱数为a），能够保证每一个需要找零的观众来的时候都能够得到找零的合法方案数。 Cn可以表示在二维直角坐标系中，从(0, 0)走到(2n, 0)点，每个相邻整数点的纵坐标差值的绝对值为1，且点始终不会落到x轴下方的方案数。 高精度大数操作BigInteger12345678910111213141516import java.math.BigInteger;import java.util.Scanner;public class BI &#123; public static void main(String[] args) &#123; Scanner in = new Scanner (System.in); BigInteger a, b; a = in.nextBigInteger(); b = in.nextBigInteger(); System.out.println(a.add(b)); System.out.println(a.subtract(b)); System.out.println(a.multiply(b)); System.out.println(a.divide(b)); BigInteger mod = BigInteger.valueOf(3); System.out.println(b.mod(mod)); &#125;&#125; 小数操作BigDecimal12345678910111213141516171819202122import java.math.BigDecimal;import java.util.*;public class BD &#123; public static void main(String[] args) &#123; BigDecimal a = new BigDecimal(10); BigDecimal b = new BigDecimal(10.5); BigDecimal c = new BigDecimal(123456789101222L); BigDecimal d = new BigDecimal(\"-123456.31\"); System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); System.out.println(a.add(b).add(c).add(d)); System.out.println(a.subtract(b).subtract(a)); System.out.println(a.multiply(b).multiply(c)); System.out.println(c.divide(a).divide(new BigDecimal(20))); System.out.println(d.divide(a)); System.out.println(d.doubleValue()); System.out.println(a.compareTo(b));// -1 System.out.println(a.equals(b));// flase &#125;&#125; 生成排列next_permutation() 生成下一个排列prev_permutation() 生成上一个排列 1234do&#123; cout &lt;&lt; str &lt;&lt; endl;// &#125;while (next_permutation(str.begin(), str.end()));&#125;while (prev_permutation(str.begin(), str.end())); Graph 图论topu 拓扑排序12345678910111213141516171819int in[maxn];//存入度数vector &lt;int &gt; edge[maxn]; //存边int topu_sort()&#123; queue&lt;int&gt;q; for (int i = 1; i &lt;= n; i++) if (!in[i]) q.push(i); //取出入度为0的点放 while (!q.empty())&#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; edge[u].size(); i++)&#123; //删边与统计操作 int v = edge[u][i]; in[v] --; //删边 if ( ! in[v] ) q.push(v); &#125; printf (\"%d \", u); &#125; for (int i = 1; i &lt;= n; i++) //若存在全部遍历完仍存在入度不为0的点说明存在环 if (in[i]) return -1;&#125; Shortest Path 最短路Dijstra123456789101112131415161718192021typedef pair&lt;int, int&gt; P;int pre[2501]; // 路径记录void Dijkstra( int s )&#123; priority_queue&lt; P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; fill (d + 1, d + n + 1, INF); d[s] = 0; q.push(P(0, s)); while (q.size())&#123; P p = q.top(); q.pop(); int h = p.second; if( d[h] &lt; p.first ) continue; for(int i = 0; i &lt; v[h].size(); i ++)&#123; edge e = v[h][i]; if( d[e.to] &gt; d[h] + e.cost )&#123; d[e.to] = d[h] + e.cost; q.push(P(d[e.to], e.to)); pre[e.to] = h; // 记录前驱 &#125; &#125; &#125;&#125; SPFA从起点到任意一个点最短距离经过的点最多只有 n 个，用 cnt[ i ] 表示从起点（假设就是 1）到 i 的最短距离包含点的个数，初始化 cnt[ 1 ] = 1，那么当我们能够用点 u 松弛点 v 时，当我们能够用点 u 松弛点 v 时，松弛时同时更新 cnt[ v ] = cnt[ u ] + 1，若发现此时 cnt[ v ] &gt; n，那么就存在负环 123456789101112131415161718192021bool SPFA( int s )&#123; queue&lt;int &gt; q; fill(d + 1, d + n + 1, INF); d[s] = 0; q.push(s); vis[s] = 1; while ( q.size() )&#123; int t = q.front(); q.pop(); vis[t] = 1; for(auto i = v[t].begin(); i != v[t].end(); i ++ )&#123; if( i -&gt; cost + d[t] &lt; d[i -&gt; to] )&#123; d[i -&gt; to] = i -&gt; cost + d[t]; // cnt[ i -&gt; to ] = 1 + cnt[t]; // if(cnt[i -&gt; to] &gt; n ) return false; if( !vis[i -&gt; to] ) q.push(i -&gt; to); &#125; &#125; &#125; return true;&#125; MST 最小生成树Kruskal12345678910111213141516171819202122232425void init()&#123; for(int i = 1; i &lt;= n; i ++) p[i] = i;&#125;int find( int x )&#123; return x == p[x] ? x : p[x] = find(p[x]);&#125;ll Kruskal()&#123; ll res = 0; sort(E, E + m, cmp); init(); int cnt = 0; for (int i = 0; i &lt; m; i ++ )&#123; edge e = E[i]; int x = find(e.from); int y = find(e.to); if( x != y )&#123; p[x] = p[y]; cnt ++; res += (ll) e.cost; &#125; if( cnt == n - 1 ) break; &#125; return res;&#125; Prim123456789101112131415161718192021222324ll Prim()&#123; fill (cost + 1, cost + n + 1, INF); cost[1] = 0; priority_queue &lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; q.push(P(0, 1)); ll res = 0; while ( q.size() &amp;&amp; cnt &lt; n )&#123; P p = q.top(); q.pop(); int v = p.second; if( !vis[v] )&#123; cnt ++; vis[v] = 1; res += p.first; for(int i = 0; i &lt; E[v].size(); i ++)&#123; edge e = E[v][i]; if( cost[e.to] &gt; e.cost )&#123; cost[e.to] = e.cost; q.push(P(cost[e.to], e.to)); &#125; &#125; &#125; &#125; return res;&#125; 最大流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef struct node&#123; int to, cap, rev;&#125;edge;bool vis[101];vector &lt;edge &gt; G[101];int dfs(int v, int t, int f)&#123; if(v == t) return f; vis[v] = 1; for(int i = 0; i &lt; G[v].size(); i ++)&#123; edge e = G[v][i]; if( !vis[e.to] &amp;&amp; e.cap &gt; 0 )&#123; int d = dfs(e.to, t, min(f, e.cap)); if( d &gt; 0 )&#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125;&#125;int max_flow(int s, int t)&#123; int flow = 0; while(true)&#123; memset(vis, 0, sizeof(vis)); int f = dfs(s, t, INF); if( !f ) return flow; flow += f; &#125;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int from, to, s = 0, t = n + m + 1; for(int i = 1; i &lt;= m; i ++&#123; G[s].push_back(&#123;i, 1, G[i].size()&#125;); G[i].push_back(&#123;s, 0, G[s].size() - 1&#125;); &#125; for(int j = m + 1; j &lt;= n + m; j ++)&#123; G[j].push_back(&#123;t, 1, G[t].size()&#125;); G[t].push_back(&#123;j, 0, G[j].size() - 1&#125;); &#125; while ( scanf(\"%d%d\", &amp;from, &amp;to), from != -1)&#123; G[to].push_back(&#123;from, 1, G[from].size()&#125;); G[from].push_back(&#123;to, 0, G[to].size() - 1&#125;); &#125; cout &lt;&lt; max_flow(s, t) &lt;&lt; endl; return 0;&#125; 欧拉路和欧拉回路有向图 12345678inline void dfs(int x, int lst) &#123; register int &amp;i=lnk[x]; for(;i;i=e[i].nxt)&#123; if(vis[i]) continue; vis[i]=1,dfs(e[i].to,i); &#125; if(lst) res[++res_]=lst;&#125; 无向图 12345678inline void dfs(int x,int lst) &#123; register int &amp;i=lnk[x]; for(;i;i=e[i].nxt)&#123; if(vis[i+1&gt;&gt;1]) continue; vis[i+1&gt;&gt;1]=1,dfs(e[i].to,i&amp;1?(i+1&gt;&gt;1):-(i+1&gt;&gt;1)); &#125; if(lst) res[++res_]=lst;&#125; Dynamic Programming 动态规划LIS 最长上升子序列123456789101112void solve()&#123; memset(dp, 0, sizeof(dp)); int res = 0; for(int i = 0; i &lt; n; i ++)&#123; dp[i] = 1; for(int j = 0; j &lt; i; j ++) if( a[j] &lt; a[i] ) dp[i] = max (dp[i], dp[j] + 1); res = max (res, dp[i]); &#125; printf(\"%d\", res);&#125; 数划分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556571.问题描述： 给定一个正整数N和K 1. 将n划分成若干正整数之和的划分数。 2. 将n划分成k个正整数之和的划分数。 3. 将n划分成最大数不超过k的划分数。 4. 将n划分成若干奇正整数之和的划分数。 5. 将n划分成若干不同整数之和的划分数。2.问题分类：总的来说这些都是背包问题；第一个问：就是一个完全背包，物品有 1 --- N 种，第 i 种物品的重量为 i ，价值为 i dp[0] = 1; for (i = 1;i &lt;= N;i++) for (j = i;j &lt;= N;j++) dp[j] += dp[j-i];其中 dp[j] 是用前 i 个数能构成 j 的种类数，则结果就为 dp[N]看完这个问题了，那么 第3个问就知道了 ， 即用前 K 种物品所得结果，只需把第一层循环的 i &lt;= N 改为 i &lt;= K 即可； dp[0] = 1; for (i = 1;i &lt;= K;i++) for (j = i;j &lt;= N;j++) dp[j] += dp[j-i]; 结果同样为 dp[N] ;那么第四个问呢，想想是奇数，那么 i = 2，4，6，…… 等等值就不能取了，因为这些物品不合要求，这很简单啊 i++ 改为 i += 2 不就行了； dp[0] = 1; for (i = 1;i &lt;= N;i+=2) for (j = i;j &lt;= N;j++) dp[j] += dp[j-i]; 结果同样为 dp[N] ;再看看第五个问，若干个不同的就是一种物品最多只能用一次这是经典的 01背包 啊，与第一个问的不同就是第二层循环的顺序而已； dp[0] = 1; for (i = 1;i &lt;= N;i++) for (j = n;j &gt;= i ;j--) dp[j] += dp[j-i];最后我们来思考第二个问： 要求只要 K 个，这怎么办呢？？？想想特殊情况…… 如果 K = 1 呢，只能是 N 咯 若果 N = 0 呢， 结果只能是 0 中可能啊，那同样N &lt; K 的话，不可能分啊 结果为 0 那么我们再考虑，分的结果中有没有 1 ，如果有那么就把剩下的 N - 1 分成 K - 1 份 如果没有，那么我们先拿出 K 份给每一堆一个1，再把剩下的 N - K 分成 K 份就行了 int work(int n,int k)&#123; if (k == 1) return 1; if (n == 0) return 0; if (n &lt; k) return 0; return work(n-k,k) + work(n-1,k-1); &#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://edxuanlen.tk/tags/模板/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"Catch That Cow","slug":"Catch-That-Cow","date":"2018-03-31T12:17:43.000Z","updated":"2020-02-06T22:40:22.751Z","comments":true,"path":"2018/03/31/Catch-That-Cow/","link":"","permalink":"https://edxuanlen.tk/2018/03/31/Catch-That-Cow/","excerpt":"","text":"原题链接 题目内容 DescriptionYou are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides.Is an escape possible? If yes, how long will it take?InputThe input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).L is the number of levels making up the dungeon.R and C are the number of rows and columns making up the plan of each level.Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C.OutputEach maze generates one line of output. If it is possible to reach the exit, print a line of the formEscaped in x minute(s).where x is replaced by the shortest time it takes to escape.If it is not possible to escape, print the lineTrapped! Sample Input3 4 5S…..###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0 Sample OutputEscaped in 11 minute(s).Trapped! 题解: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;int L,R,C;char a[31][31][31];bool vis[31][31][31];int sx,sy,sz,ex,ey,ez;struct node&#123; int x,y,z,step;&#125;;int d[6][3]=&#123;&#123;0,0,1&#125;,&#123;0,0,-1&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;1,0,0&#125;,&#123;-1,0,0&#125;&#125;;int bfs()&#123; queue&lt;node&gt;q; node now,next; now.x=sx;now.y=sy;now.z=sz,now.step=0; vis[now.x][now.y][now.z]=true; q.push(now); while(!q.empty())&#123; now=q.front(); q.pop(); if(now.x==ex&amp;&amp;now.y==ey&amp;&amp;now.z==ez) return now.step; for(int i=0;i&lt;6;i++) &#123; next.x=now.x+d[i][0]; next.y=now.y+d[i][1]; next.z=now.z+d[i][2]; if(a[next.x][next.y][next.z]!='#'&amp;&amp;next.x&gt;=0&amp;&amp;next.x&lt;L&amp;&amp;next.y&gt;=0) if(next.y&lt;R&amp;&amp;next.z&gt;=0&amp;&amp;next.z&lt;C&amp;&amp;!vis[next.x][next.y][next.z])&#123; //分开写是因为太长了 比较难看=。= vis[next.x][next.y][next.z]++; next.step=now.step+1; q.push(next); &#125; &#125; &#125; return 0;&#125;int main() &#123; while(scanf(\"%d %d %d\",&amp;L,&amp;R,&amp;C),L)&#123; memset(a,'\\0',sizeof(a)); memset(vis,false,sizeof(vis)); for(int l=0;l&lt;L;l++)&#123; getchar(); for(int r=0;r&lt;R;r++)&#123; for(int c=0;c&lt;C;c++)&#123; a[l][r][c]=getchar(); if(a[l][r][c]=='S') &#123; sx=l; sy=r; sz=c; &#125; if(a[l][r][c]=='E')&#123; ex=l; ey=r; ez=c; &#125; &#125; getchar(); &#125; &#125; int ans=bfs(); if(ans) printf(\"Escaped in %d minute(s).\\n\",ans); else printf(\"Trapped!\\n\"); &#125; return 0;&#125; 已AC….by edxuanlen","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://edxuanlen.tk/tags/BFS/"},{"name":"STL","slug":"STL","permalink":"https://edxuanlen.tk/tags/STL/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"Linux_Communication","slug":"Linux_Communication","date":"2018-03-31T12:17:43.000Z","updated":"2020-02-06T22:40:22.753Z","comments":true,"path":"2018/03/31/Linux_Communication/","link":"","permalink":"https://edxuanlen.tk/2018/03/31/Linux_Communication/","excerpt":"","text":"使用信号信号在头文件signal.h中定义，信号都以SIG开头常用信号有 SIGALRM (由alarm函数设置的定时器产生) SIGHUP由一个处于非连接状态的终端发送给控制进程，或者由控制进程在自身结束时发送给每个前台进程 SIGINT一般由Ctrl+C或者预先设置好的终端字符产生 SIGPIPE如果向管道写数据时没有与之对应的读进程产生的信号 SIGTERM作为一个请求被发送，要求进程结束运行。(是KILL命令默认发送的信号) SIGUSR1,SIGUSR2进程之间可以用这个信号进行通信，例如让进程报告状态信息 信号处理–signal函数12345678910111213141516171819# include &lt;bits/stdc++.h&gt;# include &lt;unistd.h&gt;// 原型// void (*signal(int sig, void (*func)(int)))(int);void handle(int sign)&#123; //sign 是信号类型 signal(SIGINT, SIG_DFL); // 恢复终端中断信号的默认行为&#125;int main()&#123; //改变终端中断信号SIGINT的默认行为，使之执行handle函数 signal(SIGINT, handle); while (true)&#123; printf(\"i'm running\\n\"); sleep(1); &#125; return 0;&#125; 信号处理–sigaction函数1234567891011121314151617181920212223242526# include &lt;bits/stdc++.h&gt;# include &lt;unistd.h&gt;// 原型// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);# include &lt;bits/stdc++.h&gt;#include &lt;unistd.h&gt;void handle(int sign)&#123;&#125;int main()&#123; struct sigaction act; act.sa_handler = handle; // 创建空的信号屏蔽集，即不屏蔽任何信息 sigemptyset(&amp;act.sa_mask); // 使sigaction函数重置为默认行为 act.sa_flags = SA_RESETHAND; sigaction(SIGINT, &amp;act, 0); while (true)&#123; printf(\"i'm running\\n\"); sleep(1); &#125; return 0;&#125; 发送信号–kill &amp; alarm12345# include &lt;bits/stdc++.h&gt;using namespace std;// int kill (pid_t pid, int sig);// unsigned int alarm(unsigned int seconds); kill调用失败返回-1，调用失败通常有三大原因：给定的信号无效（errno = EINVAL)发送权限不够( errno = EPERM ）目标进程不存在( errno = ESRCH ) 使用信号量semget函数1234// 原型// int semget(key_t key, int num_sems, int sem_flags);// int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);// semctl","categories":[{"name":"系统","slug":"系统","permalink":"https://edxuanlen.tk/categories/系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://edxuanlen.tk/tags/Linux/"}],"keywords":[{"name":"系统","slug":"系统","permalink":"https://edxuanlen.tk/categories/系统/"}]},{"title":"Vscode","slug":"VSCode","date":"2018-03-31T12:17:43.000Z","updated":"2020-02-06T22:40:22.772Z","comments":true,"path":"2018/03/31/VSCode/","link":"","permalink":"https://edxuanlen.tk/2018/03/31/VSCode/","excerpt":"","text":"cmder123\"terminal.integrated.shell.windows\": \"cmd.exe\",\"terminal.integrated.env.windows\": &#123;\"CMDER_ROOT\": \"[cmder_root]\"&#125;,\"terminal.integrated.shellArgs.windows\": [\"/k\", \"[cmder_root]\\\\vendor\\\\init.bat\"] 插件们 code time 记录代码时间 Markdown PDF Markdown 转 PDF 格式 Markdown Preview Enhanced Markdown 同步视图 markdownline vscode-pdf vscode 内支持打开pdf Docker Docker !!! indenticator 回车自动缩进 MYSQL mysql management tool mysql-inline-decorator Add color coding to inline MYSQL string inside Git History \\ Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。 SVG Viewer \\ C/C++先是下载 MINGW 官网或者 choco 12","categories":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/categories/应用/"}],"tags":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/tags/应用/"}],"keywords":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/categories/应用/"}]},{"title":"choco","slug":"chocolatey","date":"2018-03-31T12:17:43.000Z","updated":"2020-02-06T22:40:22.773Z","comments":true,"path":"2018/03/31/chocolatey/","link":"","permalink":"https://edxuanlen.tk/2018/03/31/chocolatey/","excerpt":"","text":"choco更改默认文件夹设置path变量 ChocolateyInstall powershell1iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1')) cmd1@powershell -NoProfile -ExecutionPolicy Bypass -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin","categories":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/categories/应用/"}],"tags":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/tags/应用/"}],"keywords":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/categories/应用/"}]},{"title":"git 配置","slug":"git","date":"2018-03-31T12:17:43.000Z","updated":"2020-02-06T22:40:22.774Z","comments":true,"path":"2018/03/31/git/","link":"","permalink":"https://edxuanlen.tk/2018/03/31/git/","excerpt":"","text":"git 全局配置12git config --global user.name &quot;edxuanlen&quot;git config --global user.email &quot;edxuanlen@gmail.com&quot; git clone 选择分支git clone -b 分支名 https:// xxxxx 创建 git 仓库12345678git init# touch README.md# git add README.mdgit add ./git commit -m &quot;2019.5.6&quot;git remote add origin https://github.com/edxuanlen/coding.gitgit push -u origin master# git push -f (强行推送) 大文件传送git-lfs 123curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bashsudo apt-get install git-lfsgit lfs install 记住密码1git config credential.helper store","categories":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/categories/应用/"}],"tags":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/tags/应用/"}],"keywords":[{"name":"应用","slug":"应用","permalink":"https://edxuanlen.tk/categories/应用/"}]},{"title":"Mysql","slug":"mysql","date":"2018-03-31T12:17:43.000Z","updated":"2020-02-06T22:40:22.776Z","comments":true,"path":"2018/03/31/mysql/","link":"","permalink":"https://edxuanlen.tk/2018/03/31/mysql/","excerpt":"","text":"开启远程访问如果是docker上的镜像不需要 12345use mysql;select host,user from user;# Grant all privileges on *.* to 'root'@'%' identified by 'password' with grant option;# (%表示是所有的外部机器，如果指定某一台机，就将%改为相应的机器名；‘root’则是指要使用的用户名，里面的password需要自己修改成root的密码flush privileges; 支持中文1set names utf8; 查看comment注释1show full columns from table_name foreign key 外键12alter table 表名 add constraint FK_ID foreign key(你的外键字段名) REFERENCES 外表表名(对应的表的主键字段名);-- FK_ID 是外键名 mysql insert1insert into Stu values('col1','col2','col3'); mysql update1UPDATE table_name SET col1 = '', col2 = '' WHERE col3 = value; mysql 更改列1alter table table_name modify column_name data_type; mysql Check 实现一个限制插入年龄15-45的Check 12345678delimiter //create trigger AgeCheck before insert on Stufor each rowbeginif new.Age &lt; 15 or new.Age &gt; 45 thensignal sqlstate 'TX000' set message_text = \"Age limit is 15 to 45\";end if;end //","categories":[{"name":"SQL","slug":"SQL","permalink":"https://edxuanlen.tk/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://edxuanlen.tk/tags/SQL/"}],"keywords":[{"name":"SQL","slug":"SQL","permalink":"https://edxuanlen.tk/categories/SQL/"}]},{"title":"棋盘问题","slug":"棋盘问题","date":"2018-03-31T12:17:15.000Z","updated":"2020-02-06T22:40:22.799Z","comments":true,"path":"2018/03/31/棋盘问题/","link":"","permalink":"https://edxuanlen.tk/2018/03/31/棋盘问题/","excerpt":"","text":"原题链接 题目内容 Description在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。Input输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个nn的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。*Output**对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 Sample Input2 1#..#4 4…#..#..#..#...-1 -1 Sample Output21 题解: 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int n,k,cnt;char a[9][9];int vis[9]; void dfs(int r,int b)&#123; if(b==k) cnt++; for(int i=r;i&lt;n;i++) for(int j=0;j&lt;n;j++) //判断是否在棋盘中且同列是否已经存在棋子 if(a[i][j]=='#'&amp;&amp;!vis[j])&#123; vis[j]=1; dfs(i+1,b+1); vis[j]=0; &#125;&#125;int main()&#123; while(scanf(\"%d %d\",&amp;n,&amp;k),n!=-1)&#123; memset(a,0,sizeof(a)); getchar(); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++) a[i][j]=getchar(); getchar(); &#125; memset(vis,0,sizeof(vis)); cnt=0; dfs(0,0); cout&lt;&lt;cnt&lt;&lt;endl; &#125; return 0;&#125; 已AC….by edxuanlen","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://edxuanlen.tk/tags/DFS/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"全排列","slug":"全排列","date":"2018-03-30T05:18:06.000Z","updated":"2020-02-06T22:40:22.788Z","comments":true,"path":"2018/03/30/全排列/","link":"","permalink":"https://edxuanlen.tk/2018/03/30/全排列/","excerpt":"","text":"递归解全排列思想如下 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;char a[3]=&#123;'a','b','c'&#125;;int resove(int n)&#123; if(n==3)&#123; for(int i=0;i&lt;3;i++) cout&lt;&lt;a[i]; cout&lt;&lt;endl; return 0; &#125; for(int i=n;i&lt;3;i++)&#123; swap(a[n],a[i]); resove(n+1); swap(a[n],a[i]); &#125;&#125;int main()&#123; resove(0); return 0;&#125; 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;char a[3]=&#123;'a','b','a'&#125;;bool same(char *a,int n,int i)&#123; for(int j=n;j&lt;i;j++) if(a[j]==a[i]) return 1; return 0;&#125;int resove(int n)&#123; if(n==3)&#123; for(int i=0;i&lt;3;i++) cout&lt;&lt;a[i]; cout&lt;&lt;endl; return 0; &#125; for(int i=n;i&lt;3;i++)&#123; if(!same(a,n,i))&#123; swap(a[n],a[i]); resove(n+1); swap(a[n],a[i]); &#125; &#125;&#125;int main()&#123; resove(0); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://edxuanlen.tk/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://edxuanlen.tk/tags/递归/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"合并数字","slug":"合并数字","date":"2018-03-30T01:34:20.000Z","updated":"2020-02-06T22:40:22.793Z","comments":true,"path":"2018/03/30/合并数字/","link":"","permalink":"https://edxuanlen.tk/2018/03/30/合并数字/","excerpt":"","text":"题目链接!题目如下：蒜头君得到了 n 个数，他想对这些数进行下面这样的操作，选出最左边的相邻的差的绝对值为 11 的两个数，只保留较小的数，删去较大的数，直到没有两个相邻的差的绝对值为 1的数，问最多可以进行多少次这样的操作？输入格式：输入第一行为一个整数 n(1≤n≤105)，表示数字的总数。第二行为 n个整数 x1,x2,…,xn(0≤n≤109)x，表示这些数。 输出格式输出一行，为一个整数，表示蒜头君最多可以进行多少次这样的操作。样例输入41 2 0 1样例输出3 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m; scanf(\"%d\",&amp;n); stack&lt;int&gt;s; for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;m); while(!s.empty() &amp;&amp; s.top()-m == 1) s.pop(); if(!s.empty() &amp;&amp;m-s.top()!=1||s.empty()) s.push(m); &#125; printf(\"%d\",n-s.size()); return 0;&#125; 输出结果:","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://edxuanlen.tk/tags/栈/"},{"name":"C/C++题目","slug":"C-C-题目","permalink":"https://edxuanlen.tk/tags/C-C-题目/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"STL之stack&queue","slug":"STL之stack-queue","date":"2018-03-29T16:47:44.000Z","updated":"2020-02-06T22:40:22.764Z","comments":true,"path":"2018/03/30/STL之stack-queue/","link":"","permalink":"https://edxuanlen.tk/2018/03/30/STL之stack-queue/","excerpt":"","text":"栈(stack)stack堆栈是一个后进先出的线性表插入和删除元素都只能在表的一端进行。插入元素的一端称为栈顶(另一端称为栈底)。插入元素为入栈(Push)，删除为出栈(Pop)。 过程就像压入和弹出数据。 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; stack&lt;int&gt; s; //压入数据 s.push(1); s.push(2); s.push(4); s.push(5); cout &lt;&lt; s.size() &lt;&lt; endl; while(s.empty() != true)&#123; cout &lt;&lt; s.top() &lt;&lt; endl; s.pop();//弹出数据 &#125; return 0;&#125; 输出: 45 4 2 1 队列(queue)queue队列容器是一个先进先出的线性存储表，元素插入只能在队尾，删除只能在队首。将上面的代码 stack改为queue ，s.top改为s.front 可得到： 41 2 4 5 优先队列(priority_queue)priority_queue与队列一样只能在队尾插入元素，队首删除元素，但是队首永远是队列中的最大元素。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; priority_queue&lt;int&gt; pq; pq.push(1); pq.push(3); pq.push(2); pq.push(8); pq.push(9); pq.push(0); cout &lt;&lt; \"size: \" &lt;&lt; pq.size() &lt;&lt; endl; while(pq.empty() != true)&#123; cout &lt;&lt; pq.top() &lt;&lt;\" \"; pq.pop(); &#125; return 0;&#125; 运行结果： set和priority_queue的重载set的重载set的重载与sort函数的重载相似。 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;struct Comp&#123; bool operator()(int a,int b) &#123; return a &gt; b; &#125;&#125;;int main()&#123; set&lt;int,Comp&gt; v; v.insert(1); v.insert(3); v.insert(5); v.insert(2); v.insert(4); v.insert(3); for(set&lt;int,Comp&gt;::iterator it = v.begin(); it != v.end(); ++it) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; for(set&lt;int,Comp&gt;::reverse_iterator rit = v.rbegin(); rit != v.rend(); ++rit) cout &lt;&lt; *rit &lt;&lt; \" \"; cout &lt;&lt; endl; return 0;&#125; 输出结果为： 5 4 3 2 11 2 3 4 5 priority_queue的重载priority_queue的重载与set的重载差不多，但中间需要一个多一个容器作为参数(暂时我也不知道为啥==)。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;//重载struct C&#123; bool operator()(int a,int b)&#123; return a&gt;b; &#125;&#125; ;int main()&#123; priority_queue&lt;int,vector&lt;int&gt;,C&gt; pq; //少了vector报错 pq.push(1); pq.push(3); pq.push(2); pq.push(8); pq.push(9); pq.push(0); cout &lt;&lt; \"size: \" &lt;&lt; pq.size() &lt;&lt; endl; while(pq.empty() != true)&#123; cout &lt;&lt; pq.top() &lt;&lt;\" \"; pq.pop(); &#125; return 0;&#125; 数据与上面优先队列的例子相同，重载后输出结果为:","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://edxuanlen.tk/tags/STL/"},{"name":"栈","slug":"栈","permalink":"https://edxuanlen.tk/tags/栈/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"STL之list","slug":"STL之list","date":"2018-03-29T10:37:29.000Z","updated":"2020-02-06T22:40:22.756Z","comments":true,"path":"2018/03/29/STL之list/","link":"","permalink":"https://edxuanlen.tk/2018/03/29/STL之list/","excerpt":"","text":"listlist的插入，遍历，删除，查找，排序都与vector容器相似。下面直接在实例中展示。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; list&lt;int&gt;l,l1; for(int i=0;i&lt;3;i++) l1.push_back(i*i); l.push_back(3); l.push_front(1); l.insert(++l.begin(),2); //list 的迭代器只能++--不能+n-n l.insert(l.end(),l1.begin(),l1.end()); // 正向遍历 for(list&lt;int&gt;::iterator i=l.begin();i!=l.end();i++) cout&lt;&lt;*i&lt;&lt;\" \"; cout&lt;&lt;endl; // 反向遍历 for(list&lt;int&gt;::reverse_iterator i=l.rbegin();i!=l.rend();i++) cout&lt;&lt;*i&lt;&lt;\" \"; cout&lt;&lt;endl; // 排序&amp;去重 l.sort(); l.unique(); for(list&lt;int&gt;::iterator i=l.begin();i!=l.end();i++) cout&lt;&lt;*i&lt;&lt;\" \"; cout&lt;&lt;endl; //查找元素以及删除迭代器位置的元素 l.erase(find(l.begin(),l.end(),4)); for(list&lt;int&gt;::iterator i=l.begin();i!=l.end();i++) cout&lt;&lt;*i&lt;&lt;\" \"; cout&lt;&lt;endl; srand(time(0)); // pop首、尾的弹出 for(int i=0;i&lt;4;i++)&#123; if(i%2) l.pop_back(); else l.pop_front(); for(list&lt;int&gt;::iterator i=l.begin();i!=l.end();i++) cout&lt;&lt;*i&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; return 0; &#125; 运行结果： 主要注意点是list的迭代器只能用++ – 到达想要的位置","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://edxuanlen.tk/tags/STL/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"STL之map","slug":"STL之map","date":"2018-03-29T04:01:49.000Z","updated":"2020-02-06T22:40:22.757Z","comments":true,"path":"2018/03/29/STL之map/","link":"","permalink":"https://edxuanlen.tk/2018/03/29/STL之map/","excerpt":"","text":"map映照容器 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; map&lt;string,double&gt;m; m[\"li\"]=123.4; m[\"wang\"]=23.1; m[\"zhang\"]=-21.9; m[\"abc\"]=12.1; for(map&lt;string,double&gt;::iterator i=m.begin();i!=m.end();i++) cout&lt;&lt;(*i).first&lt;&lt;\":\"&lt;&lt;(*i).second&lt;&lt;endl; return 0; &#125; 运行结果： map实现数字分离string-&gt;number下面给出例子，可以实现超级大数的每位相加！！！ 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; map&lt;char,int&gt; m; for(int i = 0; i &lt; 10; ++i) m['0' + i] = i; string s; s = \"9876543210123456789876543210123456789\"; int sum = 0; for( int i = 0; i &lt; s.size(); ++i) sum += m[s[i]]; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 运行结果： 171 number-&gt;string与上面的转换原理相同。 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; map&lt;long long int,char&gt; m; long long i; for(i = 0; i &lt; 10; ++i)&#123; m[i] = &apos;0&apos; + i; &#125; long long n[10] =&#123;1,2,3,4,5,6,7,8,9,0&#125;; for(int i=0;i&lt;10;i++) cout &lt;&lt;m[n[i]] ; return 0;&#125; 运行结果： 1234567890 multimapmultimap与map的关系和multiset与set的关系相同，允许重复的元素，所以元素的插入删除和查找都与map不同。 multimap&lt;string,double&gt; m; m.insert(pair&lt;string,double&gt;(“Abc”,123.2));上述插入方法同样适用于map。 find &amp; erase在上面的代码加上C++ printf(&quot;%d&quot;,m.find(&#39;5&#39;)-&gt;second);可以得到‘5’对应的数字 5。 C++ m.erase(&quot;1&quot;);会使这一个map删除。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://edxuanlen.tk/tags/STL/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"STL之sort和unique","slug":"STL之sort和unique","date":"2018-03-28T15:39:29.000Z","updated":"2020-02-06T22:40:22.763Z","comments":true,"path":"2018/03/28/STL之sort和unique/","link":"","permalink":"https://edxuanlen.tk/2018/03/28/STL之sort和unique/","excerpt":"","text":"123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt; using namespace std;bool hh(int a,int b)&#123; //改sort规则为降序 return a&gt;b;&#125;int main()&#123; int a[13]=&#123;1,3,6,6,8,5,7,4,9,4,2,3&#125;; int i; for(i=0;i&lt;12;i++) printf(\"%d \",a[i]); printf(\"\\nafter sort:\"); sort(a,a+12); //默认升序 for(i=0;i&lt;12;i++) printf(\"%d \",a[i]); printf(\"\\nafter sort:\"); sort(a,a+12,hh); for(i=0;i&lt;12;i++) printf(\"%d \",a[i]); printf(\"\\nafter unique:\"); int ans=unique(a,a+12)-a; for(i=0;i&lt;ans;i++) printf(\"%d \",a[i]); return 0;&#125; 运行结果:","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://edxuanlen.tk/tags/STL/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"STL之set","slug":"STL之set","date":"2018-03-28T14:48:14.000Z","updated":"2020-02-06T22:40:22.760Z","comments":true,"path":"2018/03/28/STL之set/","link":"","permalink":"https://edxuanlen.tk/2018/03/28/STL之set/","excerpt":"","text":"set容器set是用红黑树的平衡二叉索引树的数据结构来实现的，插入时，它会自动调节二叉树排列，把元素放到适合的位置，确保每个子树根节点的键值大于左子树所有的值、小于右子树所有的值，插入重复数据时会忽略。set迭代器采用中序遍历，检索效率高于vector、deque、list，并且会将元素按照升序的序列遍历。set容器中的数值，一经更改，set会根据新值旋转二叉树，以保证平衡，构建set就是为了快速检索（python中的set一旦建立就是一个常量，不能改的）。multiset，与set不同之处就是它允许有重复的键值。 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; set&lt;int&gt;s; srand(time(NULL)); //生成随机数种子 for(int i=0;i&lt;10;i++) s.insert(rand()%10); for(set&lt;int&gt;::iterator i=s.begin();i!=s.end();i++) printf(\"%d \",*i); cout&lt;&lt;endl; for(set&lt;int&gt;::reverse_iterator i=s.rbegin();i!=s.rend();i++) printf(\"%d \",*i); return 0;&#125; 运行结果： 由于重复的被删去，所以可能输出不够十个数。而用上面把set改成上面提及的multiset就可以支持重复数字。 在上面set的代码将set改为multiset即可。 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; multiset&lt;int&gt;s; srand(time(NULL)); //生成随机数种子 for(int i=0;i&lt;10;i++) s.insert(rand()%10); for(multiset&lt;int&gt;::iterator i=s.begin();i!=s.end();i++) printf(\"%d \",*i); cout&lt;&lt;endl; int a=rand()%10; cout&lt;&lt;\"delete the num as :\"&lt;&lt;a&lt;&lt;endl; int h=s.erase(a); //multiset的erase函数删除所有要删除的数并返回个数 cout&lt;&lt;\"delete \"&lt;&lt;h&lt;&lt;\" \"&lt;&lt;\"\\\"\"&lt;&lt;a&lt;&lt;\"\\\"\"&lt;&lt;endl; cout&lt;&lt;\"after delete \"&lt;&lt;a&lt;&lt;\":\"; for(multiset&lt;int&gt;::reverse_iterator i=s.rbegin();i!=s.rend();i++) printf(\"%d \",*i); return 0;&#125; 运行结果: set的重载重载可改变排序依据。set的重载会与priority_queue放一起比较，详情点此跳转！","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://edxuanlen.tk/tags/STL/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"STL之string","slug":"STL之string","date":"2018-03-28T03:33:20.000Z","updated":"2020-02-06T22:40:22.766Z","comments":true,"path":"2018/03/28/STL之string/","link":"","permalink":"https://edxuanlen.tk/2018/03/28/STL之string/","excerpt":"","text":"string的insert、erase和clear1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s;char ss[1000]; gets(ss);//无法直接gets string s=ss; //尾部添加字符字符串直接用+号 或者使用append() s+=\" wo\"; s.append(\"rld!\"); cout&lt;&lt;\"insert添加后: \"&lt;&lt;s&lt;&lt;endl; string::iterator i=s.begin(); s.erase(s.begin()+5,i+12); cout&lt;&lt;\"erase删除后: \"&lt;&lt;s&lt;&lt;endl; s.clear(); cout&lt;&lt;\"clear后:\"&lt;&lt;s; return 0;&#125; string的find1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s=\"what are you dong\"; string s1=\"are \"; if(s.find(s1)&lt;0) //找不到返回-1 cout&lt;&lt;\"not find\"&lt;&lt;endl; else //找到返回位置 cout&lt;&lt;\"position= \"&lt;&lt;s.find(s1)+1&lt;&lt;endl; return 0; &#125; 运行结果 position= 6 string数字处理c++11标准增加了全局函数std::to_string: 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;void StrToInt()&#123; string s=\"87654321\"; int a=stoi(s); printf(\"%d\\n\",a);&#125; void IntToStr()&#123; int a=12345678; string s; s=to_string(a); cout&lt;&lt;s&lt;&lt;endl;&#125;int main()&#123; StrToInt(); IntToStr(); return 0;&#125; 运行结果 8765432112345678 sscanf分离123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a,b,c; char s[6]=\"4,5$6\"; sscanf(s,\"%d,%d$%d\",&amp;a,&amp;b,&amp;c); cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; \" \" &lt;&lt; c &lt;&lt; endl; return 0;&#125; 运行结果: 4 5 6","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://edxuanlen.tk/tags/STL/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"STL之vector","slug":"STL之vector","date":"2018-03-28T02:21:06.000Z","updated":"2020-02-06T22:40:22.768Z","comments":true,"path":"2018/03/28/STL之vector/","link":"","permalink":"https://edxuanlen.tk/2018/03/28/STL之vector/","excerpt":"","text":"vector之insert、erasevector有内存管理的机制，也就是说对于插入和删除，vector可以动态调整所占用的内存空间。常用相关函数insert、erase如下： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; for(int i=0;i&lt;10;i++) v.push_back(i); //在数组尾部插入数字 vector&lt;int&gt; a(10); for(int i=0;i&lt;10;i++) a[i]=10-i; printf(\"a[i] v[i]\\n\"); for(int i=0;i&lt;10;i++) printf(\"%2d %2d\\n\",a[i],v[i]); //在第一个元素之前插入111 insert begin+n是在第n个元素之前插入 v.insert(v.begin()+5,10); v.insert(v.end()-5,10); printf(\"insert 插入v[i]后: \"); //iterator迭代器 for(vector&lt;int&gt;::iterator i=v.begin();i&lt;v.end();i++) printf(\"%d \",*i); //在最后一个元素之后插入222 insert end + n 是在n个元素之后插入 printf(\"\\nerase 删除单个数字后: \"); a.erase(a.begin()+4); for(vector&lt;int&gt;::iterator i=a.begin();i&lt;a.end();i++) printf(\"%d \",*i); printf(\"\\nerase 删除范围数字后: \"); a.erase(a.begin(),a.begin()+4);//删除这一范围内的数字 for(vector&lt;int&gt;::iterator i=a.begin();i&lt;a.end();i++) printf(\"%d \",*i); return 0;&#125; 运行截图如下: vector之push_back、back、reverse、size123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main ()&#123; vector&lt;int&gt; a; int sum (0); for (int i=0;i&lt;10;i++) a.push_back(i); //结尾压入数据 printf(\"%d\\n\",a.size()); reverse(a.begin(),a.end()); for (int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; cout&lt;&lt;endl; while (!a.empty())&#123; sum += a.back(); a.pop_back(); //弹出最后压入的数据 (不受reverse影响) printf(\"%d \",a.size()); &#125; printf(\"\\n%d\\n\",a.size()); cout &lt;&lt; \"total: \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125; 运行结果 求和accumulate123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; for(int i = 0; i &lt; 10; ++i ) v.push_back(i); cout &lt;&lt; accumulate(v.begin(),v.end(),0) &lt;&lt; endl; return 0;&#125; 运行结果 45","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://edxuanlen.tk/tags/STL/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"最长公共子串LCS","slug":"最长公共子串LCS","date":"2018-03-27T00:36:12.000Z","updated":"2020-02-06T22:40:22.795Z","comments":true,"path":"2018/03/27/最长公共子串LCS/","link":"","permalink":"https://edxuanlen.tk/2018/03/27/最长公共子串LCS/","excerpt":"","text":"算法思路我们首先想到的肯定是暴力枚举法。先来看看：假设序列A有n 个元素，序列B有 m 个元素，那么A，B分别有2^n，2^m个子序列，如果任意两个子序列一一比较，比较的的子序列高达2^(m+n)对，这还没有算具体的复杂度。所以我们可以试试动态规划，把这个问题分解成子问题：求A的前i个元素和B的前j个元素之间的最长公共子序列长度。这时的空间复杂度为O(m+n)。算法思想 定义dp [i][j]：表示字符串序列A的前i个字符组成的序列Ax和字符串序列B的前j个字符组成的序列By之间的最长公共子序列L(i,j )的长度（m ，n分别为Ax和By的长度，i&lt;=m,j&lt;=n） 如果Ax [i] =By [j]，那么Ax与By之间的最长公共子序列L( i,j )的最后一项一定是这个元素，所以dp [i][j] = dp[i-1][j-1] + 1。 如果Ax[i] != By[j]，设LCS（i-1,j-1)是L( i -1, j-1 )的最后一个元素，或者L（i-1,j-1）是空序列，则 t!= Ax[i]和t!=By[j]至少有一个不成立。 (1). 当 LCS（i-1,j-1) != Ax[i] 时，dp[i][j]= dp[i-1][j]； (2). 当 LCS（i-1,j-1) != By[j] 时，ap[i][j]= dp[i][j-1]；所以dp[i][j]= max ( dp[i-1][j]，dp[i][j-1] )。 初始值为：dp[0][j] = dp[i][0] = 0. 题意要求求出任意一个最长公共子序列，这点要如何实现呢？仍然考虑上面的递推式，L（i,j）的最后一个元素LCS( i，j )的来源有三种情况，定义数组flag[MAXN][MAXN]用以标记来的方向：(1). dp[i][j] = dp[i-1][j-1] + 1，对应字符LCS( i-1,j-1)接上LCS( i,j)，flag[i][j] = 1,表示从斜向上左方来；(2). dp[i][j] = dp[i-1][j]，对应字符LCS（i-1,j）接上LCS（i,j），flag[i][j] = 2,表示从/上方过来；(3). dp[i][j] = dp[i][j-1]，对应字符LCS（I,j-1）接上LCS（i,j），flag[i][j] = 3,表示从左方过来。 我们只要在计算dp[i][j]时根据来源进行不同的标记，回溯就可以找到一个最长公共子序列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;char a[500],b[500];int lcs[501][501]; ///记录中间结果的数组int flag[501][501]; ///标记数组，用于标识下标的走向，构造出公共子序列void LCS()&#123; ///动态规划求解 int i,j; for(i=1;i&lt;=strlen(a);i++) for(j=1;j&lt;=strlen(b);j++) if(a[i-1]==b[j-1])&#123; lcs[i][j]=lcs[i-1][j-1]+1; flag[i][j]=1; ///斜向下标记 &#125; else if(lcs[i][j-1]&gt;lcs[i-1][j]) &#123; lcs[i][j]=lcs[i][j-1]; flag[i][j]=2; ///向右标记 &#125; else &#123; lcs[i][j]=lcs[i-1][j]; flag[i][j]=3; ///向下标记 &#125;&#125;void getLCS()&#123;///采用倒推方式求最长公共子序列 char res[500]; int i=strlen(a); int j=strlen(b); int k=0; ///用于保存结果的数组标志位 while(i&gt;0 &amp;&amp; j&gt;0)&#123; if(flag[i][j]==1)&#123; ///如果是斜向下标记 res[k]=a[--i]; k++; j--; &#125; else if(flag[i][j]==2) ///如果是向右标记 j--; else if(flag[i][j]==3) ///如果是向下标记 i--; &#125; for(i=k-1;i&gt;=0;i--) printf(\"%c\",res[i]);&#125;int main()&#123; int i; strcpy(a,\"ABCBDAB\"); strcpy(b,\"BDCABA\"); memset(lcs,0,sizeof(lcs)); memset(flag,0,sizeof(flag)); LCS(); printf(\"%d\\n\",lcs[strlen(a)][strlen(b)]); getLCS(); return 0;&#125; 运行结果:","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://edxuanlen.tk/tags/动态规划/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"最长递增序列LIS(n^2和nlog2n)","slug":"最长递增序列LIS(n^2和nlog2n)","date":"2018-03-26T16:33:00.000Z","updated":"2020-02-06T22:40:22.798Z","comments":true,"path":"2018/03/27/最长递增序列LIS(n^2和nlog2n)/","link":"","permalink":"https://edxuanlen.tk/2018/03/27/最长递增序列LIS(n^2和nlog2n)/","excerpt":"","text":"例题： LIS是最长上升子序列。什么是最长上升子序列？就是给你一个序列，请你在其中求出一段最长严格上升的部分，它不一定要连续。就像这样：2, 3, 4, 7 和 2, 3, 4, 6就是序列 2 5 3 4 1 7 6 的两个上升子序列，最长的长度是 4。 O(n2)的方法:对于每一个数，他都是在“可以接下去”的中，从前面的最优值+1转移而来。 代码示例如下： 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int f[10000], b[10000];int lis(int n) &#123; memset(f, 0, sizeof f); int res = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) if (b[j] &lt; b[i]) &#123; f[i]=max(f[i],f[j]+1); res = max(res, f[i]); &#125; return res+1;&#125;int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d\", b + i); &#125; printf(\"%d\\n\", lis(n)); return 0;&#125; O(nlog2n)的方法:我们回想一下，在上面O(n2)的程序中，哪些地方看起来比较费时？没错，就是内层用于更新i的循环。因为每一次他都要查找一遍，效率并不高。回到题目，我们发现，他只要我们求长度，所以，我们可以模拟一个栈。所以每遇到一个比栈顶元素大的数，就放进栈里，遇到比栈顶元素小的就二分查找前边的元素，找到一个“最应该被换掉的元素”，用新数去更新前边的元素。这个算法不难证明也是正确的。因为前面每一次的枚举都换成了二分，内层的复杂度从n降到了log2n，外层不变。所以总的复杂度是O(nlog2n)。lis代码: 123456789101112131415161718int lis(int n) &#123; f[0]=b[0]; int len=0; for(int i=1;i&lt;n;i++) &#123; if(b[i]&gt;f[len]) f[++len]=b[i]; else &#123; int j=lower_bound(f,f+len,b[i])-f; f[j]=b[i]; // for(int k=0;k&lt;len;k++) // printf(\"%d \",f[k]); &#125; // printf(\"\\n\"); &#125; return len+1; &#125; 注释的代码是为了更好的理解这个算法。","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://edxuanlen.tk/tags/动态规划/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"HTML","slug":"HTML","date":"2018-03-23T06:04:56.000Z","updated":"2020-02-06T22:40:22.752Z","comments":true,"path":"2018/03/23/HTML/","link":"","permalink":"https://edxuanlen.tk/2018/03/23/HTML/","excerpt":"","text":"HTML 段落12345678910111213141516171819202122231. 分六个等级的字体(h1-h6)2. 换行&lt;br&gt;(line break)3. 水平线&lt;hr&gt;(horizontal rule)4. 字体特性设定&lt;font&gt;&lt;/font&gt;: 字体大小size; 字体颜色color; 字体名称face 如&lt;font face=标楷体&gt; 标楷体&lt;/font&gt; 5. 文本格式化： &lt;b&gt;&lt;strong&gt;定义粗体字体 &lt;em&gt; 定义着重文字 &lt;i&gt;&lt;em&gt;定义斜体字 &lt;small&gt;、&lt;big&gt;定义小、大号字 &lt;sub&gt; &lt;sup&gt;上下标 &lt;ins&gt;&lt;del&gt;定义插入字、删除字 &lt;abbr&gt;&lt;acronym&gt;定义缩写、定义地址 &lt;bdo&gt;定义文字方向 如&lt;p&gt;&lt;bdo dir=\"rtl\" &lt;blockquote&gt;定义长的引用 &lt;q&gt;短的引用定义 &lt;address&gt;定义地址 &lt;cite&gt;定义引用、引证 HTML 列表123456789101112131415161. 无序列表ul： &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Mile&lt;/li&gt; &lt;/ul&gt;2. 有序列表ol： &lt;ol type=\"a\"/\"A\"/\"Ⅰ\"/\"1\"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Mile&lt;/li&gt; &lt;/ol&gt; 3. 定义列表dl: &lt;dt&gt;标题 &lt;dd&gt;内容列表可嵌套 HTML 超链接123451. href=\"\": 链接地址2. 标签间可以为文字描绘或图片3. target: 打开位置 ex:_top、_blank、_self、_parent4. 定义位置&lt;a id=\"\"&gt;&lt;/a&gt;5. iflame 独立模块 HTML 图像12341. &lt;img&gt;定义图像(包含属性，并且灭有闭合标签)2. src源属性: &lt;img src=\"\"&gt;3. alt替代文本属性: 如:&lt;img src=\"\" alt=\"属性文本\"&gt;4. height、width、border属性 HTMl 多媒体121. 音乐播放器： &lt;audio src=\"\" controls=\"controls\" /*循环：loop*/&gt;不显示提示&lt;/audio&gt;2. 视频播放器: &lt;video source&gt; 多个格式播放 HTML 表格(table)11. rowspan 无语义元素 div模块 span span更改文段中某一小段文字的属性。 语义元素 header section article nav aside footer 微格式 T规定时间分隔符 TZD时区标识符 元素类型 date month week time datetime_local email search tel url 其他表单元素：select option optgroup textarea","categories":[{"name":"HTML","slug":"HTML","permalink":"https://edxuanlen.tk/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://edxuanlen.tk/tags/HTML/"}],"keywords":[{"name":"HTML","slug":"HTML","permalink":"https://edxuanlen.tk/categories/HTML/"}]},{"title":"网站搭建","slug":"网站","date":"2018-03-20T05:18:37.000Z","updated":"2020-02-06T22:40:22.802Z","comments":true,"path":"2018/03/20/网站/","link":"","permalink":"https://edxuanlen.tk/2018/03/20/网站/","excerpt":"","text":"MySQL的坑 新版本安装无提示设 root 用户密码。 12sudo mysql -u root --skip-passwordmysql &gt; alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;xxxxxxxxx&apos;; // xx is new password 忘了 root 密码先find mysql 的 .cnf 配置文件找到[mysqld] 的下一行写入 1234skip -grant -tablesmysqlmysql &gt; alter ....mysql &gt; flush privaileges; 记得要重启mysql服务 Apache2的坑 开多端口多路径 ports.conf 文件中添加 “Listen + 端口号”。sites-availabe/000-default-conf文件中添加如下代码 1234567&lt;VirtualHost *:61212&gt; ServerAdmin webmaster@localhost:61212 DocumentRoot /home/edxuanlen/Documents/ftp ServerName localhost ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined&lt;/VirtualHost&gt; apache2.conf 文件中加入 12345&lt;Directory /home/edxuanlen/Documents/ftp &gt; Options Indexes FollowSymLinks AllowOverride None Require all granted&lt;/Directory&gt; service apache2 restart Phpstorm 的使用 提示mysqli为定义类，其实是因为没有下载 php-mysql 这个文件 1apt-get install php-mysql 端口问题，一直无法通过浏览器显示。报cgi错误。 1apt-get install php7.2-cgi Php 的使用 php-bcmathphp-mysqlilibapache2-mod-php7","categories":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/categories/网站/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/tags/网站/"}],"keywords":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/categories/网站/"}]},{"title":"背包","slug":"背包","date":"2018-03-20T05:18:37.000Z","updated":"2020-02-06T22:40:22.802Z","comments":true,"path":"2018/03/20/背包/","link":"","permalink":"https://edxuanlen.tk/2018/03/20/背包/","excerpt":"","text":"题目大意有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 状态转化方程 dp[i][j]=max[dp[i-1][j],a[i-1][j-w[i]]+v[i]] 一维解法12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5000*2+5;int f[maxn],n,m,w,v;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); memset(f,0,sizeof f); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d%d\",&amp;w,&amp;v); for(int j=m;j&gt;=w;j--) f[j]=max(f[j],f[j-w]+v); for(int i=1;i&lt;=m;i++)printf(\"%d \",f[i]); &#125; printf(\"%d\\n\",f[m]); return 0;&#125; 二维解法1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int a[201][5001];int main()&#123; int n,m,i,j; int w[201],v[201]; scanf(\"%d%d\",&amp;n,&amp;m); memset(a,0,sizeof(a)); for(i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;w[i],&amp;v[i]); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) if(j&gt;=w[i]) a[i][j]=max(a[i-1][j],a[i-1][j-w[i]]+v[i]); else a[i][j]=a[i-1][j]; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) cout&lt;&lt;a[i][j]&lt;&lt;' '; cout&lt;&lt;endl; &#125; printf(\"%d\",a[i-1][j-1]); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://edxuanlen.tk/tags/动态规划/"}],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"https://edxuanlen.tk/categories/C-C/"}]},{"title":"hexo_Bluelake主题","slug":"hexo-Bluelake主题","date":"2018-01-24T12:52:30.000Z","updated":"2020-02-06T22:40:22.775Z","comments":true,"path":"2018/01/24/hexo-Bluelake主题/","link":"","permalink":"https://edxuanlen.tk/2018/01/24/hexo-Bluelake主题/","excerpt":"","text":"开始之前 在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。 安装 您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。1.1 安装主题 在根目录下打开终端窗口：git bash $ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2 安装主题渲染器 BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。git bash $ npm install hexo-renderer-jade@0.3.0 –save$ npm install hexo-renderer-stylus –save 1.3 启用主题 打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。根_config.yml_config.yml theme: BlueLake 1.4 验证 首先启动 Hexo 本地站点，并开启调试模式：git bash $ hexo s –debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。1.5 更新主题 今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。git bash cd themes/BlueLakegit pull 配置 1 配置网站头部显示文字 打开根_config.yml，找到：根_config.yml_config.yml title:subtitle:description:author: title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。2.2 设置语言 该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：根_config.yml_config.yml language: zh-CN 2.3 设置菜单 打开主题_config.yml，找到：主题_config.ymlthemes/BlueLake/_config.yml menu: page: homedirectory: .icon: fa-home page: archivedirectory: archives/icon: fa-archive- page: aboutdirectory: about/icon: fa-user page: rssdirectory: atom.xmlicon: fa-rss 主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好：主题_config.ymlthemes/BlueLake/_config.yml About pageabout: email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 github_url: ## github主页链接地址 2.3.1 添加about页 此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：git bash $ hexo new page ‘about’ 打开主题_config.yml，补全关于我页面的详细信息：主题_config.ymlthemes/BlueLake/_config.y About pageabout: photo_url: ## 头像的链接地址 email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 weibo_name: ## 微博用户名 github_url: ## github主页链接地址 github_name: ## github用户名 当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件 在根目录下打开命令行窗口：git bash $ npm install hexo-generator-feed –save$ npm install hexo-generator-sitemap –save$ npm install hexo-generator-baidu-sitemap –save 添加主题_config.yml配置：主题_config.ymlthemes/BlueLake/_config.yml Plugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 2.4 添加本地搜索 默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件：git bash $ npm install hexo-generator-json-content@2.2.0 –save 然后在根_config.yml添加配置：根_config.yml_config.yml jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置：主题_config.ymlthemes/BlueLake/_config.yml local_search: true 2.5 修改站点图标 站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。(有很多网站都可以在线生成ico格式的图片。)2.6 添加站点关键字 请在hexo目录的根_config.yml中添加keywords字段，如：根_config.yml_config.yml Sitetitle: Hexosubtitle: 副标题description: 网站简要描述,如：Charles·Zheng’s blog.keywords: 网站关键字, key, key1, key2, key3author: Charleslanguage: zh-CN 2.7 其他配置 主题_config.yml的其他配置 show_category_count——是否显示分类下的文章数。 widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。 主题_config.yml themes/BlueLake/_config.yml show_category_count: true widgets_on_small_screens: true3.集成第三方服务3.1 添加评论 目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了，在国内目前网易云跟帖和畅言还不错。 注册并获得代码。 若使用多说评论，注册多说后获得short_name。 若使用Disqus评论，注册Disqus后获得short_name。 若使用来必力评论，注册来必力,获得data-uid。 若使用友言评论，注册友言,获得uid。 若使用网易云跟帖评论，注册网易云跟帖,获得productKey。 若使用畅言评论，注册畅言，获得appid，appkey。 配置主题_config.yml： 主题_config.yml themes/BlueLake/_config.yml #Cmments comment: duoshuo: ## duoshuo_shortname disqus: ## disqus_shortname livere: ## 来必力(data-uid) uyan: ## 友言(uid) cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: ## 畅言(appid) appkey: ##畅言(appkey)3.2 百度统计 登录百度统计，定位到站点的代码获取页面。 复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000) 配置主题_config.yml: 主题_config.yml themes/BlueLake/_config.yml baidu_analytics: 8006843039519956000 注意： baidu_analytics不是你的百度id或者百度统计id 如若使用谷歌统计，配置方法与百度统计类似。3.3 卜算子阅读次数统计主题_config.ymlthemes/BlueLake/_config.yml busuanzi: true 若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。3.4 微博秀 微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。 登录微博开放平台，选择微博秀。 为了与主题风格统一，作如下配置 基础设置：高400px；勾选宽度自适应；颜色选择白色； 样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8； 模块设置：去掉标题、边框、粉丝的勾选框，只留微博。 复制代码里src=&quot;&quot;里引号包裹的内容，替换到layout/_widget/weibo.jade weibo.jade layout/_widget/weibo.jade .widget .widget-title i(class=&apos;fa fa-weibo&apos;)= &apos; &apos; + __(&apos;新浪微博&apos;) iframe(width=&quot;100%&quot;,height=&quot;400&quot;,class=&quot;share_self&quot;,frameborder=&quot;0&quot;,scrolling=&quot;no&quot;,src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1&quot;) 这只是为了和主题的风格统一，当然您也可以自由随意发挥。 注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。转载: https://chaooo.github.io/ 后面来补充一下遇到的问题，about界面的图片应该怎么放置： 在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。 我在themes/source下找到的img 文件夹 有bg的图片 灵机一动加在了这个img里，在git编辑themes的主题config的时候成功的调用。 /img/调用图片名 （例如 头像.jpg） 即可 2. 使用图床： https://sm.ms/ 然后再用url进行调用！ 3. 文章内如何调用图片： 前提：修改_config.yml配置文件post_asset_folder项为true。 创建博客是使用命令创建： hexo new [layout] &lt;title&gt; 其中的layout项可以省略，例如： hexo new &quot;这是一个新的博客&quot; 使用完命令之后，在source/_post文件夹里面就会出现一个“这是一个新的博客.md”的文件和一个“这是一个新的博客”的文件夹。 这是一个新的博客的图片 这是一个新的博客的图片 下一步就是把需要的图片放到新创建的那个文件夹里面去。 引用图片的第一种方法 {% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %} 用此种方法，而不是以前的![]()方法，前提是你的hexo的版本是hexo3以上，到package.json里面看一下吧。如果不是hexo3以上的版本，那就只能用第二种方法了。 例子 我现在写了一个段落，并且想在这个段落的某一个地方{% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %}引入一张图片在写作过程中乱码问题： 将博客文件保存为UTF-8即可解决问题。 方法： 1.将博客文件保存为UTF-8 用记事本打开本地的博客文件“xxx.md”，然后点“另存为”，“编码(E):”选择“UTF-8”，点击“保存”，替换原文件。 2.重新生成，部署，博客乱码即消除。","categories":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/categories/网站/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://edxuanlen.tk/tags/hexo/"}],"keywords":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/categories/网站/"}]},{"title":"hexo+github搭建个人博客","slug":"hexo-github搭建个人博客","date":"2018-01-24T12:50:02.000Z","updated":"2020-02-06T22:40:22.776Z","comments":true,"path":"2018/01/24/hexo-github搭建个人博客/","link":"","permalink":"https://edxuanlen.tk/2018/01/24/hexo-github搭建个人博客/","excerpt":"","text":"#hexo + GitHub + git 搭建个人博客 ** 安装配置node.js**安装配置node.js (http://www.runoob.com/nodejs/nodejs-install-setup.html)安装配置git：安装配置git：（(https://git-scm.com)）(https://jingyan.baidu.com/article/9f7e7ec0b17cac6f2815548d.html)）在GitHub上注册一个仓库：新建一个名为 你的用户名.github.io 的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。如果要绑定域名：域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下： 然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名可以不加www。比如edxuanlen.io 另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 过程中可能需要到购买域名的地方修改一下它的DNS： Nameserver 1 ns2.alidns.com Nameserver 1 ns1.alidns.comhexo的下载和安装：1、利用 npm 命令即可安装。在任意位置点击鼠标右键，选择Git Bash输入命令：npm install -g hexo 2、创建文件夹（我的是在E盘创建的Hexo），然后在Hexo文件下，右键运行Git Bash，输入命令：hexo init在_config.yml,进行基础配置 3、 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 ** 部分报错 ** 1.找不到git部署 ERROR Deployer not found: git 解决方法 npm install hexo-deployer-git --save 3.部署类型设置git hexo 3.0 部署类型不再是github，_config.yml 中修改 # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master 4. xcodebuild xcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance npm install bcrypt 5. RSS不显示 安装RSS插件 npm install hexo-generator-feed --save 开启RSS功能 编辑hexo/_config.yml，添加如下代码：1rss: /atom.xml #rss地址 默认即可 ** hexo d 没办法用：**正常来说只要安装了就能用了 一开始卡在死活用不了hexo d 最后发现== 我在config.yml 里面把原来我写的repository：改成repo就行了==1234567891011121314$ hexo dINFO Deploying: gitYou have to configure the deployment settings in _config.yml first!For more help, you can check the docs: http://hexo.io/docs/deployment.htmlINFO Deploy done: gitExample: deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] extend_dirs: [extend directory] warning: “warning:LF will be replacee by CRLF”：在Windows环境下使用git进行add的时候，会提示如下warning: “warning:LF will be replacee by CRLF”。 这是因为在Windows中的换行符为CRLF，而在Linux中的换行符为LF。在git创建的项目中换行符为LF，而执行git add时，系统会提示LF将被转换为CRLF。解决的办法很简单，禁止git的自动转换即可。 $ git config --global core.autocrlf false //禁用自动转换然后再进行git操作即可。如果项目已经创建，则需要先删除之前创建的.git 文件后添加上面的设置。$ rm -rf .git $ git config --globalcore.autocrlf false **完成后再重新执行git操作** $ git init $ git add . $ git remote add P.S. CRLF : Carriage-Return Line-Feed 回车换行。即回车(CR,ASCII 13, \\r)换行(LF, ASCII 10, \\n). 在windows中使用回车换行标识一行的结束，而Linux中则只有换行符。 ** 主题使用主题：**我用了bluelake ,详情转至bluelake主题配置介绍：http://blog.csdn.net/edxuanlen/article/details/79149778** 文章编辑器的使用方法：**markdown：https://coding.net/help/doc/project/markdown.html#i-5 注意 所有markdown标志后面要有一个空格 如果标题上一行是列表，则必须在标题和列表之间空一行 “`代码注释上下都空一行。（github是没问题，csdn如果不空行界面会不好看）###标题 # 一级标题 ## 二级标题 ### 三级标题 列表 - 无序列表1 - 无序列表2 - 无序列表3 1. 有序列表1 //注意1.后面有空格 2. 有序列表2 3. 有序列表3 引用 &gt;这个是引用 粗体 **这个是粗体** *这个是斜体* ***这个是粗体加斜体*** 链接和图片 [link text](http://example.com/ “optional title”) ![图片描述](链接) 代码 ` ` ``` ``` 分割线 ************* ———————————— _____________________ markdown文档转为word,pdf 使用Pandoc https://www.zhihu.com/question/22972843/answer/30096928 安装Pandoc,使用Typora http://blog.csdn.net/u012814856/article/details/69258511** 图标设置：**在设置图标的时候一直没办法替换点原来的 后来发现 改名后的ico要放在所用主题的 source 下才行 而不是 根目录下的source（值得一提，解析24小时候 域名自带的logo才会消失）","categories":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/categories/网站/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://edxuanlen.tk/tags/hexo/"}],"keywords":[{"name":"网站","slug":"网站","permalink":"https://edxuanlen.tk/categories/网站/"}]}]}